.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE FL" 3 "" "" ""
.SH "NAME"
boost::container::flat_map
.SH "SYNOPSIS"
.\" value_type: Class template flat_map
.\" Class template flat_map: value_type
.\" value_compare: Class template flat_map
.\" Class template flat_map: value_compare
.\" upper_bound: Class template flat_map
.\" Class template flat_map: upper_bound
.\" swap: Class template flat_map
.\" Class template flat_map: swap
.\" stored_allocator_type: Class template flat_map
.\" Class template flat_map: stored_allocator_type
.\" size_type: Class template flat_map
.\" Class template flat_map: size_type
.\" shrink_to_fit: Class template flat_map
.\" Class template flat_map: shrink_to_fit
.\" reverse_iterator: Class template flat_map
.\" Class template flat_map: reverse_iterator
.\" reserve: Class template flat_map
.\" Class template flat_map: reserve
.\" rend: Class template flat_map
.\" Class template flat_map: rend
.\" reference: Class template flat_map
.\" Class template flat_map: reference
.\" rbegin: Class template flat_map
.\" Class template flat_map: rbegin
.\" pointer: Class template flat_map
.\" Class template flat_map: pointer
.\" nth: Class template flat_map
.\" Class template flat_map: nth
.\" movable_value_type: Class template flat_map
.\" Class template flat_map: movable_value_type
.\" mapped_type: Class template flat_map
.\" Class template flat_map: mapped_type
.\" lower_bound: Class template flat_map
.\" Class template flat_map: lower_bound
.\" key_type: Class template flat_map
.\" Class template flat_map: key_type
.\" key_compare: Class template flat_map
.\" Class template flat_map: key_compare
.\" iterator: Class template flat_map
.\" Class template flat_map: iterator
.\" insert: Class template flat_map
.\" Class template flat_map: insert
.\" index_of: Class template flat_map
.\" Class template flat_map: index_of
.\" get_stored_allocator: Class template flat_map
.\" Class template flat_map: get_stored_allocator
.\" flat_map: Class template flat_map
.\" Class template flat_map: flat_map
.\" find: Class template flat_map
.\" Class template flat_map: find
.\" erase: Class template flat_map
.\" Class template flat_map: erase
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" emplace: Class template flat_map
.\" Class template flat_map: emplace
.\" difference_type: Class template flat_map
.\" Class template flat_map: difference_type
.\" count: Class template flat_map
.\" Class template flat_map: count
.\" const_reverse_iterator: Class template flat_map
.\" Class template flat_map: const_reverse_iterator
.\" const_reference: Class template flat_map
.\" Class template flat_map: const_reference
.\" const_pointer: Class template flat_map
.\" Class template flat_map: const_pointer
.\" const_iterator: Class template flat_map
.\" Class template flat_map: const_iterator
.\" clear: Class template flat_map
.\" Class template flat_map: clear
.\" begin: Class template flat_map
.\" Class template flat_map: begin
.\" at: Class template flat_map
.\" Class template flat_map: at
.\" allocator_type: Class template flat_map
.\" Class template flat_map: allocator_type
.\" allocator_traits_type: Class template flat_map
.\" Class template flat_map: allocator_traits_type

.sp
.nf
// In header: <boost/container/flat_map\&.hpp>

template<typename Key, typename T, typename Compare = std::less<Key>, 
         typename Allocator = new_allocator< std::pair< Key, T> > > 
class flat_map {
public:
  // types
  typedef Key                                                              key_type;              
  typedef T                                                                mapped_type;           
  typedef std::pair< Key, T >                                              value_type;            
  typedef ::boost::container::allocator_traits< Allocator >                allocator_traits_type; 
  typedef boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                        allocator_type;        
  typedef implementation_defined                                           stored_allocator_type; 
  typedef implementation_defined                                           value_compare;         
  typedef Compare                                                          key_compare;           
  typedef implementation_defined                                           iterator;              
  typedef implementation_defined                                           const_iterator;        
  typedef implementation_defined                                           reverse_iterator;      
  typedef implementation_defined                                           const_reverse_iterator;
  typedef implementation_defined                                           movable_value_type;    

  // construct/copy/destruct
  flat_map();
  explicit flat_map(const Compare &, 
                    const allocator_type & = allocator_type());
  explicit flat_map(const allocator_type &);
  template<typename InputIterator> 
    flat_map(InputIterator, InputIterator, const Compare & = Compare(), 
             const allocator_type & = allocator_type());
  template<typename InputIterator> 
    flat_map(InputIterator, InputIterator, const allocator_type &);
  template<typename InputIterator> 
    flat_map(ordered_unique_range_t, InputIterator, InputIterator, 
             const Compare & = Compare(), 
             const allocator_type & = allocator_type());
  flat_map(std::initializer_list< value_type >, const Compare & = Compare(), 
           const allocator_type & = allocator_type());
  flat_map(std::initializer_list< value_type >, const allocator_type &);
  flat_map(ordered_unique_range_t, std::initializer_list< value_type >, 
           const Compare & = Compare(), 
           const allocator_type & = allocator_type());
  flat_map(const flat_map &);
  flat_map(flat_map &&);
  flat_map(const flat_map &, const allocator_type &);
  flat_map(flat_map &&, const allocator_type &);
  flat_map & operator=(const flat_map &);
  flat_map & operator=(flat_map &&) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
  flat_map & operator=(std::initializer_list< value_type >);

  // public member functions
  allocator_type get_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_iterator cbegin() const noexcept;
  const_iterator cend() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const noexcept;
  size_type size() const noexcept;
  size_type max_size() const noexcept;
  size_type capacity() const noexcept;
  void reserve(size_type);
  void shrink_to_fit();
  mapped_type & operator[](const key_type &);
  mapped_type & operator[](key_type &&);
  iterator nth(size_type) noexcept;
  const_iterator nth(size_type) const noexcept;
  size_type index_of(iterator) noexcept;
  size_type index_of(const_iterator) const noexcept;
  T & at(const key_type &);
  const T & at(const key_type &) const;
  template<class\&.\&.\&. Args> std::pair< iterator, bool > emplace(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace_hint(const_iterator, Args &&\&.\&.\&.);
  std::pair< iterator, bool > insert(const value_type &);
  std::pair< iterator, bool > insert(value_type &&);
  std::pair< iterator, bool > insert(movable_value_type &&);
  iterator insert(const_iterator, const value_type &);
  iterator insert(const_iterator, value_type &&);
  iterator insert(const_iterator, movable_value_type &&);
  template<typename InputIterator> void insert(InputIterator, InputIterator);
  template<typename InputIterator> 
    void insert(ordered_unique_range_t, InputIterator, InputIterator);
  void insert(std::initializer_list< value_type >);
  void insert(ordered_unique_range_t, std::initializer_list< value_type >);
  iterator erase(const_iterator);
  size_type erase(const key_type &);
  iterator erase(const_iterator, const_iterator);
  void swap(flat_map &) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
  void clear() noexcept;
  key_compare key_comp() const;
  value_compare value_comp() const;
  iterator find(const key_type &);
  const_iterator find(const key_type &) const;
  size_type count(const key_type &) const;
  iterator lower_bound(const key_type &);
  const_iterator lower_bound(const key_type &) const;
  iterator upper_bound(const key_type &);
  const_iterator upper_bound(const key_type &) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;

  // friend functions
  friend bool operator==(const flat_map &, const flat_map &);
  friend bool operator!=(const flat_map &, const flat_map &);
  friend bool operator<(const flat_map &, const flat_map &);
  friend bool operator>(const flat_map &, const flat_map &);
  friend bool operator<=(const flat_map &, const flat_map &);
  friend bool operator>=(const flat_map &, const flat_map &);
  friend void swap(flat_map &, flat_map &);
};
.fi
.SH "DESCRIPTION"
.PP
A
flat_map
is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of values of another type T based on the keys\&. The
flat_map
class supports random\-access iterators\&.
.PP
A
flat_map
satisfies all of the requirements of a container and of a reversible container and of an associative container\&. A
flat_map
also provides most operations described for unique keys\&. For a flat_map<Key,T> the key_type is Key and the value_type is std::pair<Key,T> (unlike std::map<Key, T> which value_type is std::pair<\fBconst\fR
Key, T>)\&.
.PP
Compare is the ordering function for Keys (e\&.g\&.
\fIstd::less<Key>\fR)\&.
.PP
Allocator is the allocator to allocate the value_types (e\&.g\&.
\fIallocator< std::pair<Key, T> >\fR)\&.
.PP
flat_map
is similar to std::map but it\'s implemented like an ordered vector\&. This means that inserting a new element into a
flat_map
invalidates previous iterators and references
.PP
Erasing an element invalidates iterators and references pointing to elements that come after (their keys are bigger) the erased element\&.
.PP
This container provides random\-access iterators\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Key
.fi

.sp
is the key_type of the map
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename T
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Compare = std::less<Key>
.fi

.sp
is the ordering function for Keys (e\&.g\&. \fIstd::less<Key>\fR)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator< std::pair< Key, T> >
.fi

.sp
is the allocator to allocate the value_types (e\&.g\&. \fIallocator< std::pair<Key, T> > \fR)\&.
.RE

.SS "flat_map public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
flat_map();
.fi

.sp
\fBEffects\fR: Default constructs an empty
flat_map\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit flat_map(const Compare & comp, 
                  const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified comparison object and allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit flat_map(const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  flat_map(InputIterator first, InputIterator last, 
           const Compare & comp = Compare(), 
           const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified comparison object and allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  flat_map(InputIterator first, InputIterator last, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  flat_map(ordered_unique_range_t, InputIterator first, InputIterator last, 
           const Compare & comp = Compare(), 
           const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified comparison object and allocator, and inserts elements from the ordered unique range [first ,last)\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [first ,last) must be ordered according to the predicate and must be unique values\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
flat_map(std::initializer_list< value_type > il, 
         const Compare & comp = Compare(), 
         const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified comparison object and allocator, and inserts elements from the range [il\&.begin() ,il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
flat_map(std::initializer_list< value_type > il, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified allocator, and inserts elements from the range [il\&.begin() ,il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
flat_map(ordered_unique_range_t, std::initializer_list< value_type > il, 
         const Compare & comp = Compare(), 
         const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_map
using the specified comparison object and allocator, and inserts elements from the ordered unique range [il\&.begin(), il\&.end())\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [il\&.begin(), il\&.end()) must be ordered according to the predicate and must be unique values\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
flat_map(const flat_map & x);
.fi

.sp
\fBEffects\fR: Copy constructs a
flat_map\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
flat_map(flat_map && x);
.fi

.sp
\fBEffects\fR: Move constructs a
flat_map\&. Constructs *this using x\'s resources\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBPostcondition\fR: x is emptied\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
flat_map(const flat_map & x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a
flat_map
using the specified allocator\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
flat_map(flat_map && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructs a
flat_map
using the specified allocator\&. Constructs *this using x\'s resources\&.
.sp
\fBComplexity\fR: Constant if x\&.get_allocator() == a, linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
flat_map & operator=(const flat_map & x);
.fi

.sp
\fBEffects\fR: Makes *this a copy of x\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
flat_map & operator=(flat_map && x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
.fi

.sp
\fBEffects\fR: Move constructs a
flat_map\&. Constructs *this using x\'s resources\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
flat_map & operator=(std::initializer_list< value_type > il);
.fi

\fBEffects\fR: Assign elements from il to *this .RE

.SS "flat_map public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a copy of the allocator that was passed to the object\'s constructor\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get_stored_allocator: Class template flat_map
.\" Class template flat_map: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get_stored_allocator: Class template flat_map
.\" Class template flat_map: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" begin: Class template flat_map
.\" Class template flat_map: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" begin: Class template flat_map
.\" Class template flat_map: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" rbegin: Class template flat_map
.\" Class template flat_map: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" rbegin: Class template flat_map
.\" Class template flat_map: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rend: Class template flat_map
.\" Class template flat_map: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rend: Class template flat_map
.\" Class template flat_map: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
\fBEffects\fR: Returns true if the container contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
size_type capacity() const noexcept;
.fi

.sp
\fBEffects\fR: Number of elements for which memory has been allocated\&. capacity() is always greater than or equal to size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" reserve: Class template flat_map
.\" Class template flat_map: reserve

.sp

.nf
void reserve(size_type cnt);
.fi

.sp
\fBEffects\fR: If n is less than or equal to capacity(), this call has no effect\&. Otherwise, it is a request for allocation of additional memory\&. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged\&. In either case, size() is unchanged\&.
.sp
\fBThrows\fR: If memory allocation allocation throws or T\'s copy constructor throws\&.
.sp
\fBNote\fR: If capacity() is less than "cnt", iterators and references to to values might be invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" shrink_to_fit: Class template flat_map
.\" Class template flat_map: shrink_to_fit

.sp

.nf
void shrink_to_fit();
.fi

\fBEffects\fR: Tries to deallocate the excess of memory created \fBThrows\fR: If memory allocation throws, or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
mapped_type & operator[](const key_type & k);
.fi

.sp
Effects: If there is no key equivalent to x in the
flat_map, inserts value_type(x, T()) into the
flat_map\&.
.sp
Returns: A reference to the mapped_type corresponding to x in *this\&.
.sp
Complexity: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
mapped_type & operator[](key_type && k);
.fi

.sp
Effects: If there is no key equivalent to x in the
flat_map, inserts value_type(move(x), T()) into the
flat_map
(the key is move\-constructed)
.sp
Returns: A reference to the mapped_type corresponding to x in *this\&.
.sp
Complexity: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" nth: Class template flat_map
.\" Class template flat_map: nth

.sp

.nf
iterator nth(size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" nth: Class template flat_map
.\" Class template flat_map: nth

.sp

.nf
const_iterator nth(size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns a const_iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" index_of: Class template flat_map
.\" Class template flat_map: index_of

.sp

.nf
size_type index_of(iterator p) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" index_of: Class template flat_map
.\" Class template flat_map: index_of

.sp

.nf
size_type index_of(const_iterator p) const noexcept;
.fi

.sp
\fBRequires\fR: begin() <= p <= end()\&.
.sp
\fBEffects\fR: Returns the index of the element pointed by p and size() if p == end()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" at: Class template flat_map
.\" Class template flat_map: at

.sp

.nf
T & at(const key_type & k);
.fi

.sp
Returns: A reference to the element whose key is equivalent to x\&.
.sp
Throws: An exception object of type out_of_range if no such element is present\&.
.sp
Complexity: logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" at: Class template flat_map
.\" Class template flat_map: at

.sp

.nf
const T & at(const key_type & k) const;
.fi

.sp
Returns: A reference to the element whose key is equivalent to x\&.
.sp
Throws: An exception object of type out_of_range if no such element is present\&.
.sp
Complexity: logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" emplace: Class template flat_map
.\" Class template flat_map: emplace

.sp

.nf
template<class\&.\&.\&. Args> std::pair< iterator, bool > emplace(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object x of type T constructed with std::forward<Args>(args)\&.\&.\&. if and only if there is no element in the container with key equivalent to the key of x\&.
.sp
\fBReturns\fR: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time plus linear insertion to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> 
  iterator emplace_hint(const_iterator hint, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the container if and only if there is no element in the container with key equivalent to the key of x\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
std::pair< iterator, bool > insert(const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts x if and only if there is no element in the container with key equivalent to the key of x\&.
.sp
\fBReturns\fR: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time plus linear insertion to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
std::pair< iterator, bool > insert(value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x\&.
.sp
\fBReturns\fR: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time plus linear insertion to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
std::pair< iterator, bool > insert(movable_value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value_type move constructed from the pair if and only if there is no element in the container with key equivalent to the key of x\&.
.sp
\fBReturns\fR: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time plus linear insertion to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
iterator insert(const_iterator p, const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
iterator insert(const_iterator p, value_type && x);
.fi

.sp
\fBEffects\fR: Inserts an element move constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
iterator insert(const_iterator p, movable_value_type && x);
.fi

.sp
\fBEffects\fR: Inserts an element move constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
template<typename InputIterator> 
  void insert(InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: first, last are not iterators into *this\&.
.sp
\fBEffects\fR: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
template<typename InputIterator> 
  void insert(ordered_unique_range_t, InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: first, last are not iterators into *this\&.
.sp
\fBRequires\fR: [first ,last) must be ordered according to the predicate and must be unique values\&.
.sp
\fBEffects\fR: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
void insert(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: inserts each element from the range [il\&.begin(), il\&.end()) if and only if there is no element with key equivalent to the key of that element\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from il\&.first() to il\&.end()) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" insert: Class template flat_map
.\" Class template flat_map: insert

.sp

.nf
void insert(ordered_unique_range_t, std::initializer_list< value_type > il);
.fi

.sp
\fBRequires\fR: [il\&.begin(), il\&.end()) must be ordered according to the predicate and must be unique values\&.
.sp
\fBEffects\fR: inserts each element from the range [il\&.begin(), il\&.end()) if and only if there is no element with key equivalent to the key of that element\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" erase: Class template flat_map
.\" Class template flat_map: erase

.sp

.nf
iterator erase(const_iterator p);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by p\&.
.sp
\fBReturns\fR: Returns an iterator pointing to the element immediately following q prior to the element being erased\&. If no such element exists, returns end()\&.
.sp
\fBComplexity\fR: Linear to the elements with keys bigger than p
.sp
\fBNote\fR: Invalidates elements with keys not less than the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" erase: Class template flat_map
.\" Class template flat_map: erase

.sp

.nf
size_type erase(const key_type & x);
.fi

.sp
\fBEffects\fR: Erases all elements in the container with key equivalent to x\&.
.sp
\fBReturns\fR: Returns the number of erased elements\&.
.sp
\fBComplexity\fR: Logarithmic search time plus erasure time linear to the elements with bigger keys\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" erase: Class template flat_map
.\" Class template flat_map: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

.sp
\fBEffects\fR: Erases all the elements in the range [first, last)\&.
.sp
\fBReturns\fR: Returns last\&.
.sp
\fBComplexity\fR: size()*N where N is the distance from first to last\&.
.sp
\fBComplexity\fR: Logarithmic search time plus erasure time linear to the elements with bigger keys\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" swap: Class template flat_map
.\" Class template flat_map: swap

.sp

.nf
void swap(flat_map & x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" clear: Class template flat_map
.\" Class template flat_map: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: erase(a\&.begin(),a\&.end())\&.
.sp
\fBPostcondition\fR: size() == 0\&.
.sp
\fBComplexity\fR: linear in size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the comparison object out of which a was constructed\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns an object of value_compare constructed out of the comparison object\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" find: Class template flat_map
.\" Class template flat_map: find

.sp

.nf
iterator find(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" find: Class template flat_map
.\" Class template flat_map: find

.sp

.nf
const_iterator find(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.s
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" count: Class template flat_map
.\" Class template flat_map: count

.sp

.nf
size_type count(const key_type & x) const;
.fi

.sp
\fBReturns\fR: The number of elements with key equivalent to x\&.
.sp
\fBComplexity\fR: log(size())+count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" lower_bound: Class template flat_map
.\" Class template flat_map: lower_bound

.sp

.nf
iterator lower_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" lower_bound: Class template flat_map
.\" Class template flat_map: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" upper_bound: Class template flat_map
.\" Class template flat_map: upper_bound

.sp

.nf
iterator upper_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" end: Class template flat_map
.\" Class template flat_map: end
.\" upper_bound: Class template flat_map
.\" Class template flat_map: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & x);
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & x) const;
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE

.SS "flat_map friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const flat_map & x, const flat_map & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const flat_map & x, const flat_map & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const flat_map & x, const flat_map & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const flat_map & x, const flat_map & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const flat_map & x, const flat_map & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const flat_map & x, const flat_map & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template flat_map
.\" Class template flat_map: swap

.sp

.nf
friend void swap(flat_map & x, flat_map & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


