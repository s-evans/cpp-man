.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::intrusive::unordered_set
.SH "SYNOPSIS"
.\" value_type: Class template unordered_set
.\" Class template unordered_set: value_type
.\" value_traits: Class template unordered_set
.\" Class template unordered_set: value_traits
.\" swap: Class template unordered_set
.\" Class template unordered_set: swap
.\" suggested_upper_bucket_count: Class template unordered_set
.\" Class template unordered_set: suggested_upper_bucket_count
.\" suggested_lower_bucket_count: Class template unordered_set
.\" Class template unordered_set: suggested_lower_bucket_count
.\" size_type: Class template unordered_set
.\" Class template unordered_set: size_type
.\" size: Class template unordered_set
.\" Class template unordered_set: size
.\" s_local_iterator_to: Class template unordered_set
.\" Class template unordered_set: s_local_iterator_to
.\" rehash: Class template unordered_set
.\" Class template unordered_set: rehash
.\" reference: Class template unordered_set
.\" Class template unordered_set: reference
.\" pointer: Class template unordered_set
.\" Class template unordered_set: pointer
.\" node_traits: Class template unordered_set
.\" Class template unordered_set: node_traits
.\" node_ptr: Class template unordered_set
.\" Class template unordered_set: node_ptr
.\" node_algorithms: Class template unordered_set
.\" Class template unordered_set: node_algorithms
.\" node: Class template unordered_set
.\" Class template unordered_set: node
.\" local_iterator_to: Class template unordered_set
.\" Class template unordered_set: local_iterator_to
.\" local_iterator: Class template unordered_set
.\" Class template unordered_set: local_iterator
.\" key_type: Class template unordered_set
.\" Class template unordered_set: key_type
.\" key_of_value: Class template unordered_set
.\" Class template unordered_set: key_of_value
.\" key_equal: Class template unordered_set
.\" Class template unordered_set: key_equal
.\" iterator_to: Class template unordered_set
.\" Class template unordered_set: iterator_to
.\" iterator: Class template unordered_set
.\" Class template unordered_set: iterator
.\" insert_commit_data: Class template unordered_set
.\" Class template unordered_set: insert_commit_data
.\" insert_commit: Class template unordered_set
.\" Class template unordered_set: insert_commit
.\" insert: Class template unordered_set
.\" Class template unordered_set: insert
.\" incremental_rehash: Class template unordered_set
.\" Class template unordered_set: incremental_rehash
.\" hasher: Class template unordered_set
.\" Class template unordered_set: hasher
.\" hash_bool_flags: Class template unordered_set
.\" Class template unordered_set: hash_bool_flags
.\" find: Class template unordered_set
.\" Class template unordered_set: find
.\" erase_and_dispose: Class template unordered_set
.\" Class template unordered_set: erase_and_dispose
.\" erase: Class template unordered_set
.\" Class template unordered_set: erase
.\" end: Class template unordered_set
.\" Class template unordered_set: end
.\" difference_type: Class template unordered_set
.\" Class template unordered_set: difference_type
.\" count: Class template unordered_set
.\" Class template unordered_set: count
.\" const_reference: Class template unordered_set
.\" Class template unordered_set: const_reference
.\" const_pointer: Class template unordered_set
.\" Class template unordered_set: const_pointer
.\" const_node_ptr: Class template unordered_set
.\" Class template unordered_set: const_node_ptr
.\" const_local_iterator: Class template unordered_set
.\" Class template unordered_set: const_local_iterator
.\" const_iterator: Class template unordered_set
.\" Class template unordered_set: const_iterator
.\" clone_from: Class template unordered_set
.\" Class template unordered_set: clone_from
.\" clear_and_dispose: Class template unordered_set
.\" Class template unordered_set: clear_and_dispose
.\" clear: Class template unordered_set
.\" Class template unordered_set: clear
.\" cend: Class template unordered_set
.\" Class template unordered_set: cend
.\" cbegin: Class template unordered_set
.\" Class template unordered_set: cbegin
.\" bucket_type: Class template unordered_set
.\" Class template unordered_set: bucket_type
.\" bucket_traits: Class template unordered_set
.\" Class template unordered_set: bucket_traits
.\" bucket_ptr: Class template unordered_set
.\" Class template unordered_set: bucket_ptr
.\" begin: Class template unordered_set
.\" Class template unordered_set: begin

.sp
.nf
// In header: <boost/intrusive/unordered_set\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class unordered_set : public boost::intrusive::hashtable< ValueTraits, VoidOrKeyOfValue, VoidOrKeyHash, VoidOrKeyEqual, BucketTraits, SizeType, BoolFlags|hash_bool_flags::unique_keys_pos >
{
public:
  // types
  typedef implementation_defined::value_type           value_type;          
  typedef implementation_defined::key_type             key_type;            
  typedef implementation_defined::key_of_value         key_of_value;        
  typedef implementation_defined::value_traits         value_traits;        
  typedef implementation_defined::bucket_traits        bucket_traits;       
  typedef implementation_defined::pointer              pointer;             
  typedef implementation_defined::const_pointer        const_pointer;       
  typedef implementation_defined::reference            reference;           
  typedef implementation_defined::const_reference      const_reference;     
  typedef implementation_defined::difference_type      difference_type;     
  typedef implementation_defined::size_type            size_type;           
  typedef implementation_defined::key_equal            key_equal;           
  typedef implementation_defined::hasher               hasher;              
  typedef implementation_defined::bucket_type          bucket_type;         
  typedef implementation_defined::bucket_ptr           bucket_ptr;          
  typedef implementation_defined::iterator             iterator;            
  typedef implementation_defined::const_iterator       const_iterator;      
  typedef implementation_defined::insert_commit_data   insert_commit_data;  
  typedef implementation_defined::local_iterator       local_iterator;      
  typedef implementation_defined::const_local_iterator const_local_iterator;
  typedef implementation_defined::node_traits          node_traits;         
  typedef implementation_defined::node                 node;                
  typedef implementation_defined::node_ptr             node_ptr;            
  typedef implementation_defined::const_node_ptr       const_node_ptr;      
  typedef implementation_defined::node_algorithms      node_algorithms;     

  // construct/copy/destruct
  explicit unordered_set(const bucket_traits &, const hasher & = hasher(), 
                         const key_equal & = key_equal(), 
                         const value_traits & = value_traits());
  template<typename Iterator> 
    unordered_set(Iterator, Iterator, const bucket_traits &, 
                  const hasher & = hasher(), const key_equal & = key_equal(), 
                  const value_traits & = value_traits());
  unordered_set(unordered_set &&);
  unordered_set & operator=(unordered_set &&);
  ~unordered_set();

  // public member functions
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  hasher hash_function() const;
  key_equal key_eq() const;
  bool empty() const;
  size_type size() const;
  void swap(unordered_set &);
  template<typename Cloner, typename Disposer> 
    void clone_from(const unordered_set &, Cloner, Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(unordered_set &&, Cloner, Disposer);
  std::pair< iterator, bool > insert(reference);
  template<typename Iterator> void insert(Iterator, Iterator);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    std::pair< iterator, bool > 
    insert_check(const KeyType &, KeyHasher, KeyEqual, insert_commit_data &);
  iterator insert_commit(reference, const insert_commit_data &);
  void erase(const_iterator);
  void erase(const_iterator, const_iterator);
  size_type erase(const key_type &);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    size_type erase(const KeyType &, KeyHasher, KeyEqual);
  template<typename Disposer> void erase_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    void erase_and_dispose(const_iterator, const_iterator, Disposer);
  template<typename Disposer> 
    size_type erase_and_dispose(const key_type &, Disposer);
  template<typename KeyType, typename KeyHasher, typename KeyEqual, 
           typename Disposer> 
    size_type erase_and_dispose(const KeyType &, KeyHasher, KeyEqual, 
                                Disposer);
  void clear();
  template<typename Disposer> void clear_and_dispose(Disposer);
  size_type count(const key_type &) const;
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    size_type count(const KeyType &, KeyHasher, KeyEqual) const;
  iterator find(const key_type &);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    iterator find(const KeyType &, KeyHasher, KeyEqual);
  const_iterator find(const key_type &) const;
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    const_iterator find(const KeyType &, KeyHasher, KeyEqual) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    std::pair< iterator, iterator > 
    equal_range(const KeyType &, KeyHasher, KeyEqual);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    std::pair< const_iterator, const_iterator > 
    equal_range(const KeyType &, KeyHasher, KeyEqual) const;
  iterator iterator_to(reference);
  const_iterator iterator_to(const_reference) const;
  local_iterator local_iterator_to(reference);
  const_local_iterator local_iterator_to(const_reference) const;
  size_type bucket_count() const;
  size_type bucket_size(size_type) const;
  size_type bucket(const key_type &) const;
  template<typename KeyType, typename KeyHasher> 
    size_type bucket(const KeyType &, KeyHasher) const;
  bucket_ptr bucket_pointer() const;
  local_iterator begin(size_type);
  const_local_iterator begin(size_type) const;
  const_local_iterator cbegin(size_type) const;
  local_iterator end(size_type);
  const_local_iterator end(size_type) const;
  const_local_iterator cend(size_type) const;
  void rehash(const bucket_traits &);
  bool incremental_rehash(bool = true);
  bool incremental_rehash(const bucket_traits &);
  size_type split_count() const;

  // public static functions
  static local_iterator s_local_iterator_to(reference);
  static const_local_iterator s_local_iterator_to(const_reference);
  static size_type suggested_upper_bucket_count(size_type);
  static size_type suggested_lower_bucket_count(size_type);
};
.fi
.SH "DESCRIPTION"
.PP
The class template
unordered_set
is an intrusive container, that mimics most of the interface of std::tr1::unordered_set as described in the C++ TR1\&.
.PP
unordered_set
is a semi\-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work:
unordered_set
needs a pointer to an array of type
bucket_type
to be passed in the constructor\&. This bucket array must have at least the same lifetime as the container\&. This makes the use of
unordered_set
more complicated than purely intrusive containers\&.
bucket_type
is default\-constructible, copyable and assignable
.PP
The template parameter
T
is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
base_hook<>/member_hook<>/value_traits<>,
constant_time_size<>,
size_type<>,
hash<>
and
equal<>
bucket_traits<>,
power_2_buckets<>
and
cache_begin<>\&.
.PP
unordered_set
only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket\&. Local iterators are faster and smaller\&.
.PP
It\'s not recommended to use non constant\-time size unordered_sets because several key functions, like "empty()", become non\-constant time functions\&. Non constant\-time size unordered_sets are mainly provided to support auto\-unlink hooks\&.
.PP
unordered_set, unlike std::unordered_set, does not make automatic rehashings nor offers functions related to a load factor\&. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment\&.
.PP
Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements\&. Iterators are only invalidated when rehasing\&.
.SS "unordered_set public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit unordered_set(const bucket_traits & b_traits, 
                       const hasher & hash_func = hasher(), 
                       const key_equal & equal_func = key_equal(), 
                       const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: buckets must not be being used by any other resource\&.
.sp
\fBEffects\fR: Constructs an empty
unordered_set, storing a reference to the bucket array and copies of the key_hasher and equal_func functors\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws\&.
.sp
\fBNotes\fR: buckets array must be disposed only after *this is disposed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" distance: Class template unordered_set
.\" Class template unordered_set: distance

.sp

.nf
template<typename Iterator> 
  unordered_set(Iterator b, Iterator e, const bucket_traits & b_traits, 
                const hasher & hash_func = hasher(), 
                const key_equal & equal_func = key_equal(), 
                const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: buckets must not be being used by any other resource and dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Constructs an empty container and inserts elements from [b, e)\&.
.sp
\fBComplexity\fR: If N is distance(b, e): Average case is O(N) (with a good hash function and with buckets_len >= N),worst case O(N^2)\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor or invocation of hasher or key_equal throws\&.
.sp
\fBNotes\fR: buckets array must be disposed only after *this is disposed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
unordered_set(unordered_set && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
unordered_set & operator=(unordered_set && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~unordered_set();
.fi

.sp
\fBEffects\fR: Detaches all elements from this\&. The objects in the
unordered_set
are not deleted (i\&.e\&. no destructors are called)\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the
unordered_set, if it\'s a safe\-mode or auto\-unlink value\&. Otherwise constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE

.SS "unordered_set public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" begin: Class template unordered_set
.\" Class template unordered_set: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the beginning of the
unordered_set\&.
.sp
\fBComplexity\fR: Amortized constant time\&. Worst case (empty
unordered_set): O(this\->bucket_count())
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" begin: Class template unordered_set
.\" Class template unordered_set: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the
unordered_set\&.
.sp
\fBComplexity\fR: Amortized constant time\&. Worst case (empty
unordered_set): O(this\->bucket_count())
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" cbegin: Class template unordered_set
.\" Class template unordered_set: cbegin

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the
unordered_set\&.
.sp
\fBComplexity\fR: Amortized constant time\&. Worst case (empty
unordered_set): O(this\->bucket_count())
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" end: Class template unordered_set
.\" Class template unordered_set: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the end of the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" end: Class template unordered_set
.\" Class template unordered_set: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" cend: Class template unordered_set
.\" Class template unordered_set: cend

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
hasher hash_function() const;
.fi

.sp
\fBEffects\fR: Returns the hasher object used by the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If hasher copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
key_equal key_eq() const;
.fi

.sp
\fBEffects\fR: Returns the key_equal object used by the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If key_equal copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container is empty\&.
.sp
\fBComplexity\fR: if constant\-time size and
cache_begin
options are disabled, average constant time (worst case, with empty() == true: O(this\->bucket_count())\&. Otherwise constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" size: Class template unordered_set
.\" Class template unordered_set: size

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of elements stored in the
unordered_set\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this if
constant_time_size
is false\&. Constant\-time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" swap: Class template unordered_set
.\" Class template unordered_set: swap

.sp

.nf
void swap(unordered_set & other);
.fi

.sp
\fBRequires\fR: buckets must not be being used by any other resource\&.
.sp
\fBEffects\fR: Constructs an empty
unordered_set, storing a reference to the bucket array and copies of the key_hasher and equal_func functors\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws\&.
.sp
\fBNotes\fR: buckets array must be disposed only after *this is disposed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" clone_from: Class template unordered_set
.\" Class template unordered_set: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(const unordered_set & src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw Cloner should yield to nodes that compare equal and produce the same hash than the original node\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this\&. The hash function and the equality predicate are copied from the source\&.
.sp
If
store_hash
option is true, this method does not use the hash function\&.
.sp
If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner or hasher throw or hash or equality predicate copying throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" clone_from: Class template unordered_set
.\" Class template unordered_set: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(unordered_set && src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw Cloner should yield to nodes that compare equal and produce the same hash than the original node\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this\&. The hash function and the equality predicate are copied from the source\&.
.sp
If
store_hash
option is true, this method does not use the hash function\&.
.sp
If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner or hasher throw or hash or equality predicate copying throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" insert: Class template unordered_set
.\" Class template unordered_set: insert

.sp

.nf
std::pair< iterator, bool > insert(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue
.sp
\fBEffects\fR: Tries to inserts value into the
unordered_set\&.
.sp
\fBReturns\fR: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true\&. If there is an equivalent value returns a pair containing an iterator to the already present value and false\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" distance: Class template unordered_set
.\" Class template unordered_set: distance
.\" insert: Class template unordered_set
.\" Class template unordered_set: insert

.sp

.nf
template<typename Iterator> void insert(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Equivalent to this\->insert_unique(t) for each element in [b, e)\&.
.sp
\fBComplexity\fR: Average case O(N), where N is distance(b, e)\&. Worst case O(N*this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Basic guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  std::pair< iterator, bool > 
  insert_check(const KeyType & key, KeyHasher hasher, 
               KeyEqual key_value_equal, insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Checks if a value can be inserted in the
unordered_set, using a user provided key instead of the value itself\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing an iterator to the already present value and false\&. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&. Strong guarantee\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant\-time\&.
.sp
"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the
unordered_set\&.
.sp
After a successful rehashing insert_commit_data remains valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" insert_commit: Class template unordered_set
.\" Class template unordered_set: insert_commit

.sp

.nf
iterator insert_commit(reference value, 
                       const insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: value must be an lvalue of type value_type\&. commit_data must have been obtained from a previous call to "insert_check"\&. No objects should have been inserted or erased from the
unordered_set
between the "insert_check" that filled "commit_data" and the call to "insert_commit"\&.
.sp
\fBEffects\fR: Inserts the value in the
unordered_set
using the information obtained from the "commit_data" that a previous "insert_check" filled\&.
.sp
\fBReturns\fR: An iterator to the newly inserted object\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function has only sense if a "insert_check" has been previously executed to fill "commit_data"\&. No value should be inserted or erased between the "insert_check" and "insert_commit" calls\&.
.sp
After a successful rehashing insert_commit_data remains valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" erase: Class template unordered_set
.\" Class template unordered_set: erase

.sp

.nf
void erase(const_iterator i);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by i\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" erase: Class template unordered_set
.\" Class template unordered_set: erase

.sp

.nf
void erase(const_iterator b, const_iterator e);
.fi

.sp
\fBEffects\fR: Erases the range pointed to by b end e\&.
.sp
\fBComplexity\fR: Average case O(distance(b, e)), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" erase: Class template unordered_set
.\" Class template unordered_set: erase

.sp

.nf
size_type erase(const key_type & key);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given value\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" erase: Class template unordered_set
.\" Class template unordered_set: erase

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  size_type erase(const KeyType & key, KeyHasher hash_func, 
                  KeyEqual equal_func);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Erases all the elements that have the same hash and compare equal with the given key\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" erase_and_dispose: Class template unordered_set
.\" Class template unordered_set: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  void erase_and_dispose(const_iterator i, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element pointed to by i\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" erase_and_dispose: Class template unordered_set
.\" Class template unordered_set: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  void erase_and_dispose(const_iterator b, const_iterator e, 
                         Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the range pointed to by b end e\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBComplexity\fR: Average case O(distance(b, e)), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" erase_and_dispose: Class template unordered_set
.\" Class template unordered_set: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  size_type erase_and_dispose(const key_type & key, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given value\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" erase_and_dispose: Class template unordered_set
.\" Class template unordered_set: erase_and_dispose

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual, 
         typename Disposer> 
  size_type erase_and_dispose(const KeyType & key, KeyHasher hash_func, 
                              KeyEqual equal_func, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "equal_func"\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" clear: Class template unordered_set
.\" Class template unordered_set: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all of the elements\&.
.sp
\fBComplexity\fR: Linear to the number of elements on the container\&. if it\'s a safe\-mode or auto\-unlink value_type\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" clear_and_dispose: Class template unordered_set
.\" Class template unordered_set: clear_and_dispose

.sp

.nf
template<typename Disposer> void clear_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all of the elements\&.
.sp
\fBComplexity\fR: Linear to the number of elements on the container\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" count: Class template unordered_set
.\" Class template unordered_set: count

.sp

.nf
size_type count(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given value
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" count: Class template unordered_set
.\" Class template unordered_set: count

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  size_type count(const KeyType & key, KeyHasher hash_func, 
                  KeyEqual equal_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Returns the number of contained elements with the given key
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal throw\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" end: Class template unordered_set
.\" Class template unordered_set: end
.\" find: Class template unordered_set
.\" Class template unordered_set: find

.sp

.nf
iterator find(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element is equal to "value" or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" end: Class template unordered_set
.\" Class template unordered_set: end
.\" find: Class template unordered_set
.\" Class template unordered_set: find

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  iterator find(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Finds an iterator to the first element whose key is "key" according to the given hash and equality functor or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" find: Class template unordered_set
.\" Class template unordered_set: find

.sp

.nf
const_iterator find(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given value
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" end: Class template unordered_set
.\" Class template unordered_set: end
.\" find: Class template unordered_set
.\" Class template unordered_set: find

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  const_iterator 
  find(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns a range containing all elements with values equivalent to value\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  std::pair< iterator, iterator > 
  equal_range(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Returns a range containing all elements with equivalent keys\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(key, hash_func, equal_func))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or the equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns a range containing all elements with values equivalent to value\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  std::pair< const_iterator, const_iterator > 
  equal_range(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Returns a range containing all elements with equivalent keys\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(key, hash_func, equal_func))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the hasher or equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" iterator_to: Class template unordered_set
.\" Class template unordered_set: iterator_to

.sp

.nf
iterator iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the internal hash function throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" iterator_to: Class template unordered_set
.\" Class template unordered_set: iterator_to

.sp

.nf
const_iterator iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the internal hash function throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" local_iterator_to: Class template unordered_set
.\" Class template unordered_set: local_iterator_to

.sp

.nf
local_iterator local_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" local_iterator_to: Class template unordered_set
.\" Class template unordered_set: local_iterator_to

.sp

.nf
const_local_iterator local_iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}

.sp

.nf
size_type bucket_count() const;
.fi

.sp
\fBEffects\fR: Returns the number of buckets passed in the constructor or the last rehash function\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}

.sp

.nf
size_type bucket_size(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns the number of elements in the nth bucket\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}

.sp

.nf
size_type bucket(const key_type & k) const;
.fi

.sp
\fBEffects\fR: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the hash functor throws\&.
.sp
\fBNote\fR: the return value is in the range [0, this\->bucket_count())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyHasher> 
  size_type bucket(const KeyType & k, KeyHasher hash_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
\fBEffects\fR: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If hash_func throws\&.
.sp
\fBNote\fR: the return value is in the range [0, this\->bucket_count())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}

.sp

.nf
bucket_ptr bucket_pointer() const;
.fi

.sp
\fBEffects\fR: Returns the bucket array pointer passed in the constructor or the last rehash function\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" begin: Class template unordered_set
.\" Class template unordered_set: begin

.sp

.nf
local_iterator begin(size_type n);
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" begin: Class template unordered_set
.\" Class template unordered_set: begin

.sp

.nf
const_local_iterator begin(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" cbegin: Class template unordered_set
.\" Class template unordered_set: cbegin

.sp

.nf
const_local_iterator cbegin(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" end: Class template unordered_set
.\" Class template unordered_set: end

.sp

.nf
local_iterator end(size_type n);
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a local_iterator pointing to the end of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" end: Class template unordered_set
.\" Class template unordered_set: end

.sp

.nf
const_local_iterator end(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" cend: Class template unordered_set
.\" Class template unordered_set: cend

.sp

.nf
const_local_iterator cend(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" rehash: Class template unordered_set
.\" Class template unordered_set: rehash

.sp

.nf
void rehash(const bucket_traits & new_bucket_traits);
.fi

.sp
\fBRequires\fR: new_bucket_traits can hold a pointer to a new bucket array or the same as the old bucket array with a different length\&. new_size is the length of the the array pointed by new_buckets\&. If new_bucket_traits\&.bucket_begin() == this\->bucket_pointer() new_bucket_traits\&.bucket_count() can be bigger or smaller than this\->bucket_count()\&. \'new_bucket_traits\' copy constructor should not throw\&.
.sp
\fBEffects\fR: Updates the internal reference with the new bucket, erases the values from the old bucket and inserts then in the new one\&. Bucket traits hold by *this is assigned from new_bucket_traits\&. If the container is configured as incremental<>, the split bucket is set to the new bucket_count()\&.
.sp
If
store_hash
option is true, this method does not use the hash function\&.
.sp
\fBComplexity\fR: Average case linear in this\->size(), worst case quadratic\&.
.sp
\fBThrows\fR: If the hasher functor throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" incremental_rehash: Class template unordered_set
.\" Class template unordered_set: incremental_rehash

.sp

.nf
bool incremental_rehash(bool grow = true);
.fi

.sp
\fBRequires\fR:
.sp
\fBEffects\fR:
.sp
\fBComplexity\fR:
.sp
\fBThrows\fR:
.sp
\fBNote\fR: this method is only available if incremental<true> option is activated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" size: Class template unordered_set
.\" Class template unordered_set: size
.\" incremental_rehash: Class template unordered_set
.\" Class template unordered_set: incremental_rehash

.sp

.nf
bool incremental_rehash(const bucket_traits & new_bucket_traits);
.fi

.sp
\fBEffects\fR: If new_bucket_traits\&.bucket_count() is not this\->bucket_count()/2 or this\->bucket_count()*2, or this\->split_bucket() != new_bucket_traits\&.bucket_count() returns false and does nothing\&.
.sp
Otherwise, copy assigns new_bucket_traits to the internal
bucket_traits
and transfers all the objects from old buckets to the new ones\&.
.sp
\fBComplexity\fR: Linear to size()\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBNote\fR: this method is only available if incremental<true> option is activated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}

.sp

.nf
size_type split_count() const;
.fi

.sp
\fBRequires\fR: incremental<> option must be set
.sp
\fBEffects\fR: returns the current split count
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing
.RE

.SS "unordered_set public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" s_local_iterator_to: Class template unordered_set
.\" Class template unordered_set: s_local_iterator_to

.sp

.nf
static local_iterator s_local_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" s_local_iterator_to: Class template unordered_set
.\" Class template unordered_set: s_local_iterator_to

.sp

.nf
static const_local_iterator s_local_iterator_to(const_reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" suggested_upper_bucket_count: Class template unordered_set
.\" Class template unordered_set: suggested_upper_bucket_count

.sp

.nf
static size_type suggested_upper_bucket_count(size_type n);
.fi

.sp
\fBEffects\fR: Returns the nearest new bucket count optimized for the container that is bigger or equal than n\&. This suggestion can be used to create bucket arrays with a size that will usually improve container\'s performance\&. If such value does not exist, the higher possible value is returned\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" suggested_lower_bucket_count: Class template unordered_set
.\" Class template unordered_set: suggested_lower_bucket_count

.sp

.nf
static size_type suggested_lower_bucket_count(size_type n);
.fi

.sp
\fBEffects\fR: Returns the nearest new bucket count optimized for the container that is smaller or equal than n\&. This suggestion can be used to create bucket arrays with a size that will usually improve container\'s performance\&. If such value does not exist, the lowest possible value is returned\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


