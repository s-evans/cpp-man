.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPL" 3 "" "" ""
.SH "NAME"
boost::container::allocator_traits
.SH "SYNOPSIS"
.\" void_pointer: Struct template allocator_traits
.\" Struct template allocator_traits: void_pointer
.\" value_type: Struct template allocator_traits
.\" Struct template allocator_traits: value_type
.\" type: Struct template allocator_traits
.\" Struct template allocator_traits: type
.\" size_type: Struct template allocator_traits
.\" Struct template allocator_traits: size_type
.\" reference: Struct template allocator_traits
.\" Struct template allocator_traits: reference
.\" propagate_on_container_swap: Struct template allocator_traits
.\" Struct template allocator_traits: propagate_on_container_swap
.\" propagate_on_container_move_assignment: Struct template allocator_traits
.\" Struct template allocator_traits: propagate_on_container_move_assignment
.\" propagate_on_container_copy_assignment: Struct template allocator_traits
.\" Struct template allocator_traits: propagate_on_container_copy_assignment
.\" portable_rebind_alloc: Struct template allocator_traits
.\" Struct template allocator_traits: portable_rebind_alloc
.\" pointer: Struct template allocator_traits
.\" Struct template allocator_traits: pointer
.\" is_partially_propagable: Struct template allocator_traits
.\" Struct template allocator_traits: is_partially_propagable
.\" is_always_equal: Struct template allocator_traits
.\" Struct template allocator_traits: is_always_equal
.\" difference_type: Struct template allocator_traits
.\" Struct template allocator_traits: difference_type
.\" destroy: Struct template allocator_traits
.\" Struct template allocator_traits: destroy
.\" deallocate: Struct template allocator_traits
.\" Struct template allocator_traits: deallocate
.\" construct: Struct template allocator_traits
.\" Struct template allocator_traits: construct
.\" const_void_pointer: Struct template allocator_traits
.\" Struct template allocator_traits: const_void_pointer
.\" const_reference: Struct template allocator_traits
.\" Struct template allocator_traits: const_reference
.\" const_pointer: Struct template allocator_traits
.\" Struct template allocator_traits: const_pointer
.\" allocator_type: Struct template allocator_traits
.\" Struct template allocator_traits: allocator_type
.\" allocator_traits: Struct template allocator_traits
.\" Struct template allocator_traits: allocator_traits
.\" allocate: Struct template allocator_traits
.\" Struct template allocator_traits: allocate

.sp
.nf
// In header: <boost/container/allocator_traits\&.hpp>

template<typename Allocator> 
struct allocator_traits {
  // types
  typedef Allocator                             allocator_type;                        
  typedef allocator_type::value_type            value_type;                            
  typedef unspecified                           pointer;                               
  typedef see_documentation                     const_pointer;                         
  typedef see_documentation                     reference;                             
  typedef see_documentation                     const_reference;                       
  typedef see_documentation                     void_pointer;                          
  typedef see_documentation                     const_void_pointer;                    
  typedef see_documentation                     difference_type;                       
  typedef see_documentation                     size_type;                             
  typedef see_documentation                     propagate_on_container_copy_assignment;
  typedef see_documentation                     propagate_on_container_move_assignment;
  typedef see_documentation                     propagate_on_container_swap;           
  typedef see_documentation                     is_always_equal;                       
  typedef see_documentation                     is_partially_propagable;               
  typedef see_documentation                     rebind_alloc;                          
  typedef allocator_traits< rebind_alloc< T > > rebind_traits;                         

  // member classes/structs/unions
  template<typename T> 
  struct portable_rebind_alloc {
    // types
    typedef see_documentation type;
  };

  // public static functions
  static pointer allocate(Allocator &, size_type);
  static void deallocate(Allocator &, pointer, size_type);
  static pointer allocate(Allocator &, size_type, const_void_pointer);
  template<typename T> static void destroy(Allocator &, T *) noexcept;
  static size_type max_size(const Allocator &) noexcept;
  static Allocator select_on_container_copy_construction(const Allocator &);
  template<typename T, class\&.\&.\&. Args> 
    static void construct(Allocator &, T *, Args &&\&.\&.\&.);
  static bool storage_is_unpropagable(const Allocator &, pointer) noexcept;
  static bool equal(const Allocator &, const Allocator &) noexcept;
};
.fi
.SH "DESCRIPTION"
.PP
The class template
allocator_traits
supplies a uniform interface to all allocator types\&. This class is a C++03\-compatible implementation of std::allocator_traits
.SS "allocator_traits public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" pointer: Struct template allocator_traits
.\" Struct template allocator_traits: pointer

typedef
unspecified
pointer;
.sp
Allocator::pointer if such a type exists; otherwise, value_type*
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" const_pointer: Struct template allocator_traits
.\" Struct template allocator_traits: const_pointer

typedef
see_documentation
const_pointer;
.sp
Allocator::const_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<const
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" reference: Struct template allocator_traits
.\" Struct template allocator_traits: reference

typedef
see_documentation
reference;
.sp
Non\-standard extension Allocator::reference if such a type exists; otherwise, value_type&
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" const_reference: Struct template allocator_traits
.\" Struct template allocator_traits: const_reference

typedef
see_documentation
const_reference;
.sp
Non\-standard extension Allocator::const_reference if such a type exists ; otherwise, const value_type&
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" void_pointer: Struct template allocator_traits
.\" Struct template allocator_traits: void_pointer

typedef
see_documentation
void_pointer;
.sp
Allocator::void_pointer if such a type exists ; otherwise, pointer_traits<pointer>::rebind<void>\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" const_void_pointer: Struct template allocator_traits
.\" Struct template allocator_traits: const_void_pointer

typedef
see_documentation
const_void_pointer;
.sp
Allocator::const_void_pointer if such a type exists ; otherwis e, pointer_traits<pointer>::rebind<const
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" difference_type: Struct template allocator_traits
.\" Struct template allocator_traits: difference_type

typedef
see_documentation
difference_type;
.sp
Allocator::difference_type if such a type exists ; otherwise, pointer_traits<pointer>::difference_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" size_type: Struct template allocator_traits
.\" Struct template allocator_traits: size_type

typedef
see_documentation
size_type;
.sp
Allocator::size_type if such a type exists ; otherwise, make_unsigned<difference_type>::type
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" propagate_on_container_copy_assignment: Struct template allocator_traits
.\" Struct template allocator_traits: propagate_on_container_copy_assignment

typedef
see_documentation
propagate_on_container_copy_assignment;
.sp
Allocator::propagate_on_container_copy_assignment if such a type exists, otherwise a type with an internal constant static boolean member
value
== false\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" propagate_on_container_move_assignment: Struct template allocator_traits
.\" Struct template allocator_traits: propagate_on_container_move_assignment

typedef
see_documentation
propagate_on_container_move_assignment;
.sp
Allocator::propagate_on_container_move_assignment if such a type exists, otherwise a type with an internal constant static boolean member
value
== false\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" propagate_on_container_swap: Struct template allocator_traits
.\" Struct template allocator_traits: propagate_on_container_swap

typedef
see_documentation
propagate_on_container_swap;
.sp
Allocator::propagate_on_container_swap if such a type exists, otherwise a type with an internal constant static boolean member
value
== false\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" is_always_equal: Struct template allocator_traits
.\" Struct template allocator_traits: is_always_equal

typedef
see_documentation
is_always_equal;
.sp
Allocator::is_always_equal if such a type exists, otherwise a type with an internal constant static boolean member
value
== is_empty<Allocator>::value
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" is_partially_propagable: Struct template allocator_traits
.\" Struct template allocator_traits: is_partially_propagable

typedef
see_documentation
is_partially_propagable;
.sp
Allocator::is_partially_propagable if such a type exists, otherwise a type with an internal constant static boolean member
value
== false
\fBNote\fR: Non\-standard extension used to implement
small_vector_allocator\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

typedef
see_documentation
rebind_alloc;
.sp
Defines an allocator: Allocator::rebind<T>::other if such a type exists; otherwise, Allocator<T, Args> if Allocator is a class template instantiation of the form Allocator<U, Args>, where Args is zero or more type arguments ; otherwise, the instantiation of rebind_alloc is ill\-formed\&.
.sp
In C++03 compilers
rebind_alloc
is a struct derived from an allocator deduced by previously detailed rules\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

typedef
allocator_traits<
rebind_alloc<
T
>
>
rebind_traits;
.sp
In C++03 compilers
rebind_traits
is a struct derived from
allocator_traits<OtherAlloc>, where
OtherAlloc
is the allocator deduced by rules explained in
rebind_alloc\&.
.RE

.SS "allocator_traits public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" allocate: Struct template allocator_traits
.\" Struct template allocator_traits: allocate

.sp

.nf
static pointer allocate(Allocator & a, size_type n);
.fi

.sp
\fBReturns\fR:
a\&.allocate(n)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" deallocate: Struct template allocator_traits
.\" Struct template allocator_traits: deallocate

.sp

.nf
static void deallocate(Allocator & a, pointer p, size_type n);
.fi

.sp
\fBReturns\fR:
a\&.deallocate(p, n)
.sp
\fBThrows\fR: Nothing
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" allocate: Struct template allocator_traits
.\" Struct template allocator_traits: allocate

.sp

.nf
static pointer allocate(Allocator & a, size_type n, const_void_pointer p);
.fi

.sp
\fBEffects\fR: calls
a\&.allocate(n, p)
if that call is well\-formed; otherwise, invokes
a\&.allocate(n)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" destroy: Struct template allocator_traits
.\" Struct template allocator_traits: destroy

.sp

.nf
template<typename T> static void destroy(Allocator & a, T * p) noexcept;
.fi

.sp
\fBEffects\fR: calls
a\&.destroy(p)
if that call is well\-formed; otherwise, invokes
p\->~T()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
static size_type max_size(const Allocator & a) noexcept;
.fi

.sp
\fBReturns\fR:
a\&.max_size()
if that expression is well\-formed; otherwise,
numeric_limits<size_type>::max()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
static Allocator select_on_container_copy_construction(const Allocator & a);
.fi

.sp
\fBReturns\fR:
a\&.select_on_container_copy_construction()
if that expression is well\-formed; otherwise, a\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" construct: Struct template allocator_traits
.\" Struct template allocator_traits: construct

.sp

.nf
template<typename T, class\&.\&.\&. Args> 
  static void construct(Allocator & a, T * p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: calls
a\&.construct(p, std::forward<Args>(args)\&.\&.\&.)
if that call is well\-formed; otherwise, invokes
::new (static_cast<void*>(p)) T(std::forward<Args>(args)\&.\&.\&.)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
static bool storage_is_unpropagable(const Allocator & a, pointer p) noexcept;
.fi

.sp
\fBReturns\fR:
a\&.storage_is_unpropagable(p)
if is_partially_propagable::value is true; otherwise,
false\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
static bool equal(const Allocator & a, const Allocator & b) noexcept;
.fi

.sp
\fBReturns\fR:
true
if
is_always_equal::value == true, otherwise,
a == b\&.
.RE


