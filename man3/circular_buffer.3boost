.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLAT" 3 "" "" ""
.SH "NAME"
boost::circular_buffer \- Circular buffer \- a STL compliant container\&.
.SH "SYNOPSIS"
.\" value_type: Class template circular_buffer
.\" Class template circular_buffer: value_type
.\" this_type: Class template circular_buffer
.\" Class template circular_buffer: this_type
.\" swap_allocator: Class template circular_buffer
.\" Class template circular_buffer: swap_allocator
.\" size_type: Class template circular_buffer
.\" Class template circular_buffer: size_type
.\" set_capacity: Class template circular_buffer
.\" Class template circular_buffer: set_capacity
.\" rvalue_type: Class template circular_buffer
.\" Class template circular_buffer: rvalue_type
.\" rset_capacity: Class template circular_buffer
.\" Class template circular_buffer: rset_capacity
.\" rotate: Class template circular_buffer
.\" Class template circular_buffer: rotate
.\" rinsert_n: Class template circular_buffer
.\" Class template circular_buffer: rinsert_n
.\" rinsert_impl: Class template circular_buffer
.\" Class template circular_buffer: rinsert_impl
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert
.\" reverse_iterator: Class template circular_buffer
.\" Class template circular_buffer: reverse_iterator
.\" reset: Class template circular_buffer
.\" Class template circular_buffer: reset
.\" rerase: Class template circular_buffer
.\" Class template circular_buffer: rerase
.\" replace: Class template circular_buffer
.\" Class template circular_buffer: replace
.\" reference: Class template circular_buffer
.\" Class template circular_buffer: reference
.\" push_front_impl: Class template circular_buffer
.\" Class template circular_buffer: push_front_impl
.\" push_front: Class template circular_buffer
.\" Class template circular_buffer: push_front
.\" push_back_impl: Class template circular_buffer
.\" Class template circular_buffer: push_back_impl
.\" push_back: Class template circular_buffer
.\" Class template circular_buffer: push_back
.\" pop_front: Class template circular_buffer
.\" Class template circular_buffer: pop_front
.\" pop_back: Class template circular_buffer
.\" Class template circular_buffer: pop_back
.\" pointer: Class template circular_buffer
.\" Class template circular_buffer: pointer
.\" param_value_type: Class template circular_buffer
.\" Class template circular_buffer: param_value_type
.\" linearize: Class template circular_buffer
.\" Class template circular_buffer: linearize
.\" iterator: Class template circular_buffer
.\" Class template circular_buffer: iterator
.\" insert_n: Class template circular_buffer
.\" Class template circular_buffer: insert_n
.\" insert_item: Class template circular_buffer
.\" Class template circular_buffer: insert_item
.\" insert_impl: Class template circular_buffer
.\" Class template circular_buffer: insert_impl
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert
.\" initialize_buffer: Class template circular_buffer
.\" Class template circular_buffer: initialize_buffer
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize
.\" front: Class template circular_buffer
.\" Class template circular_buffer: front
.\" erase_end: Class template circular_buffer
.\" Class template circular_buffer: erase_end
.\" erase_begin: Class template circular_buffer
.\" Class template circular_buffer: erase_begin
.\" erase: Class template circular_buffer
.\" Class template circular_buffer: erase
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" difference_type: Class template circular_buffer
.\" Class template circular_buffer: difference_type
.\" destroy_item: Class template circular_buffer
.\" Class template circular_buffer: destroy_item
.\" destroy_if_constructed: Class template circular_buffer
.\" Class template circular_buffer: destroy_if_constructed
.\" destroy_content: Class template circular_buffer
.\" Class template circular_buffer: destroy_content
.\" destroy: Class template circular_buffer
.\" Class template circular_buffer: destroy
.\" decrement: Class template circular_buffer
.\" Class template circular_buffer: decrement
.\" deallocate: Class template circular_buffer
.\" Class template circular_buffer: deallocate
.\" construct_or_replace: Class template circular_buffer
.\" Class template circular_buffer: construct_or_replace
.\" const_reverse_iterator: Class template circular_buffer
.\" Class template circular_buffer: const_reverse_iterator
.\" const_reference: Class template circular_buffer
.\" Class template circular_buffer: const_reference
.\" const_pointer: Class template circular_buffer
.\" Class template circular_buffer: const_pointer
.\" const_iterator: Class template circular_buffer
.\" Class template circular_buffer: const_iterator
.\" const_array_range: Class template circular_buffer
.\" Class template circular_buffer: const_array_range
.\" clear: Class template circular_buffer
.\" Class template circular_buffer: clear
.\" capacity_type: Class template circular_buffer
.\" Class template circular_buffer: capacity_type
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
.\" back: Class template circular_buffer
.\" Class template circular_buffer: back
.\" at: Class template circular_buffer
.\" Class template circular_buffer: at
.\" assign_n: Class template circular_buffer
.\" Class template circular_buffer: assign_n
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign
.\" array_two: Class template circular_buffer
.\" Class template circular_buffer: array_two
.\" array_range: Class template circular_buffer
.\" Class template circular_buffer: array_range
.\" array_one: Class template circular_buffer
.\" Class template circular_buffer: array_one
.\" allocator_type: Class template circular_buffer
.\" Class template circular_buffer: allocator_type
.\" allocate: Class template circular_buffer
.\" Class template circular_buffer: allocate
.\" add: Class template circular_buffer
.\" Class template circular_buffer: add

.sp
.nf
// In header: <boost/circular_buffer/base\&.hpp>

template<typename T, typename Alloc> 
class circular_buffer {
public:
  // types
  typedef circular_buffer< T, Alloc >                                                                                                     this_type;               // The type of this circular_buffer\&. 
  typedef boost::container::allocator_traits< Alloc >::value_type                                                                         value_type;              // The type of elements stored in the circular_buffer\&. 
  typedef boost::container::allocator_traits< Alloc >::pointer                                                                            pointer;                 // A pointer to an element\&. 
  typedef boost::container::allocator_traits< Alloc >::const_pointer                                                                      const_pointer;           // A const pointer to the element\&. 
  typedef boost::container::allocator_traits< Alloc >::reference                                                                          reference;               // A reference to an element\&. 
  typedef boost::container::allocator_traits< Alloc >::const_reference                                                                    const_reference;         // A const reference to an element\&. 
  typedef boost::container::allocator_traits< Alloc >::difference_type                                                                    difference_type;       
  typedef boost::container::allocator_traits< Alloc >::size_type                                                                          size_type;             
  typedef Alloc                                                                                                                           allocator_type;          // The type of an allocator used in the circular_buffer\&. 
  typedef cb_details::iterator< circular_buffer< T, Alloc >, cb_details::const_traits< boost::container::allocator_traits< Alloc > > >    const_iterator;          // A const (random access) iterator used to iterate through the circular_buffer\&. 
  typedef cb_details::iterator< circular_buffer< T, Alloc >, cb_details::nonconst_traits< boost::container::allocator_traits< Alloc > > > iterator;                // A (random access) iterator used to iterate through the circular_buffer\&. 
  typedef boost::reverse_iterator< const_iterator >                                                                                       const_reverse_iterator;  // A const iterator used to iterate backwards through a circular_buffer\&. 
  typedef boost::reverse_iterator< iterator >                                                                                             reverse_iterator;        // An iterator used to iterate backwards through a circular_buffer\&. 
  typedef std::pair< pointer, size_type >                                                                                                 array_range;           
  typedef std::pair< const_pointer, size_type >                                                                                           const_array_range;     
  typedef size_type                                                                                                                       capacity_type;         
  typedef const value_type &                                                                                                              param_value_type;        // A type representing the "best" way to pass the value_type to a method\&. 
  typedef value_type &&                                                                                                                   rvalue_type;           

  // construct/copy/destruct
  explicit circular_buffer(const allocator_type & = allocator_type()) noexcept;
  explicit circular_buffer(capacity_type, 
                           const allocator_type & = allocator_type());
  circular_buffer(size_type, param_value_type, 
                  const allocator_type & = allocator_type());
  circular_buffer(capacity_type, size_type, param_value_type, 
                  const allocator_type & = allocator_type());
  circular_buffer(const circular_buffer< T, Alloc > &);
  circular_buffer(circular_buffer< T, Alloc > &&) noexcept;
  template<typename InputIterator> 
    circular_buffer(InputIterator, InputIterator, 
                    const allocator_type & = allocator_type());
  template<typename InputIterator> 
    circular_buffer(capacity_type, InputIterator, InputIterator, 
                    const allocator_type & = allocator_type());
  circular_buffer< T, Alloc > & operator=(const circular_buffer< T, Alloc > &);
  circular_buffer< T, Alloc > & 
  operator=(circular_buffer< T, Alloc > &&) noexcept;
  ~circular_buffer();

  // public member functions
  allocator_type get_allocator() const noexcept;
  allocator_type & get_allocator() noexcept;
  iterator begin() noexcept;
  iterator end() noexcept;
  const_iterator begin() const noexcept;
  const_iterator end() const noexcept;
  reverse_iterator rbegin() noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  const_reverse_iterator rend() const noexcept;
  reference operator[](size_type);
  const_reference operator[](size_type) const;
  reference at(size_type);
  const_reference at(size_type) const;
  reference front();
  reference back();
  const_reference front() const;
  const_reference back() const;
  array_range array_one();
  array_range array_two();
  const_array_range array_one() const;
  const_array_range array_two() const;
  pointer linearize();
  bool is_linearized() const noexcept;
  void rotate(const_iterator);
  size_type size() const noexcept;
  size_type max_size() const noexcept;
  bool empty() const noexcept;
  bool full() const noexcept;
  size_type reserve() const noexcept;
  capacity_type capacity() const noexcept;
  void set_capacity(capacity_type);
  void resize(size_type, param_value_type = value_type());
  void rset_capacity(capacity_type);
  void rresize(size_type, param_value_type = value_type());
  void assign(size_type, param_value_type);
  void assign(capacity_type, size_type, param_value_type);
  template<typename InputIterator> void assign(InputIterator, InputIterator);
  template<typename InputIterator> 
    void assign(capacity_type, InputIterator, InputIterator);
  void swap(circular_buffer< T, Alloc > &) noexcept;
  void push_back(param_value_type);
  void push_back(rvalue_type);
  void push_back();
  void push_front(param_value_type);
  void push_front(rvalue_type);
  void push_front();
  void pop_back();
  void pop_front();
  iterator insert(iterator, param_value_type);
  iterator insert(iterator, rvalue_type);
  iterator insert(iterator);
  void insert(iterator, size_type, param_value_type);
  template<typename InputIterator> 
    void insert(iterator, InputIterator, InputIterator);
  iterator rinsert(iterator, param_value_type);
  iterator rinsert(iterator, rvalue_type);
  iterator rinsert(iterator);
  void rinsert(iterator, size_type, param_value_type);
  template<typename InputIterator> 
    void rinsert(iterator, InputIterator, InputIterator);
  iterator erase(iterator);
  iterator erase(iterator, iterator);
  iterator rerase(iterator);
  iterator rerase(iterator, iterator);
  void erase_begin(size_type);
  void erase_end(size_type);
  void clear() noexcept;

  // private member functions
  template<typename ValT> void push_back_impl(ValT);
  template<typename ValT> void push_front_impl(ValT);
  template<typename ValT> iterator insert_impl(iterator, ValT);
  template<typename ValT> iterator rinsert_impl(iterator, ValT);
  void check_position(size_type) const;
  template<typename Pointer> void increment(Pointer &) const;
  template<typename Pointer> void decrement(Pointer &) const;
  template<typename Pointer> Pointer add(Pointer, difference_type) const;
  template<typename Pointer> Pointer sub(Pointer, difference_type) const;
  pointer map_pointer(pointer) const;
  pointer allocate(size_type);
  void deallocate(pointer, size_type);
  bool is_uninitialized(const_pointer) const noexcept;
  void replace(pointer, param_value_type);
  void replace(pointer, rvalue_type);
  void construct_or_replace(bool, pointer, param_value_type);
  void construct_or_replace(bool, pointer, rvalue_type);
  void destroy_item(pointer);
  void destroy_if_constructed(pointer);
  void destroy_content();
  void destroy_content(const true_type &);
  void destroy_content(const false_type &);
  void destroy() noexcept;
  void initialize_buffer(capacity_type);
  void initialize_buffer(capacity_type, param_value_type);
  template<typename IntegralType> 
    void initialize(IntegralType, IntegralType, const true_type &);
  template<typename Iterator> 
    void initialize(Iterator, Iterator, const false_type &);
  template<typename InputIterator> 
    void initialize(InputIterator, InputIterator, 
                    const std::input_iterator_tag &);
  template<typename ForwardIterator> 
    void initialize(ForwardIterator, ForwardIterator, 
                    const std::forward_iterator_tag &);
  template<typename IntegralType> 
    void initialize(capacity_type, IntegralType, IntegralType, 
                    const true_type &);
  template<typename Iterator> 
    void initialize(capacity_type, Iterator, Iterator, const false_type &);
  template<typename InputIterator> 
    void initialize(capacity_type, InputIterator, InputIterator, 
                    const std::input_iterator_tag &);
  template<typename ForwardIterator> 
    void initialize(capacity_type, ForwardIterator, ForwardIterator, 
                    const std::forward_iterator_tag &);
  template<typename ForwardIterator> 
    void initialize(capacity_type, ForwardIterator, ForwardIterator, 
                    size_type);
  void reset(pointer, pointer, capacity_type);
  void swap_allocator(circular_buffer< T, Alloc > &, const true_type &);
  void swap_allocator(circular_buffer< T, Alloc > &, const false_type &);
  template<typename IntegralType> 
    void assign(IntegralType, IntegralType, const true_type &);
  template<typename Iterator> 
    void assign(Iterator, Iterator, const false_type &);
  template<typename InputIterator> 
    void assign(InputIterator, InputIterator, const std::input_iterator_tag &);
  template<typename ForwardIterator> 
    void assign(ForwardIterator, ForwardIterator, 
                const std::forward_iterator_tag &);
  template<typename IntegralType> 
    void assign(capacity_type, IntegralType, IntegralType, const true_type &);
  template<typename Iterator> 
    void assign(capacity_type, Iterator, Iterator, const false_type &);
  template<typename InputIterator> 
    void assign(capacity_type, InputIterator, InputIterator, 
                const std::input_iterator_tag &);
  template<typename ForwardIterator> 
    void assign(capacity_type, ForwardIterator, ForwardIterator, 
                const std::forward_iterator_tag &);
  template<typename Functor> 
    void assign_n(capacity_type, size_type, const Functor &);
  template<typename ValT> iterator insert_item(const iterator &, ValT);
  template<typename IntegralType> 
    void insert(const iterator &, IntegralType, IntegralType, 
                const true_type &);
  template<typename Iterator> 
    void insert(const iterator &, Iterator, Iterator, const false_type &);
  template<typename InputIterator> 
    void insert(iterator, InputIterator, InputIterator, 
                const std::input_iterator_tag &);
  template<typename ForwardIterator> 
    void insert(const iterator &, ForwardIterator, ForwardIterator, 
                const std::forward_iterator_tag &);
  template<typename Wrapper> 
    void insert_n(const iterator &, size_type, const Wrapper &);
  template<typename IntegralType> 
    void rinsert(const iterator &, IntegralType, IntegralType, 
                 const true_type &);
  template<typename Iterator> 
    void rinsert(const iterator &, Iterator, Iterator, const false_type &);
  template<typename InputIterator> 
    void rinsert(iterator, InputIterator, InputIterator, 
                 const std::input_iterator_tag &);
  template<typename ForwardIterator> 
    void rinsert(const iterator &, ForwardIterator, ForwardIterator, 
                 const std::forward_iterator_tag &);
  template<typename Wrapper> 
    void rinsert_n(const iterator &, size_type, const Wrapper &);
  void erase_begin(size_type, const true_type &);
  void erase_begin(size_type, const false_type &);
  void erase_end(size_type, const true_type &);
  void erase_end(size_type, const false_type &);
};
.fi
.SH "DESCRIPTION"
.PP

.PP \fBType Requirements T\fR. The T has to be \m[blue]\fBSGIAssignable\fR\m[]\&\s-2\u[1]\d\s+2 (SGI STL defined combination of \m[blue]\fBAssignable\fR\m[]\&\s-2\u[2]\d\s+2 and \m[blue]\fBCopyConstructible\fR\m[]\&\s-2\u[3]\d\s+2)\&. Moreover T has to be \m[blue]\fBDefaultConstructible\fR\m[]\&\s-2\u[4]\d\s+2 if supplied as a default parameter when invoking some of the circular_buffer\'s methods e\&.g\&. insert(iterator pos, const value_type& item = value_type())\&. And \m[blue]\fBEqualityComparable\fR\m[]\&\s-2\u[5]\d\s+2 and/or \m[blue]\fBLessThanComparable\fR\m[]\&\s-2\u[6]\d\s+2 if the circular_buffer will be compared with another container\&.
.PP \fBType Requirements Alloc\fR. The Alloc has to meet the allocator requirements imposed by STL\&.
.PP \fBDefault Alloc\fR. std::allocator<T>
For detailed documentation of the
circular_buffer
visit:
\m[blue]\fBhttp://www\&.boost\&.org/libs/circular_buffer/doc/circular_buffer\&.html\fR\m[]
.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of the elements stored in the circular_buffer\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Alloc
.fi

.sp
The allocator type used for all internal memory management\&.
.RE

.SS "circular_buffer public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" difference_type: Class template circular_buffer
.\" Class template circular_buffer: difference_type

typedef
boost::container::allocator_traits<
Alloc
>::difference_type
difference_type;
.sp
(A signed integral type used to represent the distance between two iterators\&.)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" size_type: Class template circular_buffer
.\" Class template circular_buffer: size_type

typedef
boost::container::allocator_traits<
Alloc
>::size_type
size_type;
.sp
(An unsigned integral type that can represent any non\-negative value of the container\'s distance type\&.)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" array_range: Class template circular_buffer
.\" Class template circular_buffer: array_range

typedef
std::pair<
pointer,
size_type
>
array_range;
.sp
(A typedef for the
\m[blue]\fBstd::pair\fR\m[]\&\s-2\u[7]\d\s+2
where its first element is a pointer to a beginning of an array and its second element represents a size of the array\&.)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" const_array_range: Class template circular_buffer
.\" Class template circular_buffer: const_array_range

typedef
std::pair<
const_pointer,
size_type
>
const_array_range;
.sp
(A typedef for the
\m[blue]\fBstd::pair\fR\m[]\&\s-2\u[7]\d\s+2
where its first element is a pointer to a beginning of a const array and its second element represents a size of the const array\&.)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" capacity_type: Class template circular_buffer
.\" Class template circular_buffer: capacity_type

typedef
size_type
capacity_type;
.sp
(Same as
size_type
\- defined for consistency with the __cbso class\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" rvalue_type: Class template circular_buffer
.\" Class template circular_buffer: rvalue_type

typedef
value_type
&&
rvalue_type;
.sp
A type representing rvalue from param type\&. On compilers without rvalue references support this type is the Boost\&.Moves type used for emulation\&.
.RE

.SS "circular_buffer public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" set_capacity: Class template circular_buffer
.\" Class template circular_buffer: set_capacity
.\" push_back: Class template circular_buffer
.\" Class template circular_buffer: push_back
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
explicit circular_buffer(const allocator_type & alloc = allocator_type()) noexcept;
.fi

Create an empty circular_buffer with zero capacity\&. 
.PP \fBComplexity\fR. Constant\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
Since Boost version 1\&.36 the behaviour of this constructor has changed\&. Now the constructor does not allocate any memory and both capacity and size are set to zero\&. Also note when inserting an element into a
circular_buffer
with zero capacity (e\&.g\&. by
push_back(const_reference)
or
insert(iterator, value_type)) nothing will be inserted and the size (as well as capacity) remains zero\&.
.sp .5v
.RE

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
You can explicitly set the capacity by calling the
set_capacity(capacity_type)
method or you can use the other constructor with the capacity specified\&.
.sp .5v
.RE

\fBSee Also:\fRcircular_buffer(capacity_type, const allocator_type& alloc), set_capacity(capacity_type)
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == 0 && size() == 0
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit circular_buffer(capacity_type buffer_capacity, 
                         const allocator_type & alloc = allocator_type());
.fi

Create an empty circular_buffer with the specified capacity\&. 
.PP \fBComplexity\fR. Constant\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
buffer_capacity
.RS 4
The maximum number of elements which can be stored in the
circular_buffer\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == buffer_capacity && size() == 0
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
circular_buffer(size_type n, param_value_type item, 
                const allocator_type & alloc = allocator_type());
.fi

Create a full circular_buffer with the specified capacity and filled with n copies of item\&. 
.PP \fBComplexity\fR. Linear (in the n)\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
item
.RS 4
The element the created
circular_buffer
will be filled with\&.
.RE
.PP
n
.RS 4
The number of elements the created
circular_buffer
will be filled with\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == n && full() && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this)[n \- 1] == item
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
circular_buffer(capacity_type buffer_capacity, size_type n, 
                param_value_type item, 
                const allocator_type & alloc = allocator_type());
.fi

Create a circular_buffer with the specified capacity and filled with n copies of item\&. 
.PP \fBComplexity\fR. Linear (in the n)\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
buffer_capacity
.RS 4
The capacity of the created
circular_buffer\&.
.RE
.PP
item
.RS 4
The element the created
circular_buffer
will be filled with\&.
.RE
.PP
n
.RS 4
The number of elements the created
circular_buffer
will be filled with\&.
.RE
.RE
.PP
Requires:
.RS 4
buffer_capacity >= n
.RE
.PP
Postconditions:
.RS 4
capacity() == buffer_capacity && size() == n && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this)[n \- 1] == item
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
circular_buffer(const circular_buffer< T, Alloc > & cb);
.fi

.sp
The copy constructor\&. Creates a copy of the specified
circular_buffer\&.
.PP \fBComplexity\fR. Linear (in the size of cb)\&.
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
The
circular_buffer
to be copied\&.
.RE
.RE
.PP
Postconditions:
.RS 4
*this == cb
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
circular_buffer(circular_buffer< T, Alloc > && cb) noexcept;
.fi

.sp
The move constructor\&. Move constructs a
circular_buffer
from
cb, leaving
cb
empty\&.
.PP \fBConstant.\fR.
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
circular_buffer
to \'steal\' value from\&.
.RE
.RE
.PP
Requires:
.RS 4
C++ compiler with rvalue references support\&.
.RE
.PP
Postconditions:
.RS 4
cb\&.empty()
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
template<typename InputIterator> 
  circular_buffer(InputIterator first, InputIterator last, 
                  const allocator_type & alloc = allocator_type());
.fi

Create a full circular_buffer filled with a copy of the range\&. 
.PP \fBComplexity\fR. Linear (in the std::distance(first, last))\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[8]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == std::distance(first, last) && full() && (*this)[0]== *first && (*this)[1] == *(first + 1) && \&.\&.\&. && (*this)[std::distance(first, last) \- 1] == *(last \- 1)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
template<typename InputIterator> 
  circular_buffer(capacity_type buffer_capacity, InputIterator first, 
                  InputIterator last, 
                  const allocator_type & alloc = allocator_type());
.fi

Create a circular_buffer with the specified capacity and filled with a copy of the range\&. 
.PP \fBComplexity\fR. Linear (in std::distance(first, last); in min[capacity, std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[9]\d\s+2)\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
buffer_capacity
.RS 4
The capacity of the created
circular_buffer\&.
.RE
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[8]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == buffer_capacity && size() <= std::distance(first, last) && (*this)[0]== *(last \- buffer_capacity) && (*this)[1] == *(last \- buffer_capacity + 1) && \&.\&.\&. && (*this)[buffer_capacity \- 1] == *(last \- 1)&#9618;.br&#9618;
&#9618;.br&#9618;
If the number of items to be copied from the range
[first, last)
is greater than the specified
buffer_capacity
then only elements from the range
[last \- buffer_capacity, last)
will be copied\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
circular_buffer< T, Alloc > & 
operator=(const circular_buffer< T, Alloc > & cb);
.fi

.sp
The assign operator\&. Makes this
circular_buffer
to become a copy of the specified
circular_buffer\&.
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to this circular_buffer (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of cb)\&.
\fBSee Also:\fRassign(size_type, const_reference), assign(capacity_type, size_type, const_reference), assign(InputIterator, InputIterator), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
The
circular_buffer
to be copied\&.
.RE
.RE
.PP
Postconditions:
.RS 4
*this == cb
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
circular_buffer< T, Alloc > & 
operator=(circular_buffer< T, Alloc > && cb) noexcept;
.fi

Move assigns content of cb to *this, leaving cb empty\&. 
.PP \fBComplexity\fR. Constant\&.
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
circular_buffer
to \'steal\' value from\&.
.RE
.RE
.PP
Requires:
.RS 4
C++ compiler with rvalue references support\&.
.RE
.PP
Postconditions:
.RS 4
cb\&.empty()
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end

.sp

.nf
~circular_buffer();
.fi

.sp
The destructor\&. Destroys the
circular_buffer\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (including iterators equal to end())\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer) for scalar types; linear for other types\&.
\fBSee Also:\fRclear()
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE

.SS "circular_buffer public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
Get the allocator\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRget_allocator() for obtaining an allocator reference\&.
.PP
Returns:
.RS 4
The allocator\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
allocator_type & get_allocator() noexcept;
.fi

.sp
Get the allocator reference\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This method was added in order to optimize obtaining of the allocator with a state, although use of stateful allocators in STL is discouraged\&.
.sp .5v
.RE

\fBSee Also:\fRget_allocator() const
.PP
Returns:
.RS 4
A reference to the allocator\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin

.sp

.nf
iterator begin() noexcept;
.fi

Get the iterator pointing to the beginning of the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRend(), rbegin(), rend()
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
A random access iterator pointing to the first element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
end()\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end

.sp

.nf
iterator end() noexcept;
.fi

Get the iterator pointing to the end of the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRbegin(), rbegin(), rend()
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
A random access iterator pointing to the element "one behind" the last element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
begin()\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

Get the const iterator pointing to the beginning of the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRend() const, rbegin() const, rend() const
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
A const random access iterator pointing to the first element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
end() const\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end

.sp

.nf
const_iterator end() const noexcept;
.fi

Get the const iterator pointing to the end of the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRbegin() const, rbegin() const, rend() const
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
A const random access iterator pointing to the element "one behind" the last element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
begin() const
const\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

Get the iterator pointing to the beginning of the "reversed" circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRrend(), begin(), end()
.PP
Returns:
.RS 4
A reverse random access iterator pointing to the last element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
rend()\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
reverse_iterator rend() noexcept;
.fi

Get the iterator pointing to the end of the "reversed" circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRrbegin(), begin(), end()
.PP
Returns:
.RS 4
A reverse random access iterator pointing to the element "one before" the first element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
rbegin()\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

Get the const iterator pointing to the beginning of the "reversed" circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRrend() const, begin() const, end() const
.PP
Returns:
.RS 4
A const reverse random access iterator pointing to the last element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
rend() const\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

Get the const iterator pointing to the end of the "reversed" circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRrbegin() const, begin() const, end() const
.PP
Returns:
.RS 4
A const reverse random access iterator pointing to the element "one before" the first element of the
circular_buffer\&. If the
circular_buffer
is empty it returns an iterator equal to the one returned by
rbegin() const\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
reference operator[](size_type index);
.fi

Get the element at the index position\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRat()
.PP
Parameters:
.RS 4
.PP
index
.RS 4
The position of the element\&.
.RE
.RE
.PP
Requires:
.RS 4
0 <= index && index < size()
.RE
.PP
Returns:
.RS 4
A reference to the element at the
index
position\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reference operator[](size_type index) const;
.fi

Get the element at the index position\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRat() const
.PP
Parameters:
.RS 4
.PP
index
.RS 4
The position of the element\&.
.RE
.RE
.PP
Requires:
.RS 4
0 <= index && index < size()
.RE
.PP
Returns:
.RS 4
A const reference to the element at the
index
position\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" at: Class template circular_buffer
.\" Class template circular_buffer: at

.sp

.nf
reference at(size_type index);
.fi

Get the element at the index position\&. 
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRoperator[]
.PP
Parameters:
.RS 4
.PP
index
.RS 4
The position of the element\&.
.RE
.RE
.PP
Returns:
.RS 4
A reference to the element at the
index
position\&.
.RE
.PP
Throws:
.RS 4
<code>std::out_of_range</code> when the
index
is invalid (when
index >= size())\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" at: Class template circular_buffer
.\" Class template circular_buffer: at

.sp

.nf
const_reference at(size_type index) const;
.fi

Get the element at the index position\&. 
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRoperator[] const
.PP
Parameters:
.RS 4
.PP
index
.RS 4
The position of the element\&.
.RE
.RE
.PP
Returns:
.RS 4
A const reference to the element at the
index
position\&.
.RE
.PP
Throws:
.RS 4
<code>std::out_of_range</code> when the
index
is invalid (when
index >= size())\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" front: Class template circular_buffer
.\" Class template circular_buffer: front

.sp

.nf
reference front();
.fi

.sp
Get the first element\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRback()
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
A reference to the first element of the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" back: Class template circular_buffer
.\" Class template circular_buffer: back

.sp

.nf
reference back();
.fi

.sp
Get the last element\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRfront()
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
A reference to the last element of the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" front: Class template circular_buffer
.\" Class template circular_buffer: front

.sp

.nf
const_reference front() const;
.fi

.sp
Get the first element\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRback() const
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
A const reference to the first element of the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" back: Class template circular_buffer
.\" Class template circular_buffer: back

.sp

.nf
const_reference back() const;
.fi

.sp
Get the last element\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRfront() const
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
A const reference to the last element of the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" write: Class template circular_buffer
.\" Class template circular_buffer: write
.\" linearize: Class template circular_buffer
.\" Class template circular_buffer: linearize
.\" array_two: Class template circular_buffer
.\" Class template circular_buffer: array_two
.\" array_one: Class template circular_buffer
.\" Class template circular_buffer: array_one
.\" array_two: Class template circular_buffer
.\" Class template circular_buffer: array_two
.\" array_one: Class template circular_buffer
.\" Class template circular_buffer: array_one

.sp

.nf
array_range array_one();
.fi

.sp
Get the first continuous array of the internal buffer\&. This method in combination with
array_two()
can be useful when passing the stored data into a legacy C API as an array\&. Suppose there is a
circular_buffer
of capacity 10, containing 7 characters
\'a\', \'b\', \&.\&.\&., \'g\'
where
buff[0] == \'a\',
buff[1] == \'b\', \&.\&.\&. and
buff[6] == \'g\':&#9618;.br&#9618;
&#9618;.br&#9618;
circular_buffer<char> buff(10);&#9618;.br&#9618;
&#9618;.br&#9618;
The internal representation is often not linear and the state of the internal buffer may look like this:&#9618;.br&#9618;
&#9618;.br&#9618;
|e|f|g| | | |a|b|c|d|&#9618;.br&#9618; end ___^&#9618;.br&#9618; begin _______^&#9618;.br&#9618;
&#9618;.br&#9618;
.sp
where
|a|b|c|d|
represents the "array one",
|e|f|g|
represents the "array two" and
| | | |
is a free space\&.&#9618;.br&#9618;
Now consider a typical C style function for writing data into a file:&#9618;.br&#9618;
&#9618;.br&#9618;
int write(int file_desc, char* buff, int num_bytes);&#9618;.br&#9618;
&#9618;.br&#9618;
There are two ways how to write the content of the
circular_buffer
into a file\&. Either relying on
array_one()
and
array_two()
methods and calling the write function twice:&#9618;.br&#9618;
&#9618;.br&#9618;
array_range ar = buff\&.array_one();&#9618;.br&#9618; write(file_desc, ar\&.first, ar\&.second);&#9618;.br&#9618; ar = buff\&.array_two();&#9618;.br&#9618; write(file_desc, ar\&.first, ar\&.second);&#9618;.br&#9618;
&#9618;.br&#9618;
Or relying on the
linearize()
method:&#9618;.br&#9618;
&#9618;.br&#9618;
write(file_desc, buff\&.linearize(), buff\&.size());&#9618;.br&#9618;
&#9618;.br&#9618;
Since the complexity of
array_one()
and
array_two()
methods is constant the first option is suitable when calling the write method is "cheap"\&. On the other hand the second option is more suitable when calling the write method is more "expensive" than calling the
linearize()
method whose complexity is linear\&.
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
In general invoking any method which modifies the internal state of the
circular_buffer
may delinearize the internal buffer and invalidate the array ranges returned by
array_one()
and
array_two()
(and their const versions)\&.
.sp .5v
.RE

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
In the case the internal buffer is linear e\&.g\&.
|a|b|c|d|e|f|g| | | |
the "array one" is represented by
|a|b|c|d|e|f|g|
and the "array two" does not exist (the
array_two()
method returns an array with the size
0)\&.
.sp .5v
.RE

\fBSee Also:\fRarray_two(), linearize()
.PP
Returns:
.RS 4
The array range of the first continuous array of the internal buffer\&. In the case the
circular_buffer
is empty the size of the returned array is
0\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" array_one: Class template circular_buffer
.\" Class template circular_buffer: array_one
.\" array_two: Class template circular_buffer
.\" Class template circular_buffer: array_two

.sp

.nf
array_range array_two();
.fi

.sp
Get the second continuous array of the internal buffer\&. This method in combination with
array_one()
can be useful when passing the stored data into a legacy C API as an array\&.
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRarray_one()
.PP
Returns:
.RS 4
The array range of the second continuous array of the internal buffer\&. In the case the internal buffer is linear or the
circular_buffer
is empty the size of the returned array is
0\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" array_two: Class template circular_buffer
.\" Class template circular_buffer: array_two
.\" array_one: Class template circular_buffer
.\" Class template circular_buffer: array_one

.sp

.nf
const_array_range array_one() const;
.fi

.sp
Get the first continuous array of the internal buffer\&. This method in combination with
array_two() const
can be useful when passing the stored data into a legacy C API as an array\&.
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRarray_two() const; array_one() for more details how to pass data into a legacy C API\&.
.PP
Returns:
.RS 4
The array range of the first continuous array of the internal buffer\&. In the case the
circular_buffer
is empty the size of the returned array is
0\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" array_one: Class template circular_buffer
.\" Class template circular_buffer: array_one
.\" array_two: Class template circular_buffer
.\" Class template circular_buffer: array_two

.sp

.nf
const_array_range array_two() const;
.fi

.sp
Get the second continuous array of the internal buffer\&. This method in combination with
array_one() const
can be useful when passing the stored data into a legacy C API as an array\&.
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRarray_one() const
.PP
Returns:
.RS 4
The array range of the second continuous array of the internal buffer\&. In the case the internal buffer is linear or the
circular_buffer
is empty the size of the returned array is
0\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" array_two: Class template circular_buffer
.\" Class template circular_buffer: array_two
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" linearize: Class template circular_buffer
.\" Class template circular_buffer: linearize

.sp

.nf
pointer linearize();
.fi

.sp
Linearize the internal buffer into a continuous array\&. This method can be useful when passing the stored data into a legacy C API as an array\&.
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end()); does not invalidate any iterators if the postcondition (the \fIEffect\fR) is already met prior calling this method\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer); constant if the postcondition (the \fIEffect\fR) is already met\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
In general invoking any method which modifies the internal state of the
circular_buffer
may delinearize the internal buffer and invalidate the returned pointer\&.
.sp .5v
.RE

\fBSee Also:\fRarray_one() and array_two() for the other option how to pass data into a legacy C API; is_linearized(), rotate(const_iterator)
.PP
Postconditions:
.RS 4
&(*this)[0] < &(*this)[1] < \&.\&.\&. < &(*this)[size() \- 1]
.RE
.PP
Returns:
.RS 4
A pointer to the beginning of the array or
0
if empty\&.
.RE
.PP
Throws:
.RS 4
<a href="circular_buffer/implementation\&.html#circular_buffer\&.implementation\&.exceptions_of_move_if_noexcept_t">Exceptions of move_if_noexcept(T&)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
bool is_linearized() const noexcept;
.fi

Is the circular_buffer linearized? 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRlinearize(), array_one(), array_two()
.PP
Returns:
.RS 4
true
if the internal buffer is linearized into a continuous array (i\&.e\&. the
circular_buffer
meets a condition
&(*this)[0] < &(*this)[1] < \&.\&.\&. < &(*this)[size() \- 1]);
false
otherwise\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rotate: Class template circular_buffer
.\" Class template circular_buffer: rotate

.sp

.nf
void rotate(const_iterator new_begin);
.fi

Rotate elements in the circular_buffer\&. A more effective implementation of
\m[blue]\fBstd::rotate\fR\m[]\&\s-2\u[10]\d\s+2\&.
.PP \fBException Safety\fR. Basic; no\-throw if the circular_buffer is full or new_begin points to begin() or if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. If m < n invalidates iterators pointing to the last m elements (\fBincluding\fR new_begin, but not iterators equal to end()) else invalidates iterators pointing to the first n elements; does not invalidate any iterators if the circular_buffer is full\&.
.PP \fBComplexity\fR. Linear (in (std::min)(m, n)); constant if the circular_buffer is full\&.
\fBSee Also:\fR\m[blue]\fBstd::rotate\fR\m[]\&\s-2\u[10]\d\s+2
.PP
Parameters:
.RS 4
.PP
new_begin
.RS 4
The new beginning\&.
.RE
.RE
.PP
Requires:
.RS 4
new_begin
is a valid iterator pointing to the
circular_buffer
\fBexcept\fR
its end\&.
.RE
.PP
Postconditions:
.RS 4
Before calling the method suppose:&#9618;.br&#9618;
&#9618;.br&#9618;
m == std::distance(new_begin, end())&#9618;.br&#9618;
n == std::distance(begin(), new_begin)
&#9618;.br&#9618;
val_0 == *new_begin, val_1 == *(new_begin + 1), \&.\&.\&. val_m == *(new_begin + m)&#9618;.br&#9618;
val_r1 == *(new_begin \- 1), val_r2 == *(new_begin \- 2), \&.\&.\&. val_rn == *(new_begin \- n)&#9618;.br&#9618;
&#9618;.br&#9618;
then after call to the method:&#9618;.br&#9618;
&#9618;.br&#9618;
val_0 == (*this)[0] && val_1 == (*this)[1] && \&.\&.\&. && val_m == (*this)[m \- 1] && val_r1 == (*this)[m + n \- 1] && val_r2 == (*this)[m + n \- 2] && \&.\&.\&. && val_rn == (*this)[m]
.RE
.PP
Throws:
.RS 4
See
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

Get the number of elements currently stored in the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRcapacity(), max_size(), reserve(), resize(size_type, const_reference)
.PP
Returns:
.RS 4
The number of elements stored in the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

Get the largest possible size or capacity of the circular_buffer\&. (It depends on allocator\'s max_size())\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRsize(), capacity(), reserve()
.PP
Returns:
.RS 4
The maximum size/capacity the
circular_buffer
can be set to\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

Is the circular_buffer empty? 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRfull()
.PP
Returns:
.RS 4
true
if there are no elements stored in the
circular_buffer;
false
otherwise\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}

.sp

.nf
bool full() const noexcept;
.fi

Is the circular_buffer full? 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRempty()
.PP
Returns:
.RS 4
true
if the number of elements stored in the
circular_buffer
equals the capacity of the
circular_buffer;
false
otherwise\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}

.sp

.nf
size_type reserve() const noexcept;
.fi

Get the maximum number of elements which can be inserted into the circular_buffer without overwriting any of already stored elements\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRcapacity(), size(), max_size()
.PP
Returns:
.RS 4
capacity() \- size()
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}

.sp

.nf
capacity_type capacity() const noexcept;
.fi

Get the capacity of the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRreserve(), size(), max_size(), set_capacity(capacity_type)
.PP
Returns:
.RS 4
The maximum number of elements which can be stored in the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" set_capacity: Class template circular_buffer
.\" Class template circular_buffer: set_capacity

.sp

.nf
void set_capacity(capacity_type new_capacity);
.fi

Change the capacity of the circular_buffer\&. 
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end()) if the new capacity is different from the original\&.
.PP \fBComplexity\fR. Linear (in min[size(), new_capacity])\&.
\fBSee Also:\fRrset_capacity(capacity_type), resize(size_type, const_reference)
.PP
Parameters:
.RS 4
.PP
new_capacity
.RS 4
The new capacity\&.
.RE
.RE
.PP
Requires:
.RS 4
If
T
is a move only type, then compiler shall support
noexcept
modifiers and move constructor of
T
must be marked with it (must not throw exceptions)\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == new_capacity && size() <= new_capacity&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer
is greater than the desired new capacity then number of
[size() \- new_capacity]
\fBlast\fR
elements will be removed and the new size will be equal to
new_capacity\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted, (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
void resize(size_type new_size, param_value_type item = value_type());
.fi

Change the size of the circular_buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end()) if the new size is greater than the current capacity\&. Invalidates iterators pointing to the removed elements if the new size is lower that the original size\&. Otherwise it does not invalidate any iterator\&.
.PP \fBComplexity\fR. Linear (in the new size of the circular_buffer)\&.
\fBSee Also:\fRrresize(size_type, const_reference), set_capacity(capacity_type)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element the
circular_buffer
will be filled with in order to gain the requested size\&. (See the
\fIEffect\fR\&.)
.RE
.PP
new_size
.RS 4
The new size\&.
.RE
.RE
.PP
Postconditions:
.RS 4
size() == new_size && capacity() >= new_size&#9618;.br&#9618;
&#9618;.br&#9618;
If the new size is greater than the current size, copies of
item
will be inserted at the
\fBback\fR
of the of the
circular_buffer
in order to achieve the desired size\&. In the case the resulting size exceeds the current capacity the capacity will be set to
new_size\&.&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer
is greater than the desired new size then number of
[size() \- new_size]
\fBlast\fR
elements will be removed\&. (The capacity will remain unchanged\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rset_capacity: Class template circular_buffer
.\" Class template circular_buffer: rset_capacity

.sp

.nf
void rset_capacity(capacity_type new_capacity);
.fi

Change the capacity of the circular_buffer\&. 
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end()) if the new capacity is different from the original\&.
.PP \fBComplexity\fR. Linear (in min[size(), new_capacity])\&.
\fBSee Also:\fRset_capacity(capacity_type), rresize(size_type, const_reference)
.PP
Parameters:
.RS 4
.PP
new_capacity
.RS 4
The new capacity\&.
.RE
.RE
.PP
Requires:
.RS 4
If
T
is a move only type, then compiler shall support
noexcept
modifiers and move constructor of
T
must be marked with it (must not throw exceptions)\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == new_capacity && size() <= new_capacity&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer
is greater than the desired new capacity then number of
[size() \- new_capacity]
\fBfirst\fR
elements will be removed and the new size will be equal to
new_capacity\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear

.sp

.nf
void rresize(size_type new_size, param_value_type item = value_type());
.fi

Change the size of the circular_buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end()) if the new size is greater than the current capacity\&. Invalidates iterators pointing to the removed elements if the new size is lower that the original size\&. Otherwise it does not invalidate any iterator\&.
.PP \fBComplexity\fR. Linear (in the new size of the circular_buffer)\&.
\fBSee Also:\fRresize(size_type, const_reference), rset_capacity(capacity_type)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element the
circular_buffer
will be filled with in order to gain the requested size\&. (See the
\fIEffect\fR\&.)
.RE
.PP
new_size
.RS 4
The new size\&.
.RE
.RE
.PP
Postconditions:
.RS 4
size() == new_size && capacity() >= new_size&#9618;.br&#9618;
&#9618;.br&#9618;
If the new size is greater than the current size, copies of
item
will be inserted at the
\fBfront\fR
of the of the
circular_buffer
in order to achieve the desired size\&. In the case the resulting size exceeds the current capacity the capacity will be set to
new_size\&.&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer
is greater than the desired new size then number of
[size() \- new_size]
\fBfirst\fR
elements will be removed\&. (The capacity will remain unchanged\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
void assign(size_type n, param_value_type item);
.fi

Assign n items into the circular_buffer\&. The content of the
circular_buffer
will be removed and replaced with
n
copies of the
item\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the n)\&.
\fBSee Also:\fRoperator=, assign(capacity_type, size_type, const_reference), assign(InputIterator, InputIterator), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element the
circular_buffer
will be filled with\&.
.RE
.PP
n
.RS 4
The number of elements the
circular_buffer
will be filled with\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == n && size() == n && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this) [n \- 1] == item
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
void assign(capacity_type buffer_capacity, size_type n, param_value_type item);
.fi

Assign n items into the circular_buffer specifying the capacity\&. The capacity of the
circular_buffer
will be set to the specified value and the content of the
circular_buffer
will be removed and replaced with
n
copies of the
item\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the n)\&.
\fBSee Also:\fRoperator=, assign(size_type, const_reference), assign(InputIterator, InputIterator), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
buffer_capacity
.RS 4
The new capacity\&.
.RE
.PP
item
.RS 4
The element the
circular_buffer
will be filled with\&.
.RE
.PP
n
.RS 4
The number of elements the
circular_buffer
will be filled with\&.
.RE
.RE
.PP
Requires:
.RS 4
capacity >= n
.RE
.PP
Postconditions:
.RS 4
capacity() == buffer_capacity && size() == n && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this) [n \- 1] == item
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename InputIterator> 
  void assign(InputIterator first, InputIterator last);
.fi

Assign a copy of the range into the circular_buffer\&. The content of the
circular_buffer
will be removed and replaced with copies of elements from the specified range\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the std::distance(first, last))\&.
\fBSee Also:\fRoperator=, assign(size_type, const_reference), assign(capacity_type, size_type, const_reference), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[8]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == std::distance(first, last) && size() == std::distance(first, last) && (*this)[0]== *first && (*this)[1] == *(first + 1) && \&.\&.\&. && (*this)[std::distance(first, last) \- 1] == *(last \- 1)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename InputIterator> 
  void assign(capacity_type buffer_capacity, InputIterator first, 
              InputIterator last);
.fi

Assign a copy of the range into the circular_buffer specifying the capacity\&. The capacity of the
circular_buffer
will be set to the specified value and the content of the
circular_buffer
will be removed and replaced with copies of elements from the specified range\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in std::distance(first, last); in min[capacity, std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[9]\d\s+2)\&.
\fBSee Also:\fRoperator=, assign(size_type, const_reference), assign(capacity_type, size_type, const_reference), assign(InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
buffer_capacity
.RS 4
The new capacity\&.
.RE
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[8]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == buffer_capacity && size() <= std::distance(first, last) && (*this)[0]== *(last \- buffer_capacity) && (*this)[1] == *(last \- buffer_capacity + 1) && \&.\&.\&. && (*this)[buffer_capacity \- 1] == *(last \- 1)&#9618;.br&#9618;
&#9618;.br&#9618;
If the number of items to be copied from the range
[first, last)
is greater than the specified
buffer_capacity
then only elements from the range
[last \- buffer_capacity, last)
will be copied\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}

.sp

.nf
void swap(circular_buffer< T, Alloc > & cb) noexcept;
.fi

Swap the contents of two circular_buffers\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators of both circular_buffers\&. (On the other hand the iterators still point to the same elements but within another container\&. If you want to rely on this feature you have to turn the \m[blue]\fBDebug Support\fR\m[]\&\s-2\u[12]\d\s+2 off otherwise an assertion will report an error if such invalidated iterator is used\&.)
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRswap(circular_buffer<T, Alloc>&, circular_buffer<T, Alloc>&)
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
The
circular_buffer
whose content will be swapped\&.
.RE
.RE
.PP
Postconditions:
.RS 4
this
contains elements of
cb
and vice versa; the capacity of
this
equals to the capacity of
cb
and vice versa\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" push_back: Class template circular_buffer
.\" Class template circular_buffer: push_back

.sp

.nf
void push_back(param_value_type item);
.fi

Insert a new element at the end of the circular_buffer\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators with the exception of iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpush_front(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" back: Class template circular_buffer
.\" Class template circular_buffer: back
if
capacity() > 0
then
back() == item&#9618;.br&#9618;
If the
circular_buffer
is full, the first element will be removed\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" push_back: Class template circular_buffer
.\" Class template circular_buffer: push_back

.sp

.nf
void push_back(rvalue_type item);
.fi

Insert a new element at the end of the circular_buffer using rvalue references or rvalues references emulation\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators with the exception of iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpush_front(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" back: Class template circular_buffer
.\" Class template circular_buffer: back
if
capacity() > 0
then
back() == item&#9618;.br&#9618;
If the
circular_buffer
is full, the first element will be removed\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Throws:
.RS 4
Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" push_back: Class template circular_buffer
.\" Class template circular_buffer: push_back

.sp

.nf
void push_back();
.fi

Insert a new default\-constructed element at the end of the circular_buffer\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators with the exception of iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpush_front(const_reference), pop_back(), pop_front()
.PP
Postconditions:
.RS 4
.\" back: Class template circular_buffer
.\" Class template circular_buffer: back
if
capacity() > 0
then
back() == item&#9618;.br&#9618;
If the
circular_buffer
is full, the first element will be removed\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Throws:
.RS 4
Whatever
T::T()
throws\&. Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" push_front: Class template circular_buffer
.\" Class template circular_buffer: push_front

.sp

.nf
void push_front(param_value_type item);
.fi

Insert a new element at the beginning of the circular_buffer\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators with the exception of iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpush_back(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" front: Class template circular_buffer
.\" Class template circular_buffer: front
if
capacity() > 0
then
front() == item&#9618;.br&#9618;
If the
circular_buffer
is full, the last element will be removed\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" push_front: Class template circular_buffer
.\" Class template circular_buffer: push_front

.sp

.nf
void push_front(rvalue_type item);
.fi

Insert a new element at the beginning of the circular_buffer using rvalue references or rvalues references emulation\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators with the exception of iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpush_back(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" front: Class template circular_buffer
.\" Class template circular_buffer: front
if
capacity() > 0
then
front() == item&#9618;.br&#9618;
If the
circular_buffer
is full, the last element will be removed\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Throws:
.RS 4
Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" push_front: Class template circular_buffer
.\" Class template circular_buffer: push_front

.sp

.nf
void push_front();
.fi

Insert a new default\-constructed element at the beginning of the circular_buffer\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators with the exception of iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpush_back(const_reference), pop_back(), pop_front()
.PP
Postconditions:
.RS 4
.\" front: Class template circular_buffer
.\" Class template circular_buffer: front
if
capacity() > 0
then
front() == item&#9618;.br&#9618;
If the
circular_buffer
is full, the last element will be removed\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Throws:
.RS 4
Whatever
T::T()
throws\&. Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" pop_back: Class template circular_buffer
.\" Class template circular_buffer: pop_back

.sp

.nf
void pop_back();
.fi

Remove the last element from the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Invalidates only iterators pointing to the removed element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpop_front(), push_back(const_reference), push_front(const_reference)
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Postconditions:
.RS 4
The last element is removed from the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" pop_front: Class template circular_buffer
.\" Class template circular_buffer: pop_front

.sp

.nf
void pop_front();
.fi

Remove the first element from the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Invalidates only iterators pointing to the removed element\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer)\&.
\fBSee Also:\fRpop_back(), push_back(const_reference), push_front(const_reference)
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Postconditions:
.RS 4
The first element is removed from the
circular_buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
iterator insert(iterator pos, param_value_type item);
.fi

.sp
Insert an element at the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements at the insertion point (including pos) and iterators behind the insertion point (towards the end; except iterators equal to end())\&. It also invalidates iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Linear (in std::distance(pos, end()))\&.
\fBSee Also:\fRinsert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
The
item
will be inserted at the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer
is full, the first element will be overwritten\&. If the
circular_buffer
is full and the
pos
points to
begin(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
Iterator to the inserted element or
begin()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
iterator insert(iterator pos, rvalue_type item);
.fi

.sp
Insert an element at the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements at the insertion point (including pos) and iterators behind the insertion point (towards the end; except iterators equal to end())\&. It also invalidates iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Linear (in std::distance(pos, end()))\&.
\fBSee Also:\fRinsert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
The
item
will be inserted at the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer
is full, the first element will be overwritten\&. If the
circular_buffer
is full and the
pos
points to
begin(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
Iterator to the inserted element or
begin()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
iterator insert(iterator pos);
.fi

.sp
Insert a default\-constructed element at the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements at the insertion point (including pos) and iterators behind the insertion point (towards the end; except iterators equal to end())\&. It also invalidates iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Linear (in std::distance(pos, end()))\&.
\fBSee Also:\fRinsert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator specifying the position where the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
The
item
will be inserted at the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer
is full, the first element will be overwritten\&. If the
circular_buffer
is full and the
pos
points to
begin(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
Iterator to the inserted element or
begin()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T()
throws\&. Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
void insert(iterator pos, size_type n, param_value_type item);
.fi

Insert n copies of the item at the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements at the insertion point (including pos) and iterators behind the insertion point (towards the end; except iterators equal to end())\&. It also invalidates iterators pointing to the overwritten elements\&.
.PP \fBComplexity\fR. Linear (in min[capacity(), std::distance(pos, end()) + n])\&.
.PP \fBExample\fR. Consider a circular_buffer with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting 5 elements at the position p:&#9618;.br&#9618; &#9618;.br&#9618; insert(p, (size_t)5, 0);&#9618;.br&#9618; &#9618;.br&#9618; actually only 4 elements get inserted and elements 1 and 2 are overwritten\&. This is due to the fact the insert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |0|0|0|0|3|4|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|0|0|0|0|0|3|4|\&.
\fBSee Also:\fRinsert(iterator, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element whose copies will be inserted\&.
.RE
.PP
n
.RS 4
The number of
items the to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
items will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
The number of
min[n, (pos \- begin()) + reserve()]
elements will be inserted at the position
pos\&.&#9618;.br&#9618;
The number of
min[pos \- begin(), max[0, n \- reserve()]]
elements will be overwritten at the beginning of the
circular_buffer\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
template<typename InputIterator> 
  void insert(iterator pos, InputIterator first, InputIterator last);
.fi

Insert the range [first, last) at the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements at the insertion point (including pos) and iterators behind the insertion point (towards the end; except iterators equal to end())\&. It also invalidates iterators pointing to the overwritten elements\&.
.PP \fBComplexity\fR. Linear (in [std::distance(pos, end()) + std::distance(first, last)]; in min[capacity(), std::distance(pos, end()) + std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[9]\d\s+2)\&.
.PP \fBExample\fR. Consider a circular_buffer with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting a range of elements at the position p:&#9618;.br&#9618; &#9618;.br&#9618; int array[] = { 5, 6, 7, 8, 9 };&#9618;.br&#9618; insert(p, array, array + 5);&#9618;.br&#9618; &#9618;.br&#9618; actually only elements 6, 7, 8 and 9 from the specified range get inserted and elements 1 and 2 are overwritten\&. This is due to the fact the insert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |6|7|8|9|3|4|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|5|6|7|8|9|3|4|\&.
\fBSee Also:\fRinsert(iterator, value_type), insert(iterator, size_type, value_type), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be inserted\&.
.RE
.PP
last
.RS 4
The end of the range to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the range will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.&#9618;.br&#9618;
Valid range
[first, last)
where
first
and
last
meet the requirements of an
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[8]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
Elements from the range
[first + max[0, distance(first, last) \- (pos \- begin()) \- reserve()], last)
will be inserted at the position
pos\&.&#9618;.br&#9618;
The number of
min[pos \- begin(), max[0, distance(first, last) \- reserve()]]
elements will be overwritten at the beginning of the
circular_buffer\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws if the
InputIterator
is not a move iterator\&. Whatever
T::operator = (const T&)
throws if the
InputIterator
is not a move iterator\&. Whatever
T::T(T&&)
throws if the
InputIterator
is a move iterator\&. Whatever
T::operator = (T&&)
throws if the
InputIterator
is a move iterator\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
iterator rinsert(iterator pos, param_value_type item);
.fi

.sp
Insert an element before the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements before the insertion point (towards the beginning and excluding pos)\&. It also invalidates iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Linear (in std::distance(begin(), pos))\&.
\fBSee Also:\fRrinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position before which the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
The
item
will be inserted before the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer
is full, the last element will be overwritten\&. If the
circular_buffer
is full and the
pos
points to
end(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
Iterator to the inserted element or
end()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
iterator rinsert(iterator pos, rvalue_type item);
.fi

.sp
Insert an element before the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements before the insertion point (towards the beginning and excluding pos)\&. It also invalidates iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Linear (in std::distance(begin(), pos))\&.
\fBSee Also:\fRrinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position before which the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
The
item
will be inserted before the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer
is full, the last element will be overwritten\&. If the
circular_buffer
is full and the
pos
points to
end(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
Iterator to the inserted element or
end()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
iterator rinsert(iterator pos);
.fi

.sp
Insert an element before the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements before the insertion point (towards the beginning and excluding pos)\&. It also invalidates iterators pointing to the overwritten element\&.
.PP \fBComplexity\fR. Linear (in std::distance(begin(), pos))\&.
\fBSee Also:\fRrinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator specifying the position before which the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
The
item
will be inserted before the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer
is full, the last element will be overwritten\&. If the
circular_buffer
is full and the
pos
points to
end(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
Iterator to the inserted element or
end()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T()
throws\&. Whatever
T::T(T&&)
throws\&. Whatever
T::operator = (T&&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
void rinsert(iterator pos, size_type n, param_value_type item);
.fi

Insert n copies of the item before the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements before the insertion point (towards the beginning and excluding pos)\&. It also invalidates iterators pointing to the overwritten elements\&.
.PP \fBComplexity\fR. Linear (in min[capacity(), std::distance(begin(), pos) + n])\&.
.PP \fBExample\fR. Consider a circular_buffer with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting 5 elements before the position p:&#9618;.br&#9618; &#9618;.br&#9618; rinsert(p, (size_t)5, 0);&#9618;.br&#9618; &#9618;.br&#9618; actually only 4 elements get inserted and elements 3 and 4 are overwritten\&. This is due to the fact the rinsert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |1|2|0|0|0|0|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|0|0|0|0|0|3|4|\&.
\fBSee Also:\fRrinsert(iterator, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element whose copies will be inserted\&.
.RE
.PP
n
.RS 4
The number of
items the to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
items will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.
.RE
.PP
Postconditions:
.RS 4
The number of
min[n, (end() \- pos) + reserve()]
elements will be inserted before the position
pos\&.&#9618;.br&#9618;
The number of
min[end() \- pos, max[0, n \- reserve()]]
elements will be overwritten at the end of the
circular_buffer\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
\m[blue]\fBExceptions of move_if_noexcept(T&)\fR\m[]\&\s-2\u[11]\d\s+2\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
template<typename InputIterator> 
  void rinsert(iterator pos, InputIterator first, InputIterator last);
.fi

Insert the range [first, last) before the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operations in the \fIThrows\fR section do not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the elements before the insertion point (towards the beginning and excluding pos)\&. It also invalidates iterators pointing to the overwritten elements\&.
.PP \fBComplexity\fR. Linear (in [std::distance(begin(), pos) + std::distance(first, last)]; in min[capacity(), std::distance(begin(), pos) + std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[9]\d\s+2)\&.
.PP \fBExample\fR. Consider a circular_buffer with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting a range of elements before the position p:&#9618;.br&#9618; &#9618;.br&#9618; int array[] = { 5, 6, 7, 8, 9 };&#9618;.br&#9618; insert(p, array, array + 5);&#9618;.br&#9618; &#9618;.br&#9618; actually only elements 5, 6, 7 and 8 from the specified range get inserted and elements 3 and 4 are overwritten\&. This is due to the fact the rinsert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |1|2|5|6|7|8|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|5|6|7|8|9|3|4|\&.
\fBSee Also:\fRrinsert(iterator, value_type), rinsert(iterator, size_type, value_type), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be inserted\&.
.RE
.PP
last
.RS 4
The end of the range to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the range will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer
or its end\&.&#9618;.br&#9618;
Valid range
[first, last)
where
first
and
last
meet the requirements of an
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[8]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
Elements from the range
[first, last \- max[0, distance(first, last) \- (end() \- pos) \- reserve()])
will be inserted before the position
pos\&.&#9618;.br&#9618;
The number of
min[end() \- pos, max[0, distance(first, last) \- reserve()]]
elements will be overwritten at the end of the
circular_buffer\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)
.RE
.PP
Throws:
.RS 4
Whatever
T::T(const T&)
throws if the
InputIterator
is not a move iterator\&. Whatever
T::operator = (const T&)
throws if the
InputIterator
is not a move iterator\&. Whatever
T::T(T&&)
throws if the
InputIterator
is a move iterator\&. Whatever
T::operator = (T&&)
throws if the
InputIterator
is a move iterator\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" erase: Class template circular_buffer
.\" Class template circular_buffer: erase

.sp

.nf
iterator erase(iterator pos);
.fi

.sp
Remove an element at the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the erased element and iterators pointing to the elements behind the erased element (towards the end; except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in std::distance(pos, end()))\&.
\fBSee Also:\fRerase(iterator, iterator), rerase(iterator), rerase(iterator, iterator), erase_begin(size_type), erase_end(size_type), clear()
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator pointing at the element to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
pos
is a valid iterator pointing to the
circular_buffer
(but not an
end())\&.
.RE
.PP
Postconditions:
.RS 4
The element at the position
pos
is removed\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
Iterator to the first element remaining beyond the removed element or
end()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
<a href="circular_buffer/implementation\&.html#circular_buffer\&.implementation\&.exceptions_of_move_if_noexcept_t">Exceptions of move_if_noexcept(T&)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" erase: Class template circular_buffer
.\" Class template circular_buffer: erase

.sp

.nf
iterator erase(iterator first, iterator last);
.fi

Erase the range [first, last)\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the erased elements and iterators pointing to the elements behind the erased range (towards the end; except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in std::distance(first, end()))\&.
\fBSee Also:\fRerase(iterator), rerase(iterator), rerase(iterator, iterator), erase_begin(size_type), erase_end(size_type), clear()
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be removed\&.
.RE
.PP
last
.RS 4
The end of the range to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.
.RE
.PP
Postconditions:
.RS 4
The elements from the range
[first, last)
are removed\&. (If
first == last
nothing is removed\&.)
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
Iterator to the first element remaining beyond the removed elements or
end()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
<a href="circular_buffer/implementation\&.html#circular_buffer\&.implementation\&.exceptions_of_move_if_noexcept_t">Exceptions of move_if_noexcept(T&)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" erase: Class template circular_buffer
.\" Class template circular_buffer: erase
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rerase: Class template circular_buffer
.\" Class template circular_buffer: rerase

.sp

.nf
iterator rerase(iterator pos);
.fi

.sp
Remove an element at the specified position\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the erased element and iterators pointing to the elements in front of the erased element (towards the beginning)\&.
.PP \fBComplexity\fR. Linear (in std::distance(begin(), pos))\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This method is symetric to the
erase(iterator)
method and is more effective than
erase(iterator)
if the iterator
pos
is close to the beginning of the
circular_buffer\&. (See the
\fIComplexity\fR\&.)
.sp .5v
.RE

\fBSee Also:\fRerase(iterator), erase(iterator, iterator), rerase(iterator, iterator), erase_begin(size_type), erase_end(size_type), clear()
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator pointing at the element to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
pos
is a valid iterator pointing to the
circular_buffer
(but not an
end())\&.
.RE
.PP
Postconditions:
.RS 4
The element at the position
pos
is removed\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
Iterator to the first element remaining in front of the removed element or
begin()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
<a href="circular_buffer/implementation\&.html#circular_buffer\&.implementation\&.exceptions_of_move_if_noexcept_t">Exceptions of move_if_noexcept(T&)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}
.\" erase: Class template circular_buffer
.\" Class template circular_buffer: erase
.\" Linear: Class template circular_buffer
.\" Class template circular_buffer: Linear
.\" rerase: Class template circular_buffer
.\" Class template circular_buffer: rerase

.sp

.nf
iterator rerase(iterator first, iterator last);
.fi

Erase the range [first, last)\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&.
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the erased elements and iterators pointing to the elements in front of the erased range (towards the beginning)\&.
.PP \fBComplexity\fR. Linear (in std::distance(begin(), last))\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This method is symetric to the
erase(iterator, iterator)
method and is more effective than
erase(iterator, iterator)
if
std::distance(begin(), first)
is lower that
std::distance(last, end())\&.
.sp .5v
.RE

\fBSee Also:\fRerase(iterator), erase(iterator, iterator), rerase(iterator), erase_begin(size_type), erase_end(size_type), clear()
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be removed\&.
.RE
.PP
last
.RS 4
The end of the range to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.
.RE
.PP
Postconditions:
.RS 4
The elements from the range
[first, last)
are removed\&. (If
first == last
nothing is removed\&.)
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer
.\" Class template circular_buffer: begin
Iterator to the first element remaining in front of the removed elements or
begin()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
<a href="circular_buffer/implementation\&.html#circular_buffer\&.implementation\&.exceptions_of_move_if_noexcept_t">Exceptions of move_if_noexcept(T&)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}
.\" rerase: Class template circular_buffer
.\" Class template circular_buffer: rerase
.\" erase_begin: Class template circular_buffer
.\" Class template circular_buffer: erase_begin

.sp

.nf
void erase_begin(size_type n);
.fi

Remove first n elements (with constant complexity for scalar types)\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&. (I\&.e\&. no throw in case of scalars\&.)
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the first n erased elements\&.
.PP \fBComplexity\fR. Constant (in n) for scalar types; linear for other types\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This method has been specially designed for types which do not require an explicit destructruction (e\&.g\&. integer, float or a pointer)\&. For these scalar types a call to a destructor is not required which makes it possible to implement the "erase from beginning" operation with a constant complexity\&. For non\-sacalar types the complexity is linear (hence the explicit destruction is needed) and the implementation is actually equivalent to
rerase(begin(), begin() + n)\&.
.sp .5v
.RE

\fBSee Also:\fRerase(iterator), erase(iterator, iterator), rerase(iterator), rerase(iterator, iterator), erase_end(size_type), clear()
.PP
Parameters:
.RS 4
.PP
n
.RS 4
The number of elements to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
n <= size()
.RE
.PP
Postconditions:
.RS 4
The
n
elements at the beginning of the
circular_buffer
will be removed\&.
.RE
.PP
Throws:
.RS 4
<a href="circular_buffer/implementation\&.html#circular_buffer\&.implementation\&.exceptions_of_move_if_noexcept_t">Exceptions of move_if_noexcept(T&)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}
.\" erase: Class template circular_buffer
.\" Class template circular_buffer: erase
.\" erase_end: Class template circular_buffer
.\" Class template circular_buffer: erase_end

.sp

.nf
void erase_end(size_type n);
.fi

Remove last n elements (with constant complexity for scalar types)\&. 
.PP \fBException Safety\fR. Basic; no\-throw if the operation in the \fIThrows\fR section does not throw anything\&. (I\&.e\&. no throw in case of scalars\&.)
.PP \fBIterator Invalidation\fR. Invalidates iterators pointing to the last n erased elements\&.
.PP \fBComplexity\fR. Constant (in n) for scalar types; linear for other types\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This method has been specially designed for types which do not require an explicit destructruction (e\&.g\&. integer, float or a pointer)\&. For these scalar types a call to a destructor is not required which makes it possible to implement the "erase from end" operation with a constant complexity\&. For non\-sacalar types the complexity is linear (hence the explicit destruction is needed) and the implementation is actually equivalent to
erase(end() \- n, end())\&.
.sp .5v
.RE

\fBSee Also:\fRerase(iterator), erase(iterator, iterator), rerase(iterator), rerase(iterator, iterator), erase_begin(size_type), clear()
.PP
Parameters:
.RS 4
.PP
n
.RS 4
The number of elements to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
n <= size()
.RE
.PP
Postconditions:
.RS 4
The
n
elements at the end of the
circular_buffer
will be removed\&.
.RE
.PP
Throws:
.RS 4
<a href="circular_buffer/implementation\&.html#circular_buffer\&.implementation\&.exceptions_of_move_if_noexcept_t">Exceptions of move_if_noexcept(T&)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'65.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "65." 4.2
.\}
.\" end: Class template circular_buffer
.\" Class template circular_buffer: end
.\" clear: Class template circular_buffer
.\" Class template circular_buffer: clear

.sp

.nf
void clear() noexcept;
.fi

Remove all stored elements from the circular_buffer\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer (except iterators equal to end())\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer) for scalar types; linear for other types\&.
\fBSee Also:\fR~circular_buffer(), erase(iterator), erase(iterator, iterator), rerase(iterator), rerase(iterator, iterator), erase_begin(size_type), erase_end(size_type)
.PP
Postconditions:
.RS 4
size() == 0
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE

.SS "circular_buffer private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" push_back_impl: Class template circular_buffer
.\" Class template circular_buffer: push_back_impl

.sp

.nf
template<typename ValT> void push_back_impl(ValT item);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" push_front_impl: Class template circular_buffer
.\" Class template circular_buffer: push_front_impl

.sp

.nf
template<typename ValT> void push_front_impl(ValT item);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" insert_impl: Class template circular_buffer
.\" Class template circular_buffer: insert_impl

.sp

.nf
template<typename ValT> iterator insert_impl(iterator pos, ValT item);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" rinsert_impl: Class template circular_buffer
.\" Class template circular_buffer: rinsert_impl

.sp

.nf
template<typename ValT> iterator rinsert_impl(iterator pos, ValT item);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void check_position(size_type index) const;
.fi

Check if the index is valid\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename Pointer> void increment(Pointer & p) const;
.fi

Increment the pointer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" decrement: Class template circular_buffer
.\" Class template circular_buffer: decrement

.sp

.nf
template<typename Pointer> void decrement(Pointer & p) const;
.fi

Decrement the pointer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" add: Class template circular_buffer
.\" Class template circular_buffer: add

.sp

.nf
template<typename Pointer> Pointer add(Pointer p, difference_type n) const;
.fi

Add n to the pointer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename Pointer> Pointer sub(Pointer p, difference_type n) const;
.fi

Subtract n from the pointer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
pointer map_pointer(pointer p) const;
.fi

Map the null pointer to virtual end of circular buffer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" allocate: Class template circular_buffer
.\" Class template circular_buffer: allocate

.sp

.nf
pointer allocate(size_type n);
.fi

Allocate memory\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" deallocate: Class template circular_buffer
.\" Class template circular_buffer: deallocate

.sp

.nf
void deallocate(pointer p, size_type n);
.fi

Deallocate memory\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
bool is_uninitialized(const_pointer p) const noexcept;
.fi

Does the pointer point to the uninitialized memory? .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" replace: Class template circular_buffer
.\" Class template circular_buffer: replace

.sp

.nf
void replace(pointer pos, param_value_type item);
.fi

Replace an element\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" replace: Class template circular_buffer
.\" Class template circular_buffer: replace

.sp

.nf
void replace(pointer pos, rvalue_type item);
.fi

Replace an element\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" construct_or_replace: Class template circular_buffer
.\" Class template circular_buffer: construct_or_replace

.sp

.nf
void construct_or_replace(bool construct, pointer pos, param_value_type item);
.fi

.sp
Construct or replace an element\&. construct
has to be set to
true
if and only if
pos
points to an uninitialized memory\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" construct_or_replace: Class template circular_buffer
.\" Class template circular_buffer: construct_or_replace

.sp

.nf
void construct_or_replace(bool construct, pointer pos, rvalue_type item);
.fi

.sp
Construct or replace an element\&. construct
has to be set to
true
if and only if
pos
points to an uninitialized memory\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" destroy_item: Class template circular_buffer
.\" Class template circular_buffer: destroy_item

.sp

.nf
void destroy_item(pointer p);
.fi

Destroy an item\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" destroy_if_constructed: Class template circular_buffer
.\" Class template circular_buffer: destroy_if_constructed

.sp

.nf
void destroy_if_constructed(pointer pos);
.fi

Destroy an item only if it has been constructed\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" destroy_content: Class template circular_buffer
.\" Class template circular_buffer: destroy_content

.sp

.nf
void destroy_content();
.fi

Destroy the whole content of the circular buffer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" destroy_content: Class template circular_buffer
.\" Class template circular_buffer: destroy_content

.sp

.nf
void destroy_content(const true_type &);
.fi

Specialized destroy_content method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" destroy_content: Class template circular_buffer
.\" Class template circular_buffer: destroy_content

.sp

.nf
void destroy_content(const false_type &);
.fi

Specialized destroy_content method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" destroy: Class template circular_buffer
.\" Class template circular_buffer: destroy

.sp

.nf
void destroy() noexcept;
.fi

Destroy content and free allocated memory\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" initialize_buffer: Class template circular_buffer
.\" Class template circular_buffer: initialize_buffer

.sp

.nf
void initialize_buffer(capacity_type buffer_capacity);
.fi

Initialize the internal buffer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" initialize_buffer: Class template circular_buffer
.\" Class template circular_buffer: initialize_buffer

.sp

.nf
void initialize_buffer(capacity_type buffer_capacity, param_value_type item);
.fi

Initialize the internal buffer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename IntegralType> 
  void initialize(IntegralType n, IntegralType item, const true_type &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename Iterator> 
  void initialize(Iterator first, Iterator last, const false_type &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename InputIterator> 
  void initialize(InputIterator first, InputIterator last, 
                  const std::input_iterator_tag &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename ForwardIterator> 
  void initialize(ForwardIterator first, ForwardIterator last, 
                  const std::forward_iterator_tag &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename IntegralType> 
  void initialize(capacity_type buffer_capacity, IntegralType n, 
                  IntegralType item, const true_type &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename Iterator> 
  void initialize(capacity_type buffer_capacity, Iterator first, 
                  Iterator last, const false_type &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename InputIterator> 
  void initialize(capacity_type buffer_capacity, InputIterator first, 
                  InputIterator last, const std::input_iterator_tag &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename ForwardIterator> 
  void initialize(capacity_type buffer_capacity, ForwardIterator first, 
                  ForwardIterator last, const std::forward_iterator_tag &);
.fi

Specialized initialize method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" initialize: Class template circular_buffer
.\" Class template circular_buffer: initialize

.sp

.nf
template<typename ForwardIterator> 
  void initialize(capacity_type buffer_capacity, ForwardIterator first, 
                  ForwardIterator last, size_type distance);
.fi

Initialize the circular buffer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" reset: Class template circular_buffer
.\" Class template circular_buffer: reset

.sp

.nf
void reset(pointer buff, pointer last, capacity_type new_capacity);
.fi

Reset the circular buffer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" swap_allocator: Class template circular_buffer
.\" Class template circular_buffer: swap_allocator

.sp

.nf
void swap_allocator(circular_buffer< T, Alloc > &, const true_type &);
.fi

Specialized method for swapping the allocator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" swap_allocator: Class template circular_buffer
.\" Class template circular_buffer: swap_allocator

.sp

.nf
void swap_allocator(circular_buffer< T, Alloc > & cb, const false_type &);
.fi

Specialized method for swapping the allocator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename IntegralType> 
  void assign(IntegralType n, IntegralType item, const true_type &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename Iterator> 
  void assign(Iterator first, Iterator last, const false_type &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename InputIterator> 
  void assign(InputIterator first, InputIterator last, 
              const std::input_iterator_tag &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename ForwardIterator> 
  void assign(ForwardIterator first, ForwardIterator last, 
              const std::forward_iterator_tag &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename IntegralType> 
  void assign(capacity_type new_capacity, IntegralType n, IntegralType item, 
              const true_type &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename Iterator> 
  void assign(capacity_type new_capacity, Iterator first, Iterator last, 
              const false_type &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename InputIterator> 
  void assign(capacity_type new_capacity, InputIterator first, 
              InputIterator last, const std::input_iterator_tag &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" assign: Class template circular_buffer
.\" Class template circular_buffer: assign

.sp

.nf
template<typename ForwardIterator> 
  void assign(capacity_type new_capacity, ForwardIterator first, 
              ForwardIterator last, const std::forward_iterator_tag &);
.fi

Specialized assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" assign_n: Class template circular_buffer
.\" Class template circular_buffer: assign_n

.sp

.nf
template<typename Functor> 
  void assign_n(capacity_type new_capacity, size_type n, const Functor & fnc);
.fi

Helper assign method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" insert_item: Class template circular_buffer
.\" Class template circular_buffer: insert_item

.sp

.nf
template<typename ValT> iterator insert_item(const iterator & pos, ValT item);
.fi

Helper insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
template<typename IntegralType> 
  void insert(const iterator & pos, IntegralType n, IntegralType item, 
              const true_type &);
.fi

Specialized insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
template<typename Iterator> 
  void insert(const iterator & pos, Iterator first, Iterator last, 
              const false_type &);
.fi

Specialized insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
template<typename InputIterator> 
  void insert(iterator pos, InputIterator first, InputIterator last, 
              const std::input_iterator_tag &);
.fi

Specialized insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" insert: Class template circular_buffer
.\" Class template circular_buffer: insert

.sp

.nf
template<typename ForwardIterator> 
  void insert(const iterator & pos, ForwardIterator first, 
              ForwardIterator last, const std::forward_iterator_tag &);
.fi

Specialized insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" insert_n: Class template circular_buffer
.\" Class template circular_buffer: insert_n

.sp

.nf
template<typename Wrapper> 
  void insert_n(const iterator & pos, size_type n, const Wrapper & wrapper);
.fi

Helper insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
template<typename IntegralType> 
  void rinsert(const iterator & pos, IntegralType n, IntegralType item, 
               const true_type &);
.fi

Specialized rinsert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
template<typename Iterator> 
  void rinsert(const iterator & pos, Iterator first, Iterator last, 
               const false_type &);
.fi

Specialized rinsert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
template<typename InputIterator> 
  void rinsert(iterator pos, InputIterator first, InputIterator last, 
               const std::input_iterator_tag &);
.fi

Specialized insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" rinsert: Class template circular_buffer
.\" Class template circular_buffer: rinsert

.sp

.nf
template<typename ForwardIterator> 
  void rinsert(const iterator & pos, ForwardIterator first, 
               ForwardIterator last, const std::forward_iterator_tag &);
.fi

Specialized rinsert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" rinsert_n: Class template circular_buffer
.\" Class template circular_buffer: rinsert_n

.sp

.nf
template<typename Wrapper> 
  void rinsert_n(const iterator & pos, size_type n, const Wrapper & wrapper);
.fi

Helper rinsert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" erase_begin: Class template circular_buffer
.\" Class template circular_buffer: erase_begin

.sp

.nf
void erase_begin(size_type n, const true_type &);
.fi

Specialized erase_begin method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" erase_begin: Class template circular_buffer
.\" Class template circular_buffer: erase_begin

.sp

.nf
void erase_begin(size_type n, const false_type &);
.fi

Specialized erase_begin method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" erase_end: Class template circular_buffer
.\" Class template circular_buffer: erase_end

.sp

.nf
void erase_end(size_type n, const true_type &);
.fi

Specialized erase_end method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" erase_end: Class template circular_buffer
.\" Class template circular_buffer: erase_end

.sp

.nf
void erase_end(size_type n, const false_type &);
.fi

Specialized erase_end method\&. .RE



    .PP
\fBJan Gaspar\fR

.RS 4
Author.
.RE

    20032004200520062007200820092010201120122013Jan Gaspar
    
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      
  