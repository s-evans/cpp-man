.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE SLI" 3 "" "" ""
.SH "NAME"
boost::container::slist
.SH "SYNOPSIS"
.\" value_type: Class template slist
.\" Class template slist: value_type
.\" unique: Class template slist
.\" Class template slist: unique
.\" swap: Class template slist
.\" Class template slist: swap
.\" stored_allocator_type: Class template slist
.\" Class template slist: stored_allocator_type
.\" sort: Class template slist
.\" Class template slist: sort
.\" slist: Class template slist
.\" Class template slist: slist
.\" size_type: Class template slist
.\" Class template slist: size_type
.\" resize: Class template slist
.\" Class template slist: resize
.\" remove_if: Class template slist
.\" Class template slist: remove_if
.\" remove: Class template slist
.\" Class template slist: remove
.\" reference: Class template slist
.\" Class template slist: reference
.\" push_front: Class template slist
.\" Class template slist: push_front
.\" previous: Class template slist
.\" Class template slist: previous
.\" pop_front: Class template slist
.\" Class template slist: pop_front
.\" pointer: Class template slist
.\" Class template slist: pointer
.\" merge: Class template slist
.\" Class template slist: merge
.\" iterator: Class template slist
.\" Class template slist: iterator
.\" insert_after: Class template slist
.\" Class template slist: insert_after
.\" insert: Class template slist
.\" Class template slist: insert
.\" get_stored_allocator: Class template slist
.\" Class template slist: get_stored_allocator
.\" front: Class template slist
.\" Class template slist: front
.\" erase_after: Class template slist
.\" Class template slist: erase_after
.\" erase: Class template slist
.\" Class template slist: erase
.\" end: Class template slist
.\" Class template slist: end
.\" emplace: Class template slist
.\" Class template slist: emplace
.\" difference_type: Class template slist
.\" Class template slist: difference_type
.\" const_reference: Class template slist
.\" Class template slist: const_reference
.\" const_pointer: Class template slist
.\" Class template slist: const_pointer
.\" const_iterator: Class template slist
.\" Class template slist: const_iterator
.\" clear: Class template slist
.\" Class template slist: clear
.\" begin: Class template slist
.\" Class template slist: begin
.\" assign: Class template slist
.\" Class template slist: assign
.\" allocator_type: Class template slist
.\" Class template slist: allocator_type

.sp
.nf
// In header: <boost/container/slist\&.hpp>

template<typename T, typename Allocator = new_allocator<T> > 
class slist {
public:
  // types
  typedef T                                                                  value_type;           
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;              
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;        
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;            
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;      
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;            
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;      
  typedef Allocator                                                          allocator_type;       
  typedef implementation_defined                                             stored_allocator_type;
  typedef implementation_defined                                             iterator;             
  typedef implementation_defined                                             const_iterator;       

  // construct/copy/destruct
  slist();
  explicit slist(const allocator_type &) noexcept;
  explicit slist(size_type);
  slist(size_type, const allocator_type &);
  explicit slist(size_type, const value_type &, 
                 const allocator_type & = allocator_type());
  template<typename InpIt> 
    slist(InpIt, InpIt, const allocator_type & = allocator_type());
  slist(std::initializer_list< value_type >, 
        const allocator_type & = allocator_type());
  slist(const slist &);
  slist(slist &&);
  slist(const slist &, const allocator_type &);
  slist(slist &&, const allocator_type &);
  slist & operator=(const slist &);
  slist & operator=(slist &&) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
  slist & operator=(std::initializer_list< value_type >);
  ~slist();

  // public member functions
  void assign(size_type, const T &);
  template<typename InpIt> void assign(InpIt, InpIt);
  void assign(std::initializer_list< value_type >);
  allocator_type get_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  iterator before_begin() noexcept;
  const_iterator before_begin() const noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  const_iterator cbefore_begin() const noexcept;
  const_iterator cbegin() const noexcept;
  const_iterator cend() const noexcept;
  iterator previous(iterator) noexcept;
  const_iterator previous(const_iterator);
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  void resize(size_type);
  void resize(size_type, const T &);
  reference front();
  const_reference front() const;
  template<class\&.\&.\&. Args> void emplace_front(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace_after(const_iterator, Args &&\&.\&.\&.);
  void push_front(const T &);
  void push_front(T &&);
  iterator insert_after(const_iterator, const T &);
  iterator insert_after(const_iterator, T &&);
  iterator insert_after(const_iterator, size_type, const value_type &);
  template<typename InpIt> iterator insert_after(const_iterator, InpIt, InpIt);
  iterator insert_after(const_iterator, std::initializer_list< value_type >);
  void pop_front();
  iterator erase_after(const_iterator);
  iterator erase_after(const_iterator, const_iterator);
  void swap(slist &) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
  void clear();
  void splice_after(const_iterator, slist &) noexcept;
  void splice_after(const_iterator, slist &&) noexcept;
  void splice_after(const_iterator, slist &, const_iterator) noexcept;
  void splice_after(const_iterator, slist &&, const_iterator) noexcept;
  void splice_after(const_iterator, slist &, const_iterator, const_iterator) noexcept;
  void splice_after(const_iterator, slist &&, const_iterator, const_iterator) noexcept;
  void splice_after(const_iterator, slist &, const_iterator, const_iterator, 
                    size_type) noexcept;
  void splice_after(const_iterator, slist &&, const_iterator, const_iterator, 
                    size_type) noexcept;
  void remove(const T &);
  template<typename Pred> void remove_if(Pred);
  void unique();
  template<typename Pred> void unique(Pred);
  void merge(slist &);
  void merge(slist &&);
  template<typename StrictWeakOrdering> 
    void merge(slist &, StrictWeakOrdering);
  template<typename StrictWeakOrdering> 
    void merge(slist &&, StrictWeakOrdering);
  void sort();
  template<typename StrictWeakOrdering> void sort(StrictWeakOrdering);
  void reverse() noexcept;
  template<class\&.\&.\&. Args> iterator emplace(const_iterator, Args &&\&.\&.\&.);
  iterator insert(const_iterator, const T &);
  iterator insert(const_iterator, T &&);
  iterator insert(const_iterator, size_type, const value_type &);
  template<typename InIter> iterator insert(const_iterator, InIter, InIter);
  iterator insert(const_iterator, std::initializer_list< value_type >);
  iterator erase(const_iterator) noexcept;
  iterator erase(const_iterator, const_iterator) noexcept;
  void splice(const_iterator, slist &) noexcept;
  void splice(const_iterator, slist &&) noexcept;
  void splice(const_iterator, slist &, const_iterator) noexcept;
  void splice(const_iterator, slist &&, const_iterator) noexcept;
  void splice(const_iterator, slist &, const_iterator, const_iterator) noexcept;
  void splice(const_iterator, slist &&, const_iterator, const_iterator) noexcept;

  // friend functions
  friend bool operator==(const slist &, const slist &);
  friend bool operator!=(const slist &, const slist &);
  friend bool operator<(const slist &, const slist &);
  friend bool operator>(const slist &, const slist &);
  friend bool operator<=(const slist &, const slist &);
  friend bool operator>=(const slist &, const slist &);
  friend void swap(slist &, slist &);
};
.fi
.SH "DESCRIPTION"
.PP
An slist is a singly linked list: a list where each element is linked to the next element, but not to the previous element\&. That is, it is a Sequence that supports forward but not backward traversal, and (amortized) constant time insertion and removal of elements\&. Slists, like lists, have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed\&. The ordering of iterators may be changed (that is, slist<T>::iterator might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit\&.
.PP
The main difference between slist and list is that list\'s iterators are bidirectional iterators, while slist\'s iterators are forward iterators\&. This means that slist is less versatile than list; frequently, however, bidirectional iterators are unnecessary\&. You should usually use slist unless you actually need the extra functionality of list, because singly linked lists are smaller and faster than double linked lists\&.
.PP
Important performance note: like every other Sequence, slist defines the member functions insert and erase\&. Using these member functions carelessly, however, can result in disastrously slow programs\&. The problem is that insert\'s first argument is an iterator p, and that it inserts the new element(s) before p\&. This means that insert must find the iterator just before p; this is a constant\-time operation for list, since list has bidirectional iterators, but for slist it must find that iterator by traversing the list from the beginning up to p\&. In other words: insert and erase are slow operations anywhere but near the beginning of the slist\&.
.PP
Slist provides the member functions insert_after and erase_after, which are constant time operations: you should always use insert_after and erase_after whenever possible\&. If you find that insert_after and erase_after aren\'t adequate for your needs, and that you often need to use insert and erase in the middle of the list, then you should probably use list instead of slist\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of object that is stored in the list
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<T>
.fi

.sp
The allocator used for all internal memory management
.RE

.SS "slist public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
slist();
.fi

.sp
\fBEffects\fR: Constructs a list taking the allocator as parameter\&.
.sp
\fBThrows\fR: If allocator_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit slist(const allocator_type & a) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a list taking the allocator as parameter\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit slist(size_type n);
.fi

.sp
\fBEffects\fR: Constructs a list and inserts n value\-initialized value_types\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
slist(size_type n, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
explicit slist(size_type n, const value_type & x, 
               const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename InpIt> 
  slist(InpIt first, InpIt last, const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts a copy of the range [first, last) in the list\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced InIt throws\&.
.sp
\fBComplexity\fR: Linear to the range [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
slist(std::initializer_list< value_type > il, 
      const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts a copy of the range [il\&.begin(), il\&.end()) in the list\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
slist(const slist & x);
.fi

.sp
\fBEffects\fR: Copy constructs a list\&.
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
slist(slist && x);
.fi

.sp
\fBEffects\fR: Move constructor\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocator_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
slist(const slist & x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a list using the specified allocator\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
slist(slist && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructor using the specified allocator\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocation or value_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant if a == x\&.get_allocator(), linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
slist & operator=(const slist & x);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as x\&.
.sp
\fBPostcondition\fR: this\->size() == x\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements in x\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
slist & operator=(slist && x) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as x\&.
.sp
\fBPostcondition\fR: this\->size() == x\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
slist & operator=(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as in il\&.
.sp
\fBPostcondition\fR: this\->size() == il\&.size()\&. *this contains a copy of each of il\'s elements\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
~slist();
.fi

.sp
\fBEffects\fR: Destroys the list\&. All stored values are destroyed and used memory is deallocated\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements\&.
.RE

.SS "slist public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" assign: Class template slist
.\" Class template slist: assign

.sp

.nf
void assign(size_type n, const T & val);
.fi

.sp
\fBEffects\fR: Assigns the n copies of val to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" assign: Class template slist
.\" Class template slist: assign

.sp

.nf
template<typename InpIt> void assign(InpIt first, InpIt last);
.fi

.sp
\fBEffects\fR: Assigns the range [first, last) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing InpIt throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" assign: Class template slist
.\" Class template slist: assign

.sp

.nf
void assign(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Assigns the range [il\&.begin(), il\&.end()) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a copy of the internal allocator\&.
.sp
\fBThrows\fR: If allocator\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" get_stored_allocator: Class template slist
.\" Class template slist: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" get_stored_allocator: Class template slist
.\" Class template slist: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" begin: Class template slist
.\" Class template slist: begin

.sp

.nf
iterator before_begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a non\-dereferenceable iterator that, when incremented, yields begin()\&. This iterator may be used as the argument to insert_after, erase_after, etc\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" begin: Class template slist
.\" Class template slist: begin

.sp

.nf
const_iterator before_begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a non\-dereferenceable const_iterator that, when incremented, yields begin()\&. This iterator may be used as the argument to insert_after, erase_after, etc\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" begin: Class template slist
.\" Class template slist: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" begin: Class template slist
.\" Class template slist: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" begin: Class template slist
.\" Class template slist: begin

.sp

.nf
const_iterator cbefore_begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a non\-dereferenceable const_iterator that, when incremented, yields begin()\&. This iterator may be used as the argument to insert_after, erase_after, etc\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" previous: Class template slist
.\" Class template slist: previous

.sp

.nf
iterator previous(iterator p) noexcept;
.fi

.sp
\fBReturns\fR: The iterator to the element before i in the sequence\&. Returns the end\-iterator, if either i is the begin\-iterator or the sequence is empty\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before i\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" previous: Class template slist
.\" Class template slist: previous

.sp

.nf
const_iterator previous(const_iterator p);
.fi

.sp
\fBReturns\fR: The const_iterator to the element before i in the sequence\&. Returns the end\-const_iterator, if either i is the begin\-const_iterator or the sequence is empty\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before i\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the list contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
size_type max_size() const;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" resize: Class template slist
.\" Class template slist: resize

.sp

.nf
void resize(size_type new_size);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are value initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" resize: Class template slist
.\" Class template slist: resize

.sp

.nf
void resize(size_type new_size, const T & x);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are copy constructed from x\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" front: Class template slist
.\" Class template slist: front

.sp

.nf
reference front();
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the first element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" front: Class template slist
.\" Class template slist: front

.sp

.nf
const_reference front() const;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the first element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> void emplace_front(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the front of the list
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> 
  iterator emplace_after(const_iterator prev, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. after prev
.sp
\fBThrows\fR: If memory allocation throws or T\'s in\-place constructor throws\&.
.sp
\fBComplexity\fR: Constant
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" push_front: Class template slist
.\" Class template slist: push_front

.sp

.nf
void push_front(const T & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x at the beginning of the list\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" push_front: Class template slist
.\" Class template slist: push_front

.sp

.nf
void push_front(T && x);
.fi

.sp
\fBEffects\fR: Constructs a new element in the beginning of the list and moves the resources of x to this new element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" insert_after: Class template slist
.\" Class template slist: insert_after

.sp

.nf
iterator insert_after(const_iterator prev_p, const T & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts a copy of the value after prev_p\&.
.sp
\fBReturns\fR: An iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references of previous values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" insert_after: Class template slist
.\" Class template slist: insert_after

.sp

.nf
iterator insert_after(const_iterator prev_p, T && x);
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts a move constructed copy object from the value after the p pointed by prev_p\&.
.sp
\fBReturns\fR: An iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references of previous values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" insert_after: Class template slist
.\" Class template slist: insert_after

.sp

.nf
iterator insert_after(const_iterator prev_p, size_type n, 
                      const value_type & x);
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts n copies of x after prev_p\&.
.sp
\fBReturns\fR: an iterator to the last inserted element or prev_p if n is 0\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references of previous values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" insert_after: Class template slist
.\" Class template slist: insert_after

.sp

.nf
template<typename InpIt> 
  iterator insert_after(const_iterator prev_p, InpIt first, InpIt last);
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts the range pointed by [first, last) after prev_p\&.
.sp
\fBReturns\fR: an iterator to the last inserted element or prev_p if first == last\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced InpIt throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references of previous values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" insert_after: Class template slist
.\" Class template slist: insert_after

.sp

.nf
iterator insert_after(const_iterator prev_p, 
                      std::initializer_list< value_type > il);
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts the range pointed by [il\&.begin(), il\&.end()) after prev_p\&.
.sp
\fBReturns\fR: an iterator to the last inserted element or prev_p if il\&.begin() == il\&.end()\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references of previous values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" pop_front: Class template slist
.\" Class template slist: pop_front

.sp

.nf
void pop_front();
.fi

.sp
\fBEffects\fR: Removes the first element from the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase_after: Class template slist
.\" Class template slist: erase_after

.sp

.nf
iterator erase_after(const_iterator prev_p);
.fi

.sp
\fBEffects\fR: Erases the element after the element pointed by prev_p of the list\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not invalidate iterators or references to non erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase_after: Class template slist
.\" Class template slist: erase_after

.sp

.nf
iterator erase_after(const_iterator before_first, const_iterator last);
.fi

.sp
\fBEffects\fR: Erases the range (before_first, last) from the list\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of erased elements\&.
.sp
\fBNote\fR: Does not invalidate iterators or references to non erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" swap: Class template slist
.\" Class template slist: swap

.sp

.nf
void swap(slist & x) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements on *this and x\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" clear: Class template slist
.\" Class template slist: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all the elements of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the list\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist & x) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by the list\&. x != *this
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, after the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: std::runtime_error if this\' allocator and x\'s allocator are not equal\&.
.sp
\fBComplexity\fR: Linear to the elements in x\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist && x) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by the list\&. x != *this
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, after the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: std::runtime_error if this\' allocator and x\'s allocator are not equal\&.
.sp
\fBComplexity\fR: Linear to the elements in x\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist & x, const_iterator prev) noexcept;
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of this\&. i must point to an element contained in list x\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the value pointed by i, from list x to this list, after the element pointed by prev_p\&. If prev_p == prev or prev_p == ++prev, this function is a null operation\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist && x, const_iterator prev) noexcept;
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of this\&. i must point to an element contained in list x\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the value pointed by i, from list x to this list, after the element pointed by prev_p\&. If prev_p == prev or prev_p == ++prev, this function is a null operation\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist & x, 
                  const_iterator before_first, const_iterator before_last) noexcept;
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of this\&. before_first and before_last must be valid iterators of x\&. prev_p must not be contained in [before_first, before_last) range\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear to the number of transferred elements\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist && x, 
                  const_iterator before_first, const_iterator before_last) noexcept;
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of this\&. before_first and before_last must be valid iterators of x\&. prev_p must not be contained in [before_first, before_last) range\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear to the number of transferred elements\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist & x, 
                  const_iterator before_first, const_iterator before_last, 
                  size_type n) noexcept;
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of this\&. before_first and before_last must be valid iterators of x\&. prev_p must not be contained in [before_first, before_last) range\&. n == distance(before_first, before_last)\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}

.sp

.nf
void splice_after(const_iterator prev_p, slist && x, 
                  const_iterator before_first, const_iterator before_last, 
                  size_type n) noexcept;
.fi

.sp
\fBRequires\fR: prev_p must be a valid iterator of this\&. before_first and before_last must be valid iterators of x\&. prev_p must not be contained in [before_first, before_last) range\&. n == distance(before_first, before_last)\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_p\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" remove: Class template slist
.\" Class template slist: remove

.sp

.nf
void remove(const T & value);
.fi

.sp
\fBEffects\fR: Removes all the elements that compare equal to value\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" remove_if: Class template slist
.\" Class template slist: remove_if

.sp

.nf
template<typename Pred> void remove_if(Pred pred);
.fi

.sp
\fBEffects\fR: Removes all the elements for which a specified predicate is satisfied\&.
.sp
\fBThrows\fR: If pred throws\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() calls to the predicate\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" unique: Class template slist
.\" Class template slist: unique

.sp

.nf
void unique();
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that are equal from the list\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBComplexity\fR: Linear time (size()\-1 comparisons equality comparisons)\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" unique: Class template slist
.\" Class template slist: unique

.sp

.nf
template<typename Pred> void unique(Pred pred);
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list\&.
.sp
\fBThrows\fR: If pred throws\&.
.sp
\fBComplexity\fR: Linear time (size()\-1 comparisons calls to pred())\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" merge: Class template slist
.\" Class template slist: merge

.sp

.nf
void merge(slist & x);
.fi

.sp
\fBRequires\fR: The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this according to std::less<value_type>\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" merge: Class template slist
.\" Class template slist: merge

.sp

.nf
void merge(slist && x);
.fi

.sp
\fBRequires\fR: The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this according to std::less<value_type>\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" merge: Class template slist
.\" Class template slist: merge

.sp

.nf
template<typename StrictWeakOrdering> 
  void merge(slist & x, StrictWeakOrdering comp);
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comp throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references to *this are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" merge: Class template slist
.\" Class template slist: merge

.sp

.nf
template<typename StrictWeakOrdering> 
  void merge(slist && x, StrictWeakOrdering comp);
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comp throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references to *this are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" sort: Class template slist
.\" Class template slist: sort

.sp

.nf
void sort();
.fi

.sp
\fBEffects\fR: This function sorts the list *this according to std::less<value_type>\&. The sort is stable, that is, the relative order of equivalent elements is preserved\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBNotes\fR: Iterators and references are not invalidated\&.
.sp
\fBComplexity\fR: The number of comparisons is approximately N log N, where N is the list\'s size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" sort: Class template slist
.\" Class template slist: sort

.sp

.nf
template<typename StrictWeakOrdering> void sort(StrictWeakOrdering comp);
.fi

.sp
\fBEffects\fR: This function sorts the list *this according to std::less<value_type>\&. The sort is stable, that is, the relative order of equivalent elements is preserved\&.
.sp
\fBThrows\fR: If comp throws\&.
.sp
\fBNotes\fR: Iterators and references are not invalidated\&.
.sp
\fBComplexity\fR: The number of comparisons is approximately N log N, where N is the list\'s size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}

.sp

.nf
void reverse() noexcept;
.fi

.sp
\fBEffects\fR: Reverses the order of elements in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: This function is linear time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" emplace: Class template slist
.\" Class template slist: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. before p
.sp
\fBThrows\fR: If memory allocation throws or T\'s in\-place constructor throws\&.
.sp
\fBComplexity\fR: Linear to the elements before p
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" insert: Class template slist
.\" Class template slist: insert

.sp

.nf
iterator insert(const_iterator p, const T & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of x before p\&.
.sp
\fBReturns\fR: an iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws or x\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the elements before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" insert: Class template slist
.\" Class template slist: insert

.sp

.nf
iterator insert(const_iterator prev_p, T && x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a new element before p with x\'s resources\&.
.sp
\fBReturns\fR: an iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Linear to the elements before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" insert: Class template slist
.\" Class template slist: insert

.sp

.nf
iterator insert(const_iterator p, size_type n, const value_type & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts n copies of x before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if n == 0\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n plus linear to the elements before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}
.\" insert: Class template slist
.\" Class template slist: insert

.sp

.nf
template<typename InIter> 
  iterator insert(const_iterator p, InIter first, InIter last);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [first, last) range before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if first == last\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced InpIt throws\&.
.sp
\fBComplexity\fR: Linear to distance [first, last) plus linear to the elements before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}
.\" insert: Class template slist
.\" Class template slist: insert

.sp

.nf
iterator insert(const_iterator p, std::initializer_list< value_type > il);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [il\&.begin(), il\&.end()) range before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if il\&.begin() == il\&.end()\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end()) plus linear to the elements before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}
.\" erase: Class template slist
.\" Class template slist: erase

.sp

.nf
iterator erase(const_iterator p) noexcept;
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Erases the element at p p\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'65.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "65." 4.2
.\}
.\" erase: Class template slist
.\" Class template slist: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last) noexcept;
.fi

.sp
\fBRequires\fR: first and last must be valid iterator to elements in *this\&.
.sp
\fBEffects\fR: Erases the elements pointed by [first, last)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the distance between first and last plus linear to the elements before first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'66.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "66." 4.2
.\}

.sp

.nf
void splice(const_iterator p, slist & x) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by the list\&. x != *this\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear in distance(begin(), p), and linear in x\&.size()\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'67.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "67." 4.2
.\}

.sp

.nf
void splice(const_iterator p, slist && x) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by the list\&. x != *this\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear in distance(begin(), p), and linear in x\&.size()\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'68.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "68." 4.2
.\}

.sp

.nf
void splice(const_iterator p, slist & x, const_iterator i) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. i must point to an element contained in list x\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers the value pointed by i, from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&. If p == i or p == ++i, this function is a null operation\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear in distance(begin(), p), and in distance(x\&.begin(), i)\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'69.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "69." 4.2
.\}

.sp

.nf
void splice(const_iterator p, slist && x, const_iterator i) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. i must point to an element contained in list x\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the value pointed by i, from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&. If p == i or p == ++i, this function is a null operation\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear in distance(begin(), p), and in distance(x\&.begin(), i)\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'70.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "70." 4.2
.\}

.sp

.nf
void splice(const_iterator p, slist & x, const_iterator first, 
            const_iterator last) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. first and last must point to elements contained in list x\&.
.sp
\fBEffects\fR: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear in distance(begin(), p), in distance(x\&.begin(), first), and in distance(first, last)\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'71.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "71." 4.2
.\}

.sp

.nf
void splice(const_iterator p, slist && x, const_iterator first, 
            const_iterator last) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. first and last must point to elements contained in list x\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear in distance(begin(), p), in distance(x\&.begin(), first), and in distance(first, last)\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE

.SS "slist friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const slist & x, const slist & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const slist & x, const slist & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const slist & x, const slist & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const slist & x, const slist & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const slist & x, const slist & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const slist & x, const slist & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template slist
.\" Class template slist: swap

.sp

.nf
friend void swap(slist & x, slist & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


