.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_L" 3 "" "" ""
.SH "NAME"
BOOST_LOCAL_FUNCTION_NAME \- This macro is used to end a local function declaration specifying its name\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/local_function\&.hpp>

BOOST_LOCAL_FUNCTION_NAME(qualified_name)
.fi
.SH "DESCRIPTION"
.PP
This macro must follow the local function body code block
{ \&.\&.\&. }:

.sp
.if n \{\
.RS 4
.\}
.nf
{ // Some declarative context\&.
    \&.\&.\&.
    result_type BOOST_LOCAL_FUNCTION(declarations) {
        \&.\&.\&. // Body code\&.
    } BOOST_LOCAL_FUNCTION_NAME(qualified_name)
    \&.\&.\&.
}

.fi
.if n \{\
.RE
.\}

.PP
Within templates, the special macros
BOOST_LOCAL_FUNCTION_TPL
and
BOOST_LOCAL_FUNCTION_NAME_TPL
must be used\&.
.PP
\fBParameters:\fR
.TS
allbox tab(:);
l l.
T{
\fBqualified_name\fR
T}:T{
The name of the local function optionally qualified as follow: .if n \{\
.RS 4
.\}
.nf
name:
        [inline] [recursive] local_function_name

.fi
.if n \{\
.RE
.\}
.sp
 (Lexical conventions: token1 | token2 means either token1 or token2; [token] means either token or nothing; {expression} means the token resulting from the expression\&.)
T}
.TE
.sp 1

.PP
The local function name can be qualified by prefixing it with the keyword
inline
(see the
Advanced Topics
section):

.sp
.if n \{\
.RS 4
.\}
.nf
BOOST_LOCAL_FUNCTION_NAME(inline local_function_name)

.fi
.if n \{\
.RE
.\}
.sp
This increases the chances that the compiler will be able to inline the local function calls (thus reducing run\-time)\&. However, inline local functions cannot be passed as template parameters (e\&.g\&., to
std::for_each) or assigned to other functors (e\&.g\&., to
boost::function)\&. That is true on C++03 compilers but inline local functions can instead be passed as template parameters on C++11 compilers\&. On C++11 compilers, there is no need to declare a local function lined because this library will automatically use C++11 specific features to inline the local function while always allowing to pass it as a template parameter\&. This optimization is automatically enabled when the Boost\&.Config macro
BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS
is not defined but it also be forced using
BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS\&.
.PP
The local function name can also be qualified by prefixing it with the "keyword"
recursive
(see the
Advanced Topics
section):

.sp
.if n \{\
.RS 4
.\}
.nf
BOOST_LOCAL_FUNCTION_NAME(recursive local_function_name)

.fi
.if n \{\
.RE
.\}
.sp
This allows the local function to recursively call itself from its body (as usual in C++)\&. However, recursive local functions should only be called within their declaration scope (otherwise the result is undefined behaviour)\&. Finally, compilers have not been observed to be able to inline recursive local function calls, not even when the recursive local function is also declared inline:

.sp
.if n \{\
.RS 4
.\}
.nf
BOOST_LOCAL_FUNCTION(inline recursive local_function_name)

.fi
.if n \{\
.RE
.\}

.PP
\fBNote:\fR
The local function name cannot be the name of an operator
operator\&.\&.\&.
and it cannot be the same name of another local function declared within the same enclosing scope (but
boost::overloaded_function
can be used to overload local functions, see Boost\&.Functional/OverloadedFunction and the
Advanced Topics
section)\&.
.PP
\fBSee:\fR
Tutorial
section,
Advanced Topics
section,
BOOST_LOCAL_FUNCTION,
BOOST_LOCAL_FUNCTION_NAME_TPL\&.

