.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLA" 3 "" "" ""
.SH "NAME"
boost::movelib::default_delete
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/move/default_delete\&.hpp>

template<typename T> 
struct default_delete {
  // construct/copy/destruct
  default_delete();
  default_delete(const default_delete &);
  template<typename U> default_delete(const default_delete< U > &) noexcept;
  default_delete & operator=(const default_delete &);
  template<typename U> 
    default_delete & operator=(const default_delete< U > &) noexcept;

  // public member functions
  template<typename U> void operator()(U *) const noexcept;
  void operator()(std::nullptr_t) const noexcept;
};
.fi
.SH "DESCRIPTION"
.PP
The class template
default_delete
serves as the default deleter (destruction policy) for the class template
unique_ptr\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type to be deleted\&. It may be an incomplete type
.RE

.SS "default_delete public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
default_delete();
.fi

.sp
Default constructor\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
default_delete(const default_delete &);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename U> default_delete(const default_delete< U > &) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a
default_delete
object from another
default_delete<U>
object\&.
.sp
\fBRemarks\fR: This constructor shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is not an array type and U* is implicitly convertible to T*\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is an array type and U* is a more CV qualified pointer to remove_extent<T>::type\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
default_delete & operator=(const default_delete &);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename U> 
  default_delete & operator=(const default_delete< U > &) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a
default_delete
object from another
default_delete<U>
object\&.
.sp
\fBRemarks\fR: This constructor shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is not an array type and U* is implicitly convertible to T*\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is an array type and U* is a more CV qualified pointer to remove_extent<T>::type\&.
.RE
.RS 4

.RE

.SS "default_delete public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename U> void operator()(U * ptr) const noexcept;
.fi

.sp
\fBEffects\fR: if T is not an array type, calls
delete
on static_cast<T*>(ptr), otherwise calls
delete[]
on static_cast<remove_extent<T>::type*>(ptr)\&.
.sp
\fBRemarks\fR: If U is an incomplete type, the program is ill\-formed\&. This operator shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T is not an array type and U* is convertible to T*, OR
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T is an array type, and remove_cv<U>::type is the same type as remove_cv<remove_extent<T>::type>::type and U* is convertible to remove_extent<T>::type*\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void operator()(std::nullptr_t) const noexcept;
.fi

.sp
\fBEffects\fR: Same as
(\fIthis)(static_cast<element_type\fR>(nullptr))\&.
.RE


