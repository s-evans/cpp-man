.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE F" 3 "" "" ""
.SH "NAME"
boost::functionN \- A set of generalized function pointers that can be used for callbacks or wrapping function objects\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/function\&.hpp>

template<typename R, typename T1, typename T2, \&.\&.\&., typename TN> 
class functionN : public function_base {
public:
  // types
  typedef R  result_type;         
  typedef T1 argument_type;         // If N == 1
  typedef T1 first_argument_type;   // If N == 2
  typedef T2 second_argument_type;  // If N == 2
  typedef T1 arg1_type;           
  typedef T2 arg2_type;           
     \&.
     \&.
     \&.
  typedef TN argN_type;           

  // static constants
  static const int arity = N;

  // member classes/structs/unions

  // Lambda library support
  template<typename Args> 
  struct sig {
    // types
    typedef result_type type;
  };

  // construct/copy/destruct
  functionN();
  functionN(const functionN&);
  functionN(functionN&&);
  template<typename F> functionN(F);
  template<typename F, typename Allocator> functionN(F, Allocator);
  functionN& operator=(const functionN&);
  functionN& operator=(functionN&&);
  ~functionN();

  // modifiers
  void swap(const functionN&);
  void clear();

  // capacity
  bool empty() const;
  operator safe_bool() const;
  bool operator!() const;

  // target access
  template<typename Functor> Functor* target();
  template<typename Functor> const Functor* target() const;
  template<typename Functor> bool contains(const Functor&) const;
  const std::type_info& target_type() const;

  // invocation
  result_type operator()(arg1_type, arg2_type, \&.\&.\&., argN_type) const;
};

// specialized algorithms
template<typename T1, typename T2, \&.\&.\&., typename TN> 
  void swap(functionN<T1, T2, \&.\&.\&., TN>&, functionN<T1, T2, \&.\&.\&., TN>&);

// comparison operators
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(const functionN<T1, T2, \&.\&.\&., TN>&, Functor);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(Functor, const functionN<T1, T2, \&.\&.\&., TN>&);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(const functionN<T1, T2, \&.\&.\&., TN>&, 
                  reference_wrapper<Functor>);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(reference_wrapper<Functor>, 
                  const functionN<T1, T2, \&.\&.\&., TN>&);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename U1, typename U2, 
         \&.\&.\&., typename UN> 
  void operator==(const functionN<T1, T2, \&.\&.\&., TN>&, 
                  const functionN<U1, U2, \&.\&.\&., UN>&);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(const functionN<T1, T2, \&.\&.\&., TN>&, Functor);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(Functor, const functionN<T1, T2, \&.\&.\&., TN>&);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(const functionN<T1, T2, \&.\&.\&., TN>&, 
                  reference_wrapper<Functor>);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(reference_wrapper<Functor>, 
                  const functionN<T1, T2, \&.\&.\&., TN>&);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename U1, typename U2, 
         \&.\&.\&., typename UN> 
  void operator!=(const functionN<T1, T2, \&.\&.\&., TN>&, 
                  const functionN<U1, U2, \&.\&.\&., UN>&);
.fi
.SH "DESCRIPTION"
.PP
Class template
functionN
is actually a family of related classes
function0,
function1, etc\&., up to some implementation\-defined maximum\&. In this context,
N
refers to the number of parameters\&.
.SS "functionN public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
functionN();
.fi

.PP
Postconditions:
.RS 4
this\->empty()
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
functionN(const functionN& f);
.fi

.PP
Postconditions:
.RS 4
Contains a copy of the
f\'s target, if it has one, or is empty if
f\&.empty()\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
functionN(functionN&& f);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Postconditions:
.RS 4
Moves the value from
f
to
*this\&. If the argument has its function object allocated on the heap, its buffer will be assigned to
*this
leaving argument empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless argument has its function object allocated not on the heap and copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename F> functionN(F f);
.fi

.PP
Requires:
.RS 4
F is a function object Callable from
this\&.
.RE
.PP
Postconditions:
.RS 4
*this
targets a copy of
f
if
f
is nonempty, or
this\->empty()
if
f
is empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename F, typename Allocator> functionN(F f, Allocator alloc);
.fi

.PP
Requires:
.RS 4
F is a function object Callable from
this, Allocator is an allocator\&. The copy constructor and destructor of Allocator shall not throw\&.
.RE
.PP
Postconditions:
.RS 4
*this
targets a copy of
f
if
f
is nonempty, or
this\->empty()
if
f
is empty\&.
.RE
.PP
Effects:
.RS 4
If memory allocation is required, the given allocator (or a copy of it) will be used to allocate that memory\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
functionN& operator=(const functionN& f);
.fi

.PP
Postconditions:
.RS 4
If copy construction does not throw,
*this
targets a copy of
f\'s target, if it has one, or is empty if
f\&.empty()\&. If copy construction does throw,
this\->empty()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
functionN& operator=(functionN&& f);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Postconditions:
.RS 4
Moves the value from
f
to
*this\&. If the argument has its function object allocated on the heap, its buffer will be assigned to
*this
leaving argument empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless argument has its function object allocated not on the heap and copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
~functionN();
.fi

.PP
Effects:
.RS 4
If
!this\->empty(), destroys the target of this\&.
.RE
.RE

.SS "functionN modifiers"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void swap(const functionN& f);
.fi

.PP
Effects:
.RS 4
Interchanges the targets of
*this
and
f\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void clear();
.fi

.PP
Postconditions:
.RS 4
this\->empty()
.RE
.RE

.SS "functionN capacity"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.PP
Returns:
.RS 4
false
if
this
has a target, and
true
otherwise\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
operator safe_bool() const;
.fi

.PP
Returns:
.RS 4
A
safe_bool
that evaluates
false
in a boolean context when
this\->empty(), and
true
otherwise\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool operator!() const;
.fi

.PP
Returns:
.RS 4
this\->empty()
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "functionN target access"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Functor> Functor* target();
template<typename Functor> const Functor* target() const;
.fi

.PP
Returns:
.RS 4
If
this
stores a target of type
Functor, returns the address of the target\&. Otherwise, returns the NULL pointer\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Functor> bool contains(const Functor& f) const;
.fi

.PP
Returns:
.RS 4
true
if
this\->target<Functor>()
is non\-NULL and
function_equal(*(this\->target<Functor>()), f)
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
const std::type_info& target_type() const;
.fi

.PP
Returns:
.RS 4
typeid
of the target function object, or
typeid(void)
if
this\->empty()\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "functionN invocation"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
result_type operator()(arg1_type a1, arg2_type a2, \&.\&.\&., argN_type aN) const;
.fi

.PP
Effects:
.RS 4
f(a1, a2, \&.\&.\&., aN), where
f
is the target of
*this\&.
.RE
.PP
Returns:
.RS 4
if
R
is
void, nothing is returned; otherwise, the return value of the call to
f
is returned\&.
.RE
.PP
Throws:
.RS 4
bad_function_call
if
this\->empty()\&. Otherwise, may through any exception thrown by the target function
f\&.
.RE
.RE

.SS "functionN specialized algorithms"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename T1, typename T2, \&.\&.\&., typename TN> 
  void swap(functionN<T1, T2, \&.\&.\&., TN>& f1, functionN<T1, T2, \&.\&.\&., TN>& f2);
.fi

.PP
Effects:
.RS 4
f1\&.swap(f2)
.RE
.RE

.SS "functionN comparison operators"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(const functionN<T1, T2, \&.\&.\&., TN>& f, Functor g);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(Functor g, const functionN<T1, T2, \&.\&.\&., TN>& f);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(const functionN<T1, T2, \&.\&.\&., TN>& f, 
                  reference_wrapper<Functor> g);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator==(reference_wrapper<Functor> g, 
                  const functionN<T1, T2, \&.\&.\&., TN>& f);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename U1, typename U2, 
         \&.\&.\&., typename UN> 
  void operator==(const functionN<T1, T2, \&.\&.\&., TN>& f1, 
                  const functionN<U1, U2, \&.\&.\&., UN>& f2);
.fi

.PP
Returns:
.RS 4
True when
f
stores an object of type
Functor
and one of the following conditions applies:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is of type
reference_wrapper<Functor>
and
f\&.target<Functor>() == g\&.get_pointer()\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is not of type
reference_wrapper<Functor>
and
function_equal(*(f\&.target<Functor>()), g)\&.
.RE
.RS 4

.RE
.PP
Notes:
.RS 4
functionN
objects are not EqualityComparable\&.
.RE
.PP
Rationale:
.RS 4
The
safe_bool
conversion opens a loophole whereby two
functionN
instances can be compared via
==, although this is not feasible to implement\&. The undefined
void operator==
closes the loophole and ensures a compile\-time or link\-time error\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(const functionN<T1, T2, \&.\&.\&., TN>& f, Functor g);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(Functor g, const functionN<T1, T2, \&.\&.\&., TN>& f);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(const functionN<T1, T2, \&.\&.\&., TN>& f, 
                  reference_wrapper<Functor> g);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename Functor> 
  bool operator!=(reference_wrapper<Functor> g, 
                  const functionN<T1, T2, \&.\&.\&., TN>& f);
template<typename T1, typename T2, \&.\&.\&., typename TN, typename U1, typename U2, 
         \&.\&.\&., typename UN> 
  void operator!=(const functionN<T1, T2, \&.\&.\&., TN>& f1, 
                  const functionN<U1, U2, \&.\&.\&., UN>& f2);
.fi

.PP
Returns:
.RS 4
True when
f
does not store an object of type
Functor
or it stores an object of type
Functor
and one of the following conditions applies:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is of type
reference_wrapper<Functor>
and
f\&.target<Functor>() != g\&.get_pointer()\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is not of type
reference_wrapper<Functor>
and
!function_equal(*(f\&.target<Functor>()), g)\&.
.RE
.RS 4

.RE
.PP
Notes:
.RS 4
functionN
objects are not EqualityComparable\&.
.RE
.PP
Rationale:
.RS 4
The
safe_bool
conversion opens a loophole whereby two
functionN
instances can be compared via
!=, although this is not feasible to implement\&. The undefined
void operator!=
closes the loophole and ensures a compile\-time or link\-time error\&.
.RE
.RE


