.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE S" 3 "" "" ""
.SH "NAME"
boost::heap::skew_heap \- skew heap
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/heap/skew_heap\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class skew_heap {
public:
  // types
  typedef T                                                                                   value_type;      
  typedef implementation_defined::size_type                                                   size_type;       
  typedef implementation_defined::difference_type                                             difference_type; 
  typedef implementation_defined::value_compare                                               value_compare;   
  typedef implementation_defined::allocator_type                                              allocator_type;  
  typedef implementation_defined::reference                                                   reference;       
  typedef implementation_defined::const_reference                                             const_reference; 
  typedef implementation_defined::pointer                                                     pointer;         
  typedef implementation_defined::const_pointer                                               const_pointer;   
  typedef implementation_defined::iterator                                                    iterator;        
  typedef implementation_defined::const_iterator                                              const_iterator;  
  typedef implementation_defined::ordered_iterator                                            ordered_iterator;
  typedef mpl::if_c< is_mutable, typename implementation_defined::handle_type, void * >::type handle_type;     

  // member classes/structs/unions

  struct implementation_defined {
    // types
    typedef T                               value_type;         
    typedef base_maker::compare_argument    value_compare;      
    typedef base_maker::allocator_type      allocator_type;     
    typedef base_maker::node_type           node;               
    typedef allocator_type::pointer         node_pointer;       
    typedef allocator_type::const_pointer   const_node_pointer; 
    typedef \fIunspecified\fR                     value_extractor;    
    typedef boost::array< node_pointer, 2 > child_list_type;    
    typedef child_list_type::iterator       child_list_iterator;
    typedef \fIunspecified\fR                     iterator;           
    typedef iterator                        const_iterator;     
    typedef \fIunspecified\fR                     ordered_iterator;   
    typedef \fIunspecified\fR                     reference;          
    typedef \fIunspecified\fR                     handle_type;        
  };

  // construct/copy/destruct
  explicit skew_heap(value_compare const & = value_compare());
  skew_heap(skew_heap const &);
  skew_heap(skew_heap &&);
  skew_heap & operator=(skew_heap const &);
  skew_heap & operator=(skew_heap &&);
  ~skew_heap(void);

  // public member functions
  mpl::if_c< is_mutable, handle_type, void >::type push(value_type const &);
  template<typename\&.\&.\&. Args> 
    mpl::if_c< is_mutable, handle_type, void >::type emplace(Args &&\&.\&.\&.);
  bool empty(void) const;
  size_type size(void) const;
  size_type max_size(void) const;
  void clear(void);
  allocator_type get_allocator(void) const;
  void swap(skew_heap &);
  const_reference top(void) const;
  void pop(void);
  iterator begin(void) const;
  iterator end(void) const;
  ordered_iterator ordered_begin(void) const;
  ordered_iterator ordered_end(void) const;
  void merge(skew_heap &);
  value_compare const & value_comp(void) const;
  template<typename HeapType> bool operator<(HeapType const &) const;
  template<typename HeapType> bool operator>(HeapType const &) const;
  template<typename HeapType> bool operator>=(HeapType const &) const;
  template<typename HeapType> bool operator<=(HeapType const &) const;
  template<typename HeapType> bool operator==(HeapType const &) const;
  template<typename HeapType> bool operator!=(HeapType const &) const;
  void erase(handle_type);
  void update(handle_type, const_reference);
  void update(handle_type);
  void increase(handle_type, const_reference);
  void increase(handle_type);
  void decrease(handle_type, const_reference);
  void decrease(handle_type);

  // public static functions
  static handle_type s_handle_from_iterator(iterator const &);

  // public data members
  static const bool constant_time_size;
  static const bool has_ordered_iterators;
  static const bool is_mergable;
  static const bool is_stable;
  static const bool has_reserve;
  static const bool is_mutable;
};
.fi
.SH "DESCRIPTION"
.PP
The template parameter T is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::heap::compare<>, defaults to
compare<std::less<T>
>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::heap::stable<>, defaults to
stable<false>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::heap::stability_counter_type<>, defaults to
stability_counter_type<boost::uintmax_t>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::heap::allocator<>, defaults to
allocator<std::allocator<T>
>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::heap::constant_time_size<>, defaults to
constant_time_size<true>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::heap::store_parent_pointer<>, defaults to
store_parent_pointer<true>\&. Maintaining a parent pointer adds some maintenance and size overhead, but iterating a heap is more efficient\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::heap::mutable<>, defaults to
mutable<false>\&.
.RE
.sp
.RE

.SS "skew_heap public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

typedef
implementation_defined::iterator
iterator;
.sp
\fBNote:\fR
The iterator does not traverse the priority queue in order of the priorities\&.
.RE

.SS "skew_heap public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit skew_heap(value_compare const & cmp = value_compare());
.fi

.sp
\fBEffects:\fR
constructs an empty priority queue\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
skew_heap(skew_heap const & rhs);
.fi

.sp
\fBEffects:\fR
copy\-constructs priority queue from rhs\&.
.sp
\fBComplexity:\fR
Linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
skew_heap(skew_heap && rhs);
.fi

.sp
\fBEffects:\fR
C++11\-style move constructor\&.
.sp
\fBComplexity:\fR
Constant\&.
.sp
\fBNote:\fR
Only available, if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
skew_heap & operator=(skew_heap const & rhs);
.fi

.sp
\fBEffects:\fR
Assigns priority queue from rhs\&.
.sp
\fBComplexity:\fR
Linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
skew_heap & operator=(skew_heap && rhs);
.fi

.sp
\fBEffects:\fR
C++11\-style move assignment\&.
.sp
\fBComplexity:\fR
Constant\&.
.sp
\fBNote:\fR
Only available, if BOOST_NO_CXX11_RVALUE_REFERENCES is not defined
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
~skew_heap(void);
.fi

.RE

.SS "skew_heap public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
mpl::if_c< is_mutable, handle_type, void >::type push(value_type const & v);
.fi

.sp
\fBEffects:\fR
Adds a new element to the priority queue\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename\&.\&.\&. Args> 
  mpl::if_c< is_mutable, handle_type, void >::type emplace(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects:\fR
Adds a new element to the priority queue\&. The element is directly constructed in\-place\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool empty(void) const;
.fi

.sp
\fBEffects:\fR
Returns true, if the priority queue contains no elements\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
size_type size(void) const;
.fi

.sp
\fBEffects:\fR
Returns the number of elements contained in the priority queue\&.
.sp
\fBComplexity:\fR
Constant, if configured with constant_time_size<true>, otherwise linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
size_type max_size(void) const;
.fi

.sp
\fBEffects:\fR
Returns the maximum number of elements the priority queue can contain\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void clear(void);
.fi

.sp
\fBEffects:\fR
Removes all elements from the priority queue\&.
.sp
\fBComplexity:\fR
Linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
allocator_type get_allocator(void) const;
.fi

.sp
\fBEffects:\fR
Returns allocator\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
void swap(skew_heap & rhs);
.fi

.sp
\fBEffects:\fR
Swaps two priority queues\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_reference top(void) const;
.fi

.sp
\fBEffects:\fR
Returns a const_reference to the maximum element\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
void pop(void);
.fi

.sp
\fBEffects:\fR
Removes the top element from the priority queue\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
iterator begin(void) const;
.fi

.sp
\fBEffects:\fR
Returns an iterator to the first element contained in the priority queue\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
iterator end(void) const;
.fi

.sp
\fBEffects:\fR
Returns an iterator to the end of the priority queue\&.
.sp
\fBComplexity:\fR
Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
ordered_iterator ordered_begin(void) const;
.fi

.sp
\fBEffects:\fR
Returns an ordered iterator to the first element contained in the priority queue\&.
.sp
\fBNote:\fR
Ordered iterators traverse the priority queue in heap order\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
ordered_iterator ordered_end(void) const;
.fi

.sp
\fBEffects:\fR
Returns an ordered iterator to the first element contained in the priority queue\&.
.sp
\fBNote:\fR
Ordered iterators traverse the priority queue in heap order\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
void merge(skew_heap & rhs);
.fi

.sp
\fBEffects:\fR
Merge all elements from rhs into this
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
value_compare const & value_comp(void) const;
.fi

.sp
\fBEffect:\fR
Returns the value_compare object used by the priority queue
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
template<typename HeapType> bool operator<(HeapType const & rhs) const;
.fi

.sp
\fBReturns:\fR
Element\-wise comparison of heap data structures
.sp
\fBRequirement:\fR
the
value_compare
object of both heaps must match\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
template<typename HeapType> bool operator>(HeapType const & rhs) const;
.fi

.sp
\fBReturns:\fR
Element\-wise comparison of heap data structures
.sp
\fBRequirement:\fR
the
value_compare
object of both heaps must match\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
template<typename HeapType> bool operator>=(HeapType const & rhs) const;
.fi

.sp
\fBReturns:\fR
Element\-wise comparison of heap data structures
.sp
\fBRequirement:\fR
the
value_compare
object of both heaps must match\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
template<typename HeapType> bool operator<=(HeapType const & rhs) const;
.fi

.sp
\fBReturns:\fR
Element\-wise comparison of heap data structures
.sp
\fBRequirement:\fR
the
value_compare
object of both heaps must match\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
template<typename HeapType> bool operator==(HeapType const & rhs) const;
.fi

Equivalent comparison \fBReturns:\fR True, if both heap data structures are equivalent\&. \fBRequirement:\fR
the
value_compare
object of both heaps must match\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
template<typename HeapType> bool operator!=(HeapType const & rhs) const;
.fi

Equivalent comparison \fBReturns:\fR True, if both heap data structures are not equivalent\&. \fBRequirement:\fR
the
value_compare
object of both heaps must match\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
void erase(handle_type object);
.fi

.sp
\fBEffects:\fR
Removes the element handled by
handle
from the
priority_queue\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
void update(handle_type handle, const_reference v);
.fi

.sp
\fBEffects:\fR
Assigns
v
to the element handled by
handle
& updates the priority queue\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
void update(handle_type handle);
.fi

.sp
\fBEffects:\fR
Updates the heap after the element handled by
handle
has been changed\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.sp
\fBNote:\fR
If this is not called, after a handle has been updated, the behavior of the data structure is undefined!
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
void increase(handle_type handle, const_reference v);
.fi

.sp
\fBEffects:\fR
Assigns
v
to the element handled by
handle
& updates the priority queue\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.sp
\fBNote:\fR
The new value is expected to be greater than the current one
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}

.sp

.nf
void increase(handle_type handle);
.fi

.sp
\fBEffects:\fR
Updates the heap after the element handled by
handle
has been changed\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.sp
\fBNote:\fR
If this is not called, after a handle has been updated, the behavior of the data structure is undefined!
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}

.sp

.nf
void decrease(handle_type handle, const_reference v);
.fi

.sp
\fBEffects:\fR
Assigns
v
to the element handled by
handle
& updates the priority queue\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.sp
\fBNote:\fR
The new value is expected to be less than the current one
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}

.sp

.nf
void decrease(handle_type handle);
.fi

.sp
\fBEffects:\fR
Updates the heap after the element handled by
handle
has been changed\&.
.sp
\fBComplexity:\fR
Logarithmic (amortized)\&.
.sp
\fBNote:\fR
The new value is expected to be less than the current one\&. If this is not called, after a handle has been updated, the behavior of the data structure is undefined!
.RE

.SS "skew_heap public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static handle_type s_handle_from_iterator(iterator const & it);
.fi

.sp
\fBEffects:\fR
Casts an iterator to a node handle\&.
.sp
\fBComplexity:\fR
Constant\&.
.sp
\fBRequirement:\fR
data structure must be configured as mutable
.RE


