.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::date_time::time_duration \- Represents some amount of elapsed time measure to a given resolution\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/time_duration\&.hpp>

template<typename T, typename rep_type> 
class time_duration :
  private boost::less_than_comparable< T, boost::equality_comparable< T > >
{
public:
  // types
  typedef void                              _is_boost_date_time_duration;
  typedef T                                 duration_type;               
  typedef rep_type                          traits_type;                 
  typedef rep_type::day_type                day_type;                    
  typedef rep_type::hour_type               hour_type;                   
  typedef rep_type::min_type                min_type;                    
  typedef rep_type::sec_type                sec_type;                    
  typedef rep_type::fractional_seconds_type fractional_seconds_type;     
  typedef rep_type::tick_type               tick_type;                   
  typedef rep_type::impl_type               impl_type;                   

  // construct/copy/destruct
  time_duration();
  time_duration(hour_type, min_type, sec_type = 0, 
                fractional_seconds_type = 0);
  time_duration(const time_duration< T, rep_type > &);
  time_duration(special_values);
  explicit time_duration(impl_type);

  // public member functions
  hour_type hours() const;
  min_type minutes() const;
  sec_type seconds() const;
  sec_type total_seconds() const;
  tick_type total_milliseconds() const;
  tick_type total_nanoseconds() const;
  tick_type total_microseconds() const;
  fractional_seconds_type fractional_seconds() const;
  duration_type invert_sign() const;
  bool is_negative() const;
  bool operator<(const time_duration &) const;
  bool operator==(const time_duration &) const;
  duration_type operator\-() const;
  duration_type operator\-(const duration_type &) const;
  duration_type operator+(const duration_type &) const;
  duration_type operator/(int) const;
  duration_type operator\-=(const duration_type &);
  duration_type operator+=(const duration_type &);
  duration_type operator/=(int);
  duration_type operator*(int) const;
  duration_type operator*=(int);
  tick_type ticks() const;
  bool is_special() const;
  bool is_pos_infinity() const;
  bool is_neg_infinity() const;
  bool is_not_a_date_time() const;
  impl_type get_rep() const;

  // public static functions
  static duration_type unit();
  static tick_type ticks_per_second();
  static time_resolutions resolution();
  static unsigned short num_fractional_digits();
};
.fi
.SH "DESCRIPTION"
.PP
This class represents a standard set of capabilities for all counted time durations\&. Time duration implementations should derive from this class passing their type as the first template parameter\&. This design allows the subclass duration types to provide custom construction policies or other custom features not provided here\&.
.PP

.SS "time_duration public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
time_duration();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
time_duration(hour_type hours_in, min_type minutes_in, 
              sec_type seconds_in = 0, 
              fractional_seconds_type frac_sec_in = 0);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
time_duration(const time_duration< T, rep_type > & other);
.fi

Construct from another time_duration (Copy constructor) .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
time_duration(special_values sv);
.fi

Construct from special_values\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
explicit time_duration(impl_type in);
.fi

.RE

.SS "time_duration public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
hour_type hours() const;
.fi

Returns number of hours in the duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
min_type minutes() const;
.fi

Returns normalized number of minutes\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
sec_type seconds() const;
.fi

Returns normalized number of seconds (0\&.\&.60) .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
sec_type total_seconds() const;
.fi

Returns total number of seconds truncating any fractional seconds\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
tick_type total_milliseconds() const;
.fi

Returns total number of milliseconds truncating any fractional seconds\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
tick_type total_nanoseconds() const;
.fi

Returns total number of nanoseconds truncating any sub millisecond values\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
tick_type total_microseconds() const;
.fi

Returns total number of microseconds truncating any sub microsecond values\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
fractional_seconds_type fractional_seconds() const;
.fi

Returns count of fractional seconds at given resolution\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
duration_type invert_sign() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool is_negative() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
bool operator<(const time_duration & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool operator==(const time_duration & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
duration_type operator\-() const;
.fi

unary\- Allows for time_duration td = \-td1 .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
duration_type operator\-(const duration_type & d) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
duration_type operator+(const duration_type & d) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
duration_type operator/(int divisor) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
duration_type operator\-=(const duration_type & d);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
duration_type operator+=(const duration_type & d);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
duration_type operator/=(int divisor);
.fi

Division operations on a duration with an integer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
duration_type operator*(int rhs) const;
.fi

Multiplication operations an a duration with an integer\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
duration_type operator*=(int divisor);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
tick_type ticks() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
bool is_special() const;
.fi

Is ticks_ a special value? .RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
bool is_pos_infinity() const;
.fi

Is duration pos\-infinity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
bool is_neg_infinity() const;
.fi

Is duration neg\-infinity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
bool is_not_a_date_time() const;
.fi

Is duration not\-a\-date\-time\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}

.sp

.nf
impl_type get_rep() const;
.fi

Used for special_values output\&. .RE

.SS "time_duration public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static duration_type unit();
.fi

Returns smallest representable duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static tick_type ticks_per_second();
.fi

Return the number of ticks in a second\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
static time_resolutions resolution();
.fi

Provide the resolution of this duration type\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
static unsigned short num_fractional_digits();
.fi

Returns number of possible digits in fractional seconds\&. .RE


