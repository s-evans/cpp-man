.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTION APPLY_VI" 3 "" "" ""
.SH "NAME"
boost::apply_visitor \- Allows compile\-time checked type\-safe application of the given visitor to the content of the given variant, ensuring that all types are handled by the visitor\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/variant/apply_visitor\&.hpp>


template<typename Visitor, typename Variant> 
  typename Visitor::result_type 
  apply_visitor(Visitor & visitor, Variant & operand);
template<typename Visitor, typename Variant> 
  typename Visitor::result_type 
  apply_visitor(const Visitor & visitor, Variant & operand);
template<typename BinaryVisitor, typename Variant1, typename Variant2> 
  typename BinaryVisitor::result_type OR decltype(auto) 
  apply_visitor(BinaryVisitor & visitor, Variant1 & operand1, 
                Variant2 & operand2);
template<typename BinaryVisitor, typename Variant1, typename Variant2> 
  typename BinaryVisitor::result_type OR decltype(auto) 
  apply_visitor(const BinaryVisitor & visitor, Variant1 & operand1, 
                Variant2 & operand2);
template<typename MultiVisitor, typename Variant1, typename Variant2, 
         typename Variant3> 
  typename MultiVisitor::result_type OR decltype(auto) 
  apply_visitor(MultiVisitor & visitor, Variant1 & operand1, 
                Variant2 & operand2, Variant3 & operand3, \&.\&.\&. other_operands);
template<typename MultiVisitor, typename Variant1, typename Variant2, 
         typename Variant3> 
  typename MultiVisitor::result_type OR decltype(auto) 
  apply_visitor(const MultiVisitor & visitor, Variant1 & operand1, 
                Variant2 & operand2, Variant3 & operand3, \&.\&.\&. other_operands);
template<typename Visitor> 
  apply_visitor_delayed_t<Visitor> apply_visitor(Visitor & visitor);
template<typename Visitor> 
  apply_visitor_delayed_cpp14_t<Visitor> apply_visitor(Visitor & visitor);
.fi
.SH "DESCRIPTION"
.sp
The behavior of apply_visitor is dependent on the number of arguments on which it operates (i\&.e\&., other than the visitor)\&. The function behaves as follows: .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} Overloads accepting one operand invoke the unary function call operator of the given visitor on the content of the given variant operand\&..RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} Overloads accepting two operands invoke the binary function call operator of the given visitor on the content of the given variant operands\&..RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} Overloads accepting three or more operands invoke the function call operator of the given visitor on the content of the given variant operands\&. Maximum amount of parameters controlled by \fBBOOST_VARAINT_MAX_MULTIVIZITOR_PARAMS\fR macro\&. Those functions are actually defined in a header boost/variant/multivisitors\&.hpp (See the section called &#8220;Header <boost/variant/multivisitors.hpp>&#8221;)\&. That header must be manually included if multi visitors are meant for use\&..RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} The overloads accepting only a visitor return a C++03 compatible generic function object or C++14 compatible generic function object that accepts either one, two or arbitrary count of arguments and invoke apply_visitor using these arguments and visitor, thus behaving as specified above\&. (This behavior is particularly useful, for example, when one needs to operate on each element of a sequence of variant objects using a standard library algorithm\&.).RE
.PP
Returns:
.RS 4
The overloads acccepting operands return the result of applying the given visitor to the content of the given operands\&. The overload accepting only a visitor return a function object, thus delaying application of the visitor to any operands\&.
.RE
.PP
Requires:
.RS 4
The given visitor must fulfill the
\fIStaticVisitor\fR
concept requirements with respect to each of the bounded types of the given
variant\&.
.RE
.PP
Throws:
.RS 4
The overloads accepting operands throw only if the given visitor throws when applied\&. The overload accepting only a visitor will not throw\&. (Note, however, that the returned
function object
may throw when invoked\&.)
.RE

