.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::xpressive::placeholder \- For defining a placeholder to stand in for a variable a semantic action\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/xpressive/regex_actions\&.hpp>

template<typename T, int I = 0> 
struct placeholder {
  // construct/copy/destruct
  \fIunspecified\fR operator=(T &) const;
  \fIunspecified\fR operator=(T const &) const;
};
.fi
.SH "DESCRIPTION"
.PP
Use
placeholder<>
to define a placeholder for use in semantic actions to stand in for real objects\&. The use of placeholders allows regular expressions with actions to be defined once and reused in many contexts to read and write from objects which were not available when the regex was defined\&.
.PP
You can use
placeholder<>
by creating an object of type
placeholder<T>
and using that object in a semantic action exactly as you intend an object of type
T
to be used\&.

.sp
.if n \{\
.RS 4
.\}
.nf
placeholder<int> _i;
placeholder<double> _d;

sregex rex = ( some >> regex >> here )
    [ ++_i, _d *= _d ];

.fi
.if n \{\
.RE
.\}
.sp
Then, when doing a pattern match with either
regex_search(),
regex_match()
or
regex_replace(), pass a
match_results<>
object that contains bindings for the placeholders used in the regex object\'s semantic actions\&. You can create the bindings by calling
match_results::let
as follows:

.sp
.if n \{\
.RS 4
.\}
.nf
int i = 0;
double d = 3\&.14;

smatch what;
what\&.let(_i = i)
    \&.let(_d = d);

if(regex_match("some string", rex, what))
   // i and d mutated here

.fi
.if n \{\
.RE
.\}
.sp
If a semantic action executes that contains an unbound placeholder, a exception of type
regex_error
is thrown\&.
.PP
See the discussion for
xpressive::let()
and the
"Referring to Non\-Local Variables"
section in the Users\' Guide for more information\&.
.PP
\fIExample:\fR

.sp
.if n \{\
.RS 4
.\}
.nf
// Define a placeholder for a map object:
placeholder<std::map<std::string, int> > _map;

// Match a word and an integer, separated by =>,
// and then stuff the result into a std::map<>
sregex pair = ( (s1= +_w) >> "=>" >> (s2= +_d) )
    [ _map[s1] = as<int>(s2) ];

// Match one or more word/integer pairs, separated
// by whitespace\&.
sregex rx = pair >> *(+_s >> pair);

// The string to parse
std::string str("aaa=>1 bbb=>23 ccc=>456");

// Here is the actual map to fill in:
std::map<std::string, int> result;

// Bind the _map placeholder to the actual map
smatch what;
what\&.let( _map = result );

// Execute the match and fill in result map
if(regex_match(str, what, rx))
{
    std::cout << result["aaa"] << \'\en\';
    std::cout << result["bbb"] << \'\en\';
    std::cout << result["ccc"] << \'\en\';
}

.fi
.if n \{\
.RE
.\}
.sp

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of the object for which this placeholder stands in\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
int I = 0
.fi

.sp
An optional identifier that can be used to distinguish this placeholder from others that may be used in the same semantic action that happen to have the same type\&.
.RE

.SS "placeholder public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
\fIunspecified\fR operator=(T & t) const;
.fi

.sp

.PP
Parameters:
.RS 4
.PP
t
.RS 4
The object to associate with this placeholder
.RE
.RE
.PP
Returns:
.RS 4
An object of unspecified type that records the association of
t
with
*this\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
\fIunspecified\fR operator=(T const & t) const;
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


