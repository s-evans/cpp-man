.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE S" 3 "" "" ""
.SH "NAME"
boost::interprocess::scoped_ptr
.SH "SYNOPSIS"
.\" unspecified_bool_type: Class template scoped_ptr
.\" Class template scoped_ptr: unspecified_bool_type
.\" swap: Class template scoped_ptr
.\" Class template scoped_ptr: swap
.\" scoped_ptr: Class template scoped_ptr
.\" Class template scoped_ptr: scoped_ptr
.\" reset: Class template scoped_ptr
.\" Class template scoped_ptr: reset
.\" release: Class template scoped_ptr
.\" Class template scoped_ptr: release
.\" pointer: Class template scoped_ptr
.\" Class template scoped_ptr: pointer
.\" get: Class template scoped_ptr
.\" Class template scoped_ptr: get
.\" element_type: Class template scoped_ptr
.\" Class template scoped_ptr: element_type
.\" deleter_type: Class template scoped_ptr
.\" Class template scoped_ptr: deleter_type

.sp
.nf
// In header: <boost/interprocess/smart_ptr/scoped_ptr\&.hpp>

template<typename T, typename Deleter> 
class scoped_ptr : private Deleter {
public:
  // types
  typedef T                    element_type;         
  typedef Deleter              deleter_type;         
  typedef \fIunspecified\fR          pointer;              
  typedef pointer this_type::* unspecified_bool_type;

  // construct/copy/destruct
  explicit scoped_ptr(const pointer & = 0, const Deleter & = Deleter());
  ~scoped_ptr();

  // public member functions
  void reset(const pointer & = 0);
  void reset(const pointer &, const Deleter &);
  pointer release();
  reference operator*() const;
  pointer & operator\->();
  const pointer & operator\->() const;
  pointer & get();
  const pointer & get() const;
  operator unspecified_bool_type() const;
  bool operator!() const;
  void swap(scoped_ptr &);
};
.fi
.SH "DESCRIPTION"
.\" release: Class template scoped_ptr
.\" Class template scoped_ptr: release
.PP
scoped_ptr
stores a pointer to a dynamically allocated object\&. The object pointed to is guaranteed to be deleted, either on destruction of the
scoped_ptr, or via an explicit reset\&. The user can avoid this deletion using release()\&.
scoped_ptr
is parameterized on T (the type of the object pointed to) and Deleter (the functor to be executed to delete the internal pointer)\&. The internal pointer will be of the same pointer type as typename Deleter::pointer type (that is, if typename Deleter::pointer is offset_ptr<void>, the internal pointer will be offset_ptr<T>)\&.
.SS "scoped_ptr public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit scoped_ptr(const pointer & p = 0, const Deleter & d = Deleter());
.fi

.sp
Constructs a
scoped_ptr, storing a copy of p(which can be 0) and d\&. Does not throw\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
~scoped_ptr();
.fi

.sp
If the stored pointer is not 0, destroys the object pointed to by the stored pointer\&. calling the operator() of the stored deleter\&. Never throws
.RE

.SS "scoped_ptr public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" reset: Class template scoped_ptr
.\" Class template scoped_ptr: reset

.sp

.nf
void reset(const pointer & p = 0);
.fi

.sp
Deletes the object pointed to by the stored pointer and then stores a copy of p\&. Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" reset: Class template scoped_ptr
.\" Class template scoped_ptr: reset

.sp

.nf
void reset(const pointer & p, const Deleter & d);
.fi

.sp
Deletes the object pointed to by the stored pointer and then stores a copy of p and a copy of d\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" release: Class template scoped_ptr
.\" Class template scoped_ptr: release

.sp

.nf
pointer release();
.fi

.sp
Assigns internal pointer as 0 and returns previous pointer\&. This will avoid deletion on destructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
reference operator*() const;
.fi

.sp
Returns a reference to the object pointed to by the stored pointer\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
pointer & operator\->();
.fi

.sp
Returns the internal stored pointer\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const pointer & operator\->() const;
.fi

.sp
Returns the internal stored pointer\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" get: Class template scoped_ptr
.\" Class template scoped_ptr: get

.sp

.nf
pointer & get();
.fi

.sp
Returns the stored pointer\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" get: Class template scoped_ptr
.\" Class template scoped_ptr: get

.sp

.nf
const pointer & get() const;
.fi

.sp
Returns the stored pointer\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
operator unspecified_bool_type() const;
.fi

.sp
Conversion to bool Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool operator!() const;
.fi

.sp
Returns true if the stored pointer is 0\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" swap: Class template scoped_ptr
.\" Class template scoped_ptr: swap

.sp

.nf
void swap(scoped_ptr & b);
.fi

.sp
Exchanges the internal pointer and deleter with other
scoped_ptr
Never throws\&.
.RE


