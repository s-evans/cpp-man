.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::container::basic_string
.SH "SYNOPSIS"
.\" value_type: Class template basic_string
.\" Class template basic_string: value_type
.\" traits_type: Class template basic_string
.\" Class template basic_string: traits_type
.\" swap: Class template basic_string
.\" Class template basic_string: swap
.\" stored_allocator_type: Class template basic_string
.\" Class template basic_string: stored_allocator_type
.\" size_type: Class template basic_string
.\" Class template basic_string: size_type
.\" shrink_to_fit: Class template basic_string
.\" Class template basic_string: shrink_to_fit
.\" rfind: Class template basic_string
.\" Class template basic_string: rfind
.\" reverse_iterator: Class template basic_string
.\" Class template basic_string: reverse_iterator
.\" resize: Class template basic_string
.\" Class template basic_string: resize
.\" reserve: Class template basic_string
.\" Class template basic_string: reserve
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" rend: Class template basic_string
.\" Class template basic_string: rend
.\" reference: Class template basic_string
.\" Class template basic_string: reference
.\" rbegin: Class template basic_string
.\" Class template basic_string: rbegin
.\" push_back: Class template basic_string
.\" Class template basic_string: push_back
.\" pop_back: Class template basic_string
.\" Class template basic_string: pop_back
.\" pointer: Class template basic_string
.\" Class template basic_string: pointer
.\" iterator: Class template basic_string
.\" Class template basic_string: iterator
.\" insert: Class template basic_string
.\" Class template basic_string: insert
.\" get_stored_allocator: Class template basic_string
.\" Class template basic_string: get_stored_allocator
.\" find: Class template basic_string
.\" Class template basic_string: find
.\" erase: Class template basic_string
.\" Class template basic_string: erase
.\" end: Class template basic_string
.\" Class template basic_string: end
.\" difference_type: Class template basic_string
.\" Class template basic_string: difference_type
.\" const_reverse_iterator: Class template basic_string
.\" Class template basic_string: const_reverse_iterator
.\" const_reference: Class template basic_string
.\" Class template basic_string: const_reference
.\" const_pointer: Class template basic_string
.\" Class template basic_string: const_pointer
.\" const_iterator: Class template basic_string
.\" Class template basic_string: const_iterator
.\" clear: Class template basic_string
.\" Class template basic_string: clear
.\" begin: Class template basic_string
.\" Class template basic_string: begin
.\" basic_string: Class template basic_string
.\" Class template basic_string: basic_string
.\" at: Class template basic_string
.\" Class template basic_string: at
.\" assign: Class template basic_string
.\" Class template basic_string: assign
.\" append: Class template basic_string
.\" Class template basic_string: append
.\" allocator_type: Class template basic_string
.\" Class template basic_string: allocator_type

.sp
.nf
// In header: <boost/container/string\&.hpp>

template<typename CharT, typename Traits = std::char_traits<CharT>, 
         typename Allocator = new_allocator<CharT> > 
class basic_string {
public:
  // types
  typedef Traits                                                             traits_type;           
  typedef CharT                                                              value_type;            
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef implementation_defined                                             stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  basic_string();
  explicit basic_string(const allocator_type &) noexcept;
  basic_string(const basic_string &);
  basic_string(basic_string &&) noexcept;
  basic_string(const basic_string &, const allocator_type &);
  basic_string(basic_string &&, const allocator_type &);
  basic_string(const basic_string &, size_type, size_type = npos, 
               const allocator_type & = allocator_type());
  basic_string(const CharT *, size_type, 
               const allocator_type & = allocator_type());
  basic_string(const CharT *, const allocator_type & = allocator_type());
  basic_string(size_type, CharT, const allocator_type & = allocator_type());
  basic_string(size_type, default_init_t, 
               const allocator_type & = allocator_type());
  template<typename InputIterator> 
    basic_string(InputIterator, InputIterator, 
                 const allocator_type & = allocator_type());
  basic_string & operator=(const basic_string &);
  basic_string & 
  operator=(basic_string &&) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
  basic_string & operator=(const CharT *);
  basic_string & operator=(CharT);
  ~basic_string();

  // public member functions
  allocator_type get_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_iterator cbegin() const noexcept;
  const_iterator cend() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const noexcept;
  size_type size() const noexcept;
  size_type length() const noexcept;
  size_type max_size() const noexcept;
  void resize(size_type, CharT);
  void resize(size_type);
  void resize(size_type, default_init_t);
  size_type capacity() const noexcept;
  void reserve(size_type);
  void shrink_to_fit();
  reference operator[](size_type) noexcept;
  const_reference operator[](size_type) const noexcept;
  reference at(size_type);
  const_reference at(size_type) const;
  basic_string & operator+=(const basic_string &);
  basic_string & operator+=(const CharT *);
  basic_string & operator+=(CharT);
  basic_string & append(const basic_string &);
  basic_string & append(const basic_string &, size_type, size_type);
  basic_string & append(const CharT *, size_type);
  basic_string & append(const CharT *);
  basic_string & append(size_type, CharT);
  template<typename InputIter> basic_string & append(InputIter, InputIter);
  void push_back(CharT);
  basic_string & assign(const basic_string &);
  basic_string & assign(basic_string &&) noexcept;
  basic_string & assign(const basic_string &, size_type, size_type);
  basic_string & assign(const CharT *, size_type);
  basic_string & assign(const CharT *);
  basic_string & assign(size_type, CharT);
  basic_string & assign(const CharT *, const CharT *);
  template<typename InputIter> basic_string & assign(InputIter, InputIter);
  basic_string & insert(size_type, const basic_string &);
  basic_string & insert(size_type, const basic_string &, size_type, size_type);
  basic_string & insert(size_type, const CharT *, size_type);
  basic_string & insert(size_type, const CharT *);
  basic_string & insert(size_type, size_type, CharT);
  iterator insert(const_iterator, CharT);
  iterator insert(const_iterator, size_type, CharT);
  template<typename InputIter> 
    iterator insert(const_iterator, InputIter, InputIter);
  basic_string & erase(size_type = 0, size_type = npos);
  iterator erase(const_iterator) noexcept;
  iterator erase(const_iterator, const_iterator) noexcept;
  void pop_back() noexcept;
  void clear() noexcept;
  basic_string & replace(size_type, size_type, const basic_string &);
  basic_string & 
  replace(size_type, size_type, const basic_string &, size_type, size_type);
  basic_string & replace(size_type, size_type, const CharT *, size_type);
  basic_string & replace(size_type, size_type, const CharT *);
  basic_string & replace(size_type, size_type, size_type, CharT);
  basic_string & replace(const_iterator, const_iterator, const basic_string &);
  basic_string & 
  replace(const_iterator, const_iterator, const CharT *, size_type);
  basic_string & replace(const_iterator, const_iterator, const CharT *);
  basic_string & replace(const_iterator, const_iterator, size_type, CharT);
  template<typename InputIter> 
    basic_string & 
    replace(const_iterator, const_iterator, InputIter, InputIter);
  size_type copy(CharT *, size_type, size_type = 0) const;
  void swap(basic_string &) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
  const CharT * c_str() const noexcept;
  const CharT * data() const noexcept;
  size_type find(const basic_string &, size_type = 0) const;
  size_type find(const CharT *, size_type, size_type) const;
  size_type find(const CharT *, size_type = 0) const;
  size_type find(CharT, size_type = 0) const;
  size_type rfind(const basic_string &, size_type = npos) const;
  size_type rfind(const CharT *, size_type, size_type) const;
  size_type rfind(const CharT *, size_type = npos) const;
  size_type rfind(CharT, size_type = npos) const;
  size_type find_first_of(const basic_string &, size_type = 0) const;
  size_type find_first_of(const CharT *, size_type, size_type) const;
  size_type find_first_of(const CharT *, size_type = 0) const;
  size_type find_first_of(CharT, size_type = 0) const;
  size_type find_last_of(const basic_string &, size_type = npos) const;
  size_type find_last_of(const CharT *, size_type, size_type) const;
  size_type find_last_of(const CharT *, size_type = npos) const;
  size_type find_last_of(CharT, size_type = npos) const;
  size_type find_first_not_of(const basic_string &, size_type = 0) const;
  size_type find_first_not_of(const CharT *, size_type, size_type) const;
  size_type find_first_not_of(const CharT *, size_type = 0) const;
  size_type find_first_not_of(CharT, size_type = 0) const;
  size_type find_last_not_of(const basic_string &, size_type = npos) const;
  size_type find_last_not_of(const CharT *, size_type, size_type) const;
  size_type find_last_not_of(const CharT *, size_type = npos) const;
  size_type find_last_not_of(CharT, size_type = npos) const;
  basic_string substr(size_type = 0, size_type = npos) const;
  int compare(const basic_string &) const;
  int compare(size_type, size_type, const basic_string &) const;
  int compare(size_type, size_type, const basic_string &, size_type, 
              size_type) const;
  int compare(const CharT *) const;
  int compare(size_type, size_type, const CharT *, size_type) const;
  int compare(size_type, size_type, const CharT *) const;

  // public data members
  static const size_type npos;
};
.fi
.SH "DESCRIPTION"
.\" begin: Class template basic_string
.\" Class template basic_string: begin
.PP
The
basic_string
class represents a Sequence of characters\&. It contains all the usual operations of a Sequence, and, additionally, it contains standard string operations such as search and concatenation\&.
.PP
The
basic_string
class is parameterized by character type, and by that type\'s Character Traits\&.
.PP
This class has performance characteristics very much like vector<>, meaning, for example, that it does not perform reference\-count or copy\-on\-write, and that concatenation of two strings is an O(N) operation\&.
.PP
Some of
basic_string\'s member functions use an unusual method of specifying positions and ranges\&. In addition to the conventional method using iterators, many of
basic_string\'s member functions use a single value pos of type size_type to represent a position (in which case the position is begin() + pos, and many of
basic_string\'s member functions use two values, pos and n, to represent a range\&. In that case pos is the beginning of the range and n is its size\&. That is, the range is [begin() + pos, begin() + pos + n)\&.
.PP
Note that the C++ standard does not specify the complexity of
basic_string
operations\&. In this implementation,
basic_string
has performance characteristics very similar to those of vector: access to a single character is O(1), while copy and concatenation are O(N)\&.
.PP
In this implementation, begin(), end(), rbegin(), rend(), operator[], c_str(), and data() do not invalidate iterators\&. In this implementation, iterators are only invalidated by member functions that explicitly change the string\'s contents\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename CharT
.fi

.sp
The type of character it contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Traits = std::char_traits<CharT>
.fi

.sp
The Character Traits type, which encapsulates basic character operations
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<CharT>
.fi

.sp
The allocator, used for internal memory management\&.
.RE

.SS "basic_string public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
basic_string();
.fi

.sp
\fBEffects\fR: Default constructs a
basic_string\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit basic_string(const allocator_type & a) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a
basic_string
taking the allocator as parameter\&.
.sp
\fBThrows\fR: Nothing
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
basic_string(const basic_string & s);
.fi

.sp
\fBEffects\fR: Copy constructs a
basic_string\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor or allocation throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
basic_string(basic_string && s) noexcept;
.fi

.sp
\fBEffects\fR: Move constructor\&. Moves s\'s resources to *this\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
basic_string(const basic_string & s, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a
basic_string
using the specified allocator\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocation throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
basic_string(basic_string && s, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructor using the specified allocator\&. Moves s\'s resources to *this\&.
.sp
\fBThrows\fR: If allocation throws\&.
.sp
\fBComplexity\fR: Constant if a == s\&.get_allocator(), linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
basic_string(const basic_string & s, size_type pos, size_type n = npos, 
             const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
basic_string
taking the allocator as parameter, and is initialized by a specific number of characters of the s string\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
basic_string(const CharT * s, size_type n, 
             const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
basic_string
taking the allocator as parameter, and is initialized by a specific number of characters of the s c\-string\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
basic_string(const CharT * s, const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
basic_string
taking the allocator as parameter, and is initialized by the null\-terminated s c\-string\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
basic_string(size_type n, CharT c, 
             const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
basic_string
taking the allocator as parameter, and is initialized by n copies of c\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
basic_string(size_type n, default_init_t, 
             const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
basic_string
taking the allocator as parameter, and is initialized by n default\-initialized characters\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  basic_string(InputIterator f, InputIterator l, 
               const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
basic_string
taking the allocator as parameter, and a range of iterators\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
basic_string & operator=(const basic_string & x);
.fi

.sp
\fBEffects\fR: Copy constructs a string\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
basic_string & 
operator=(basic_string && x) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Move constructor\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and allocation throws
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
basic_string & operator=(const CharT * s);
.fi

\fBEffects\fR: Assignment from a null\-terminated c\-string\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
basic_string & operator=(CharT c);
.fi

\fBEffects\fR: Assignment from character\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
~basic_string();
.fi

.sp
\fBEffects\fR: Destroys the
basic_string\&. All used memory is deallocated\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE

.SS "basic_string public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a copy of the internal allocator\&.
.sp
\fBThrows\fR: If allocator\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get_stored_allocator: Class template basic_string
.\" Class template basic_string: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get_stored_allocator: Class template basic_string
.\" Class template basic_string: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" begin: Class template basic_string
.\" Class template basic_string: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" begin: Class template basic_string
.\" Class template basic_string: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" end: Class template basic_string
.\" Class template basic_string: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" end: Class template basic_string
.\" Class template basic_string: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" rbegin: Class template basic_string
.\" Class template basic_string: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" rbegin: Class template basic_string
.\" Class template basic_string: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rend: Class template basic_string
.\" Class template basic_string: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rend: Class template basic_string
.\" Class template basic_string: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
\fBEffects\fR: Returns true if the vector contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
size_type length() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" resize: Class template basic_string
.\" Class template basic_string: resize

.sp

.nf
void resize(size_type n, CharT c);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are copy constructed from x\&.
.sp
\fBThrows\fR: If memory allocation throws
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" resize: Class template basic_string
.\" Class template basic_string: resize

.sp

.nf
void resize(size_type n);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are value initialized\&.
.sp
\fBThrows\fR: If memory allocation throws
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" resize: Class template basic_string
.\" Class template basic_string: resize

.sp

.nf
void resize(size_type n, default_init_t);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are uninitialized\&.
.sp
\fBThrows\fR: If memory allocation throws
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
size_type capacity() const noexcept;
.fi

.sp
\fBEffects\fR: Number of elements for which memory has been allocated\&. capacity() is always greater than or equal to size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" reserve: Class template basic_string
.\" Class template basic_string: reserve

.sp

.nf
void reserve(size_type res_arg);
.fi

.sp
\fBEffects\fR: If n is less than or equal to capacity(), this call has no effect\&. Otherwise, it is a request for allocation of additional memory\&. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged\&. In either case, size() is unchanged\&.
.sp
\fBThrows\fR: If memory allocation allocation throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" shrink_to_fit: Class template basic_string
.\" Class template basic_string: shrink_to_fit

.sp

.nf
void shrink_to_fit();
.fi

.sp
\fBEffects\fR: Tries to deallocate the excess of memory created with previous allocations\&. The size of the string is unchanged
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear to size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
reference operator[](size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}

.sp

.nf
const_reference operator[](size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" at: Class template basic_string
.\" Class template basic_string: at

.sp

.nf
reference at(size_type n);
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" at: Class template basic_string
.\" Class template basic_string: at

.sp

.nf
const_reference at(size_type n) const;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & operator+=(const basic_string & s);
.fi

.sp
\fBEffects\fR: Calls append(str\&.data, str\&.size())\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & operator+=(const CharT * s);
.fi

.sp
\fBEffects\fR: Calls append(s)\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & operator+=(CharT c);
.fi

.sp
\fBEffects\fR: Calls append(1, c)\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & append(const basic_string & s);
.fi

.sp
\fBEffects\fR: Calls append(str\&.data(), str\&.size())\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & append(const basic_string & s, size_type pos, size_type n);
.fi

.sp
\fBRequires\fR: pos <= str\&.size()
.sp
\fBEffects\fR: Determines the effective length rlen of the string to append as the smaller of n and str\&.size() \- pos and calls append(str\&.data() + pos, rlen)\&.
.sp
\fBThrows\fR: If memory allocation throws and out_of_range if pos > str\&.size()
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & append(const CharT * s, size_type n);
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT\&.
.sp
\fBEffects\fR: The function replaces the string controlled by *this with a string of length size() + n whose irst size() elements are a copy of the original string controlled by *this and whose remaining elements are a copy of the initial n elements of s\&.
.sp
\fBThrows\fR: If memory allocation throws length_error if size() + n > max_size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & append(const CharT * s);
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBEffects\fR: Calls append(s, traits::length(s))\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
basic_string & append(size_type n, CharT c);
.fi

.sp
\fBEffects\fR: Equivalent to append(basic_string(n, c))\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" append: Class template basic_string
.\" Class template basic_string: append
.\" append: Class template basic_string
.\" Class template basic_string: append

.sp

.nf
template<typename InputIter> 
  basic_string & append(InputIter first, InputIter last);
.fi

.sp
\fBRequires\fR: [first,last) is a valid range\&.
.sp
\fBEffects\fR: Equivalent to append(basic_string(first, last))\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" push_back: Class template basic_string
.\" Class template basic_string: push_back

.sp

.nf
void push_back(CharT c);
.fi

\fBEffects\fR: Equivalent to append(static_cast<size_type>(1), c)\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
basic_string & assign(const basic_string & s);
.fi

.sp
\fBEffects\fR: Equivalent to assign(str, 0, npos)\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
basic_string & assign(basic_string && ms) noexcept;
.fi

.sp
\fBEffects\fR: The function replaces the string controlled by *this with a string of length str\&.size() whose elements are a copy of the string controlled by str\&. Leaves str in a valid but unspecified state\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
basic_string & assign(const basic_string & s, size_type pos, size_type n);
.fi

.sp
\fBRequires\fR: pos <= str\&.size()
.sp
\fBEffects\fR: Determines the effective length rlen of the string to assign as the smaller of n and str\&.size() \- pos and calls assign(str\&.data() + pos rlen)\&.
.sp
\fBThrows\fR: If memory allocation throws or out_of_range if pos > str\&.size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
basic_string & assign(const CharT * s, size_type n);
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT\&.
.sp
\fBEffects\fR: Replaces the string controlled by *this with a string of length n whose elements are a copy of those pointed to by s\&.
.sp
\fBThrows\fR: If memory allocation throws or length_error if n > max_size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
basic_string & assign(const CharT * s);
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBEffects\fR: Calls assign(s, traits::length(s))\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
basic_string & assign(size_type n, CharT c);
.fi

.sp
\fBEffects\fR: Equivalent to assign(basic_string(n, c))\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
basic_string & assign(const CharT * first, const CharT * last);
.fi

.sp
\fBEffects\fR: Equivalent to assign(basic_string(first, last))\&.
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" assign: Class template basic_string
.\" Class template basic_string: assign
.\" assign: Class template basic_string
.\" Class template basic_string: assign

.sp

.nf
template<typename InputIter> 
  basic_string & assign(InputIter first, InputIter last);
.fi

.sp
\fBEffects\fR: Equivalent to assign(basic_string(first, last))\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
basic_string & insert(size_type pos, const basic_string & s);
.fi

.sp
\fBRequires\fR: pos <= size()\&.
.sp
\fBEffects\fR: Calls insert(pos, str\&.data(), str\&.size())\&.
.sp
\fBThrows\fR: If memory allocation throws or out_of_range if pos > size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
basic_string & 
insert(size_type pos1, const basic_string & s, size_type pos2, size_type n);
.fi

.sp
\fBRequires\fR: pos1 <= size() and pos2 <= str\&.size()
.sp
\fBEffects\fR: Determines the effective length rlen of the string to insert as the smaller of n and str\&.size() \- pos2 and calls insert(pos1, str\&.data() + pos2, rlen)\&.
.sp
\fBThrows\fR: If memory allocation throws or out_of_range if pos1 > size() or pos2 > str\&.size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
basic_string & insert(size_type pos, const CharT * s, size_type n);
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT and pos <= size()\&.
.sp
\fBEffects\fR: Replaces the string controlled by *this with a string of length size() + n whose first pos elements are a copy of the initial elements of the original string controlled by *this and whose next n elements are a copy of the elements in s and whose remaining elements are a copy of the remaining elements of the original string controlled by *this\&.
.sp
\fBThrows\fR: If memory allocation throws, out_of_range if pos > size() or length_error if size() + n > max_size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
basic_string & insert(size_type pos, const CharT * s);
.fi

.sp
\fBRequires\fR: pos <= size() and s points to an array of at least traits::length(s) + 1 elements of CharT
.sp
\fBEffects\fR: Calls insert(pos, s, traits::length(s))\&.
.sp
\fBThrows\fR: If memory allocation throws, out_of_range if pos > size() length_error if size() > max_size() \- Traits::length(s)
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
basic_string & insert(size_type pos, size_type n, CharT c);
.fi

.sp
\fBEffects\fR: Equivalent to insert(pos, basic_string(n, c))\&.
.sp
\fBThrows\fR: If memory allocation throws, out_of_range if pos > size() length_error if size() > max_size() \- n
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
iterator insert(const_iterator p, CharT c);
.fi

.sp
\fBRequires\fR: p is a valid iterator on *this\&.
.sp
\fBEffects\fR: inserts a copy of c before the character referred to by p\&.
.sp
\fBReturns\fR: An iterator which refers to the copy of the inserted character\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
iterator insert(const_iterator p, size_type n, CharT c);
.fi

.sp
\fBRequires\fR: p is a valid iterator on *this\&.
.sp
\fBEffects\fR: Inserts n copies of c before the character referred to by p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if n is 0\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" insert: Class template basic_string
.\" Class template basic_string: insert
.\" insert: Class template basic_string
.\" Class template basic_string: insert

.sp

.nf
template<typename InputIter> 
  iterator insert(const_iterator p, InputIter first, InputIter last);
.fi

.sp
\fBRequires\fR: p is a valid iterator on *this\&. [first,last) is a valid range\&.
.sp
\fBEffects\fR: Equivalent to insert(p \- begin(), basic_string(first, last))\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if first == last\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" erase: Class template basic_string
.\" Class template basic_string: erase

.sp

.nf
basic_string & erase(size_type pos = 0, size_type n = npos);
.fi

.sp
\fBRequires\fR: pos <= size()
.sp
\fBEffects\fR: Determines the effective length xlen of the string to be removed as the smaller of n and size() \- pos\&. The function then replaces the string controlled by *this with a string of length size() \- xlen whose first pos elements are a copy of the initial elements of the original string controlled by *this, and whose remaining elements are a copy of the elements of the original string controlled by *this beginning at position pos + xlen\&.
.sp
\fBThrows\fR: out_of_range if pos > size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" erase: Class template basic_string
.\" Class template basic_string: erase

.sp

.nf
iterator erase(const_iterator p) noexcept;
.fi

.sp
\fBEffects\fR: Removes the character referred to by p\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: An iterator which points to the element immediately following p prior to the element being erased\&. If no such element exists, end() is returned\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" erase: Class template basic_string
.\" Class template basic_string: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last) noexcept;
.fi

.sp
\fBRequires\fR: first and last are valid iterators on *this, defining a range [first,last)\&.
.sp
\fBEffects\fR: Removes the characters in the range [first,last)\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: An iterator which points to the element pointed to by last prior to the other elements being erased\&. If no such element exists, end() is returned\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" erase: Class template basic_string
.\" Class template basic_string: erase
.\" pop_back: Class template basic_string
.\" Class template basic_string: pop_back

.sp

.nf
void pop_back() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBThrows\fR: Nothing
.sp
\fBEffects\fR: Equivalent to erase(size() \- 1, 1)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" clear: Class template basic_string
.\" Class template basic_string: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: Erases all the elements of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the vector\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & replace(size_type pos1, size_type n1, const basic_string & str);
.fi

.sp
\fBRequires\fR: pos1 <= size()\&.
.sp
\fBEffects\fR: Calls replace(pos1, n1, str\&.data(), str\&.size())\&.
.sp
\fBThrows\fR: if memory allocation throws or out_of_range if pos1 > size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & 
replace(size_type pos1, size_type n1, const basic_string & str, 
        size_type pos2, size_type n2);
.fi

.sp
\fBRequires\fR: pos1 <= size() and pos2 <= str\&.size()\&.
.sp
\fBEffects\fR: Determines the effective length rlen of the string to be inserted as the smaller of n2 and str\&.size() \- pos2 and calls replace(pos1, n1, str\&.data() + pos2, rlen)\&.
.sp
\fBThrows\fR: if memory allocation throws, out_of_range if pos1 > size() or pos2 > str\&.size()\&.
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & 
replace(size_type pos1, size_type n1, const CharT * s, size_type n2);
.fi

.sp
\fBRequires\fR: pos1 <= size() and s points to an array of at least n2 elements of CharT\&.
.sp
\fBEffects\fR: Determines the effective length xlen of the string to be removed as the smaller of n1 and size() \- pos1\&. If size() \- xlen >= max_size() \- n2 throws length_error\&. Otherwise, the function replaces the string controlled by *this with a string of length size() \- xlen + n2 whose first pos1 elements are a copy of the initial elements of the original string controlled by *this, whose next n2 elements are a copy of the initial n2 elements of s, and whose remaining elements are a copy of the elements of the original string controlled by *this beginning at position pos + xlen\&.
.sp
\fBThrows\fR: if memory allocation throws, out_of_range if pos1 > size() or length_error if the length of the resulting string would exceed max_size()
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & replace(size_type pos, size_type n1, const CharT * s);
.fi

.sp
\fBRequires\fR: pos1 <= size() and s points to an array of at least n2 elements of CharT\&.
.sp
\fBEffects\fR: Determines the effective length xlen of the string to be removed as the smaller of n1 and size() \- pos1\&. If size() \- xlen >= max_size() \- n2 throws length_error\&. Otherwise, the function replaces the string controlled by *this with a string of length size() \- xlen + n2 whose first pos1 elements are a copy of the initial elements of the original string controlled by *this, whose next n2 elements are a copy of the initial n2 elements of s, and whose remaining elements are a copy of the elements of the original string controlled by *this beginning at position pos + xlen\&.
.sp
\fBThrows\fR: if memory allocation throws, out_of_range if pos1 > size() or length_error if the length of the resulting string would exceed max_size()
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'65.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "65." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & replace(size_type pos1, size_type n1, size_type n2, CharT c);
.fi

.sp
\fBRequires\fR: pos1 <= size()\&.
.sp
\fBEffects\fR: Equivalent to replace(pos1, n1, basic_string(n2, c))\&.
.sp
\fBThrows\fR: if memory allocation throws, out_of_range if pos1 > size() or length_error if the length of the resulting string would exceed max_size()
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'66.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "66." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & 
replace(const_iterator i1, const_iterator i2, const basic_string & str);
.fi

.sp
\fBRequires\fR: [begin(),i1) and [i1,i2) are valid ranges\&.
.sp
\fBEffects\fR: Calls replace(i1 \- begin(), i2 \- i1, str)\&.
.sp
\fBThrows\fR: if memory allocation throws
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'67.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "67." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & 
replace(const_iterator i1, const_iterator i2, const CharT * s, size_type n);
.fi

.sp
\fBRequires\fR: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least n elements
.sp
\fBEffects\fR: Calls replace(i1 \- begin(), i2 \- i1, s, n)\&.
.sp
\fBThrows\fR: if memory allocation throws
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'68.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "68." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & replace(const_iterator i1, const_iterator i2, const CharT * s);
.fi

.sp
\fBRequires\fR: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBEffects\fR: Calls replace(i1 \- begin(), i2 \- i1, s, traits::length(s))\&.
.sp
\fBThrows\fR: if memory allocation throws
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'69.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "69." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
basic_string & 
replace(const_iterator i1, const_iterator i2, size_type n, CharT c);
.fi

.sp
\fBRequires\fR: [begin(),i1) and [i1,i2) are valid ranges\&.
.sp
\fBEffects\fR: Calls replace(i1 \- begin(), i2 \- i1, basic_string(n, c))\&.
.sp
\fBThrows\fR: if memory allocation throws
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'70.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "70." 4.2
.\}
.\" replace: Class template basic_string
.\" Class template basic_string: replace
.\" replace: Class template basic_string
.\" Class template basic_string: replace

.sp

.nf
template<typename InputIter> 
  basic_string & 
  replace(const_iterator i1, const_iterator i2, InputIter j1, InputIter j2);
.fi

.sp
\fBRequires\fR: [begin(),i1), [i1,i2) and [j1,j2) are valid ranges\&.
.sp
\fBEffects\fR: Calls replace(i1 \- begin(), i2 \- i1, basic_string(j1, j2))\&.
.sp
\fBThrows\fR: if memory allocation throws
.sp
\fBReturns\fR: *this
.RE


.sp
.RS 4
.ie n \{\
\h'-04'71.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "71." 4.2
.\}

.sp

.nf
size_type copy(CharT * s, size_type n, size_type pos = 0) const;
.fi

.sp
\fBRequires\fR: pos <= size()
.sp
\fBEffects\fR: Determines the effective length rlen of the string to copy as the smaller of n and size() \- pos\&. s shall designate an array of at least rlen elements\&. The function then replaces the string designated by s with a string of length rlen whose elements are a copy of the string controlled by *this beginning at position pos\&. The function does not append a null object to the string designated by s\&.
.sp
\fBThrows\fR: if memory allocation throws, out_of_range if pos > size()\&.
.sp
\fBReturns\fR: rlen
.RE


.sp
.RS 4
.ie n \{\
\h'-04'72.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "72." 4.2
.\}
.\" swap: Class template basic_string
.\" Class template basic_string: swap

.sp

.nf
void swap(basic_string & x) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: *this contains the same sequence of characters that was in s, s contains the same sequence of characters that was in *this\&.
.sp
\fBThrows\fR: Nothing
.RE


.sp
.RS 4
.ie n \{\
\h'-04'73.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "73." 4.2
.\}

.sp

.nf
const CharT * c_str() const noexcept;
.fi

.sp
\fBRequires\fR: The program shall not alter any of the values stored in the character array\&.
.sp
\fBReturns\fR: A pointer p such that p + i == &operator[](i) for each i in [0,size()]\&.
.sp
\fBComplexity\fR: constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'74.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "74." 4.2
.\}

.sp

.nf
const CharT * data() const noexcept;
.fi

.sp
\fBRequires\fR: The program shall not alter any of the values stored in the character array\&.
.sp
\fBReturns\fR: A pointer p such that p + i == &operator[](i) for each i in [0,size()]\&.
.sp
\fBComplexity\fR: constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'75.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "75." 4.2
.\}
.\" find: Class template basic_string
.\" Class template basic_string: find

.sp

.nf
size_type find(const basic_string & s, size_type pos = 0) const;
.fi

.sp
\fBEffects\fR: Determines the lowest position xpos, if possible, such that both of the following conditions obtain: 19 pos <= xpos and xpos + str\&.size() <= size(); 2) traits::eq(at(xpos+I), str\&.at(I)) for all elements I of the string controlled by str\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: xpos if the function can determine such a value for xpos\&. Otherwise, returns npos\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'76.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "76." 4.2
.\}
.\" find: Class template basic_string
.\" Class template basic_string: find

.sp

.nf
size_type find(const CharT * s, size_type pos, size_type n) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find(basic_string<CharT,traits,Allocator>(s,n),pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'77.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "77." 4.2
.\}
.\" find: Class template basic_string
.\" Class template basic_string: find

.sp

.nf
size_type find(const CharT * s, size_type pos = 0) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find(basic_string(s), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'78.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "78." 4.2
.\}
.\" find: Class template basic_string
.\" Class template basic_string: find

.sp

.nf
size_type find(CharT c, size_type pos = 0) const;
.fi

.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find(basic_string<CharT,traits,Allocator>(1,c), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'79.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "79." 4.2
.\}
.\" rfind: Class template basic_string
.\" Class template basic_string: rfind

.sp

.nf
size_type rfind(const basic_string & str, size_type pos = npos) const;
.fi

.sp
\fBEffects\fR: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos <= pos and xpos + str\&.size() <= size(); b) traits::eq(at(xpos+I), str\&.at(I)) for all elements I of the string controlled by str\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: xpos if the function can determine such a value for xpos\&. Otherwise, returns npos\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'80.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "80." 4.2
.\}
.\" rfind: Class template basic_string
.\" Class template basic_string: rfind

.sp

.nf
size_type rfind(const CharT * s, size_type pos, size_type n) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: rfind(basic_string(s, n), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'81.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "81." 4.2
.\}
.\" rfind: Class template basic_string
.\" Class template basic_string: rfind

.sp

.nf
size_type rfind(const CharT * s, size_type pos = npos) const;
.fi

.sp
\fBRequires\fR: pos <= size() and s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: rfind(basic_string(s), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'82.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "82." 4.2
.\}
.\" rfind: Class template basic_string
.\" Class template basic_string: rfind

.sp

.nf
size_type rfind(CharT c, size_type pos = npos) const;
.fi

.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: rfind(basic_string<CharT,traits,Allocator>(1,c),pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'83.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "83." 4.2
.\}

.sp

.nf
size_type find_first_of(const basic_string & s, size_type pos = 0) const;
.fi

.sp
\fBEffects\fR: Determines the lowest position xpos, if possible, such that both of the following conditions obtain: a) pos <= xpos and xpos < size(); b) traits::eq(at(xpos), str\&.at(I)) for some element I of the string controlled by str\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: xpos if the function can determine such a value for xpos\&. Otherwise, returns npos\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'84.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "84." 4.2
.\}

.sp

.nf
size_type find_first_of(const CharT * s, size_type pos, size_type n) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_first_of(basic_string(s, n), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'85.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "85." 4.2
.\}

.sp

.nf
size_type find_first_of(const CharT * s, size_type pos = 0) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_first_of(basic_string(s), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'86.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "86." 4.2
.\}

.sp

.nf
size_type find_first_of(CharT c, size_type pos = 0) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_first_of(basic_string<CharT,traits,Allocator>(1,c), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'87.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "87." 4.2
.\}

.sp

.nf
size_type find_last_of(const basic_string & str, size_type pos = npos) const;
.fi

.sp
\fBEffects\fR: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos <= pos and xpos < size(); b) traits::eq(at(xpos), str\&.at(I)) for some element I of the string controlled by str\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: xpos if the function can determine such a value for xpos\&. Otherwise, returns npos\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'88.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "88." 4.2
.\}

.sp

.nf
size_type find_last_of(const CharT * s, size_type pos, size_type n) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_last_of(basic_string(s, n), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'89.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "89." 4.2
.\}

.sp

.nf
size_type find_last_of(const CharT * s, size_type pos = npos) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_last_of(basic_string<CharT,traits,Allocator>(1,c),pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'90.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "90." 4.2
.\}

.sp

.nf
size_type find_last_of(CharT c, size_type pos = npos) const;
.fi

.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_last_of(basic_string(s), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'91.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "91." 4.2
.\}

.sp

.nf
size_type find_first_not_of(const basic_string & str, size_type pos = 0) const;
.fi

.sp
\fBEffects\fR: Determines the lowest position xpos, if possible, such that both of the following conditions obtain: a) pos <= xpos and xpos < size(); b) traits::eq(at(xpos), str\&.at(I)) for no element I of the string controlled by str\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: xpos if the function can determine such a value for xpos\&. Otherwise, returns npos\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'92.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "92." 4.2
.\}

.sp

.nf
size_type find_first_not_of(const CharT * s, size_type pos, size_type n) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_first_not_of(basic_string(s, n), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'93.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "93." 4.2
.\}

.sp

.nf
size_type find_first_not_of(const CharT * s, size_type pos = 0) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_first_not_of(basic_string(s), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'94.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "94." 4.2
.\}

.sp

.nf
size_type find_first_not_of(CharT c, size_type pos = 0) const;
.fi

.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_first_not_of(basic_string(1, c), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'95.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "95." 4.2
.\}

.sp

.nf
size_type find_last_not_of(const basic_string & str, size_type pos = npos) const;
.fi

.sp
\fBEffects\fR: Determines the highest position xpos, if possible, such that both of the following conditions obtain: a) xpos <= pos and xpos < size(); b) traits::eq(at(xpos), str\&.at(I)) for no element I of the string controlled by str\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: xpos if the function can determine such a value for xpos\&. Otherwise, returns npos\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'96.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "96." 4.2
.\}

.sp

.nf
size_type find_last_not_of(const CharT * s, size_type pos, size_type n) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least n elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_last_not_of(basic_string(s, n), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'97.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "97." 4.2
.\}

.sp

.nf
size_type find_last_not_of(const CharT * s, size_type pos = npos) const;
.fi

.sp
\fBRequires\fR: s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_last_not_of(basic_string(s), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'98.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "98." 4.2
.\}

.sp

.nf
size_type find_last_not_of(CharT c, size_type pos = npos) const;
.fi

.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: find_last_not_of(basic_string(1, c), pos)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'99.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "99." 4.2
.\}

.sp

.nf
basic_string substr(size_type pos = 0, size_type n = npos) const;
.fi

.sp
\fBRequires\fR: Requires: pos <= size()
.sp
\fBEffects\fR: Determines the effective length rlen of the string to copy as the smaller of n and size() \- pos\&.
.sp
\fBThrows\fR: If memory allocation throws or out_of_range if pos > size()\&.
.sp
\fBReturns\fR: basic_string<CharT,traits,Allocator>(data()+pos,rlen)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'100.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "100." 4.2
.\}

.sp

.nf
int compare(const basic_string & str) const;
.fi

.sp
\fBEffects\fR: Determines the effective length rlen of the string to copy as the smaller of size() and str\&.size()\&. The function then compares the two strings by calling traits::compare(data(), str\&.data(), rlen)\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: The nonzero result if the result of the comparison is nonzero\&. Otherwise, returns a value < 0 if size() < str\&.size(), a 0 value if size() == str\&.size(), and value > 0 if size() > str\&.size()
.RE


.sp
.RS 4
.ie n \{\
\h'-04'101.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "101." 4.2
.\}

.sp

.nf
int compare(size_type pos1, size_type n1, const basic_string & str) const;
.fi

.sp
\fBRequires\fR: pos1 <= size()
.sp
\fBEffects\fR: Determines the effective length rlen of the string to copy as the smaller of
.sp
\fBThrows\fR: out_of_range if pos1 > size()
.sp
\fBReturns\fR:basic_string(*this,pos1,n1)\&.compare(str)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'102.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "102." 4.2
.\}

.sp

.nf
int compare(size_type pos1, size_type n1, const basic_string & str, 
            size_type pos2, size_type n2) const;
.fi

.sp
\fBRequires\fR: pos1 <= size() and pos2 <= str\&.size()
.sp
\fBEffects\fR: Determines the effective length rlen of the string to copy as the smaller of
.sp
\fBThrows\fR: out_of_range if pos1 > size() or pos2 > str\&.size()
.sp
\fBReturns\fR: basic_string(*this, pos1, n1)\&.compare(basic_string(str, pos2, n2))\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'103.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "103." 4.2
.\}

.sp

.nf
int compare(const CharT * s) const;
.fi

.sp
\fBThrows\fR: Nothing
.sp
\fBReturns\fR: compare(basic_string(s))\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'104.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "104." 4.2
.\}

.sp

.nf
int compare(size_type pos1, size_type n1, const CharT * s, size_type n2) const;
.fi

.sp
\fBRequires\fR: pos1 > size() and s points to an array of at least n2 elements of CharT\&.
.sp
\fBThrows\fR: out_of_range if pos1 > size()
.sp
\fBReturns\fR: basic_string(*this, pos, n1)\&.compare(basic_string(s, n2))\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'105.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "105." 4.2
.\}

.sp

.nf
int compare(size_type pos1, size_type n1, const CharT * s) const;
.fi

.sp
\fBRequires\fR: pos1 > size() and s points to an array of at least traits::length(s) + 1 elements of CharT\&.
.sp
\fBThrows\fR: out_of_range if pos1 > size()
.sp
\fBReturns\fR: basic_string(*this, pos, n1)\&.compare(basic_string(s, n2))\&.
.RE


