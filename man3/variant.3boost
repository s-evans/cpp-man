.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE VA" 3 "" "" ""
.SH "NAME"
boost::variant \- Safe, generic, stack\-based discriminated union container\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/variant/variant\&.hpp>

template<typename T1, typename T2 = \fIunspecified\fR, \&.\&.\&., 
         typename TN = \fIunspecified\fR> 
class variant {
public:
  // types
  typedef \fIunspecified\fR types;

  // construct/copy/destruct
  variant();
  variant(const variant &);
  variant(variant &&);
  template<typename T> variant(T &);
  template<typename T> variant(const T &);
  template<typename T> variant(T &&);
  template<typename U1, typename U2, \&.\&.\&., typename UN> 
    variant(variant<U1, U2, \&.\&.\&., UN> &);
  template<typename U1, typename U2, \&.\&.\&., typename UN> 
    variant(const variant<U1, U2, \&.\&.\&., UN> &);
  template<typename U1, typename U2, \&.\&.\&., typename UN> 
    variant(variant<U1, U2, \&.\&.\&., UN> &&);
  ~variant();

  // modifiers
  void swap(variant &);
  variant & operator=(const variant &);
  variant & operator=(variant &&);
  template<typename T> variant & operator=(const T &);
  template<typename T> variant & operator=(T &&);

  // queries
  int which() const;
  bool empty() const;
  const std::type_info & type() const;

  // relational
  bool operator==(const variant &) const;
  template<typename U> void operator==(const U &) const;
  bool operator!=(const variant &) const;
  template<typename U> void operator!=(const U &) const;
  bool operator<(const variant &) const;
  template<typename U> void operator<(const U &) const;
  bool operator>(const variant &) const;
  template<typename U> void operator>(const U &) const;
  bool operator<=(const variant &) const;
  template<typename U> void operator<=(const U &) const;
  bool operator>=(const variant &) const;
  template<typename U> void operator>=(const U &) const;
};
.fi
.SH "DESCRIPTION"
.sp
The variant class template (inspired by Andrei Alexandrescu\'s class of the same name [Ale01A]) is an efficient, recursive\-capable, bounded discriminated union value type capable of containing any value type (either POD or non\-POD)\&. It supports construction from any type convertible to one of its bounded types or from a source variant whose bounded types are each convertible to one of the destination variant\'s bounded types\&. As well, through apply_visitor, variant supports compile\-time checked, type\-safe visitation; and through get, variant supports run\-time checked, type\-safe value retrieval\&.
.sp
\fBNotes\fR:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The bounded types of the variant are exposed
            via the nested typedef types, which is an
            MPL\-compatible Sequence containing the
            set of types that must be handled by any
            visitor to
            the variant\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
All members of variant satisfy at least the
            basic guarantee of exception\-safety\&. That is, all operations on
            a variant remain defined even after previous
            operations have failed\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Each type specified as a template argument to
            variant must meet the requirements of the
            \fIBoundedType\fR
            concept\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Each type specified as a template argument to
            variant must be distinct after removal of qualifiers\&.
            Thus, for instance, both variant<int, int> and
            variant<int, const int> have undefined
            behavior\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Conforming implementations of variant must
            allow at least ten types as template arguments\&. The exact number
            of allowed arguments is exposed by the preprocessor macro
            BOOST_VARIANT_LIMIT_TYPES\&.
            (See make_variant_over for a
            means to specify the bounded types of a variant by
            the elements of an MPL or compatible
            Sequence, thus overcoming this limitation\&.).RE
.SS "variant public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
variant();
.fi

.PP
Requires:
.RS 4
The first bounded type of the
variant
(i\&.e\&.,
T1) must fulfill the requirements of the
\fIDefaultConstructible\fR
[20\&.1\&.4] concept\&.
.RE
.PP
Postconditions:
.RS 4
Content of
*this
is the default value of the first bounded type (i\&.e,
T1)\&.
.RE
.PP
Throws:
.RS 4
May fail with any exceptions arising from the default constructor of
T1\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
variant(const variant & other);
.fi

.PP
Postconditions:
.RS 4
Content of
*this
is a copy of the content of
other\&.
.RE
.PP
Throws:
.RS 4
May fail with any exceptions arising from the copy constructor of
other\'s contained type\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
variant(variant && other);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Postconditions:
.RS 4
Content of
*this
is move constructed from the content of
other\&.
.RE
.PP
Throws:
.RS 4
May fail with any exceptions arising from the move constructor of
other\'s contained type\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename T> variant(T & operand);
.fi

.PP
Requires:
.RS 4
T
must be unambiguously convertible to one of the bounded types (i\&.e\&.,
T1,
T2, etc\&.)\&.
.RE
.PP
Postconditions:
.RS 4
Content of
*this
is the best conversion of
operand
to one of the bounded types, as determined by standard overload resolution rules\&.
.RE
.PP
Throws:
.RS 4
May fail with any exceptions arising from the conversion of
operand
to one of the bounded types\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename T> variant(const T & operand);
.fi

.PP
Notes:
.RS 4
Same semantics as previous constructor, but allows construction from temporaries\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename T> variant(T && operand);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Notes:
.RS 4
Same semantics as previous constructor, but allows move construction if
operand
is an rvalue\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename U1, typename U2, \&.\&.\&., typename UN> 
  variant(variant<U1, U2, \&.\&.\&., UN> & operand);
.fi

.PP
Requires:
.RS 4
\fIEvery\fR
one of
U1,
U2, \&.\&.\&.,
UN
must have an unambiguous conversion to one of the bounded types (i\&.e\&.,
T1,
T2, \&.\&.\&.,
TN)\&.
.RE
.PP
Postconditions:
.RS 4
If
variant<U1, U2, \&.\&.\&., UN>
is itself one of the bounded types, then content of
*this
is a copy of
operand\&. Otherwise, content of
*this
is the best conversion of the content of
operand
to one of the bounded types, as determined by standard overload resolution rules\&.
.RE
.PP
Throws:
.RS 4
If
variant<U1, U2, \&.\&.\&., UN>
is itself one of the bounded types, then may fail with any exceptions arising from the copy constructor of
variant<U1, U2, \&.\&.\&., UN>\&. Otherwise, may fail with any exceptions arising from the conversion of the content of
operand
to one of the bounded types\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename U1, typename U2, \&.\&.\&., typename UN> 
  variant(const variant<U1, U2, \&.\&.\&., UN> & operand);
.fi

.PP
Notes:
.RS 4
Same semantics as previous constructor, but allows construction from temporaries\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename U1, typename U2, \&.\&.\&., typename UN> 
  variant(variant<U1, U2, \&.\&.\&., UN> && operand);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Notes:
.RS 4
Same semantics as previous constructor, but allows move construction\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
~variant();
.fi

.PP
Effects:
.RS 4
Destroys the content of
*this\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&..RE
.RE

.SS "variant modifiers"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void swap(variant & other);
.fi

.PP
Requires:
.RS 4
Every bounded type must fulfill the requirements of the MoveAssignable concept\&.
.RE
.PP
Effects:
.RS 4
Interchanges the content of
*this
and
other\&.
.RE
.PP
Throws:
.RS 4
If the contained type of
other
is the same as the contained type of
*this, then may fail with any exceptions arising from the
swap
of the contents of
*this
and
other\&. Otherwise, may fail with any exceptions arising from either of the move or copy constructors of the contained types\&. Also, in the event of insufficient memory, may fail with
std::bad_alloc
(why?)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
variant & operator=(const variant & rhs);
.fi

.PP
Requires:
.RS 4
Every bounded type must fulfill the requirements of the Assignable concept\&.
.RE
.PP
Effects:
.RS 4
If the contained type of
rhs
is the same as the contained type of
*this, then assigns the content of
rhs
into the content of
*this\&. Otherwise, makes the content of
*this
a copy of the content of
rhs, destroying the previous content of
*this\&.
.RE
.PP
Throws:
.RS 4
If the contained type of
rhs
is the same as the contained type of
*this, then may fail with any exceptions arising from the assignment of the content of
rhs
into the content
*this\&. Otherwise, may fail with any exceptions arising from the copy constructor of the contained type of
rhs\&. Also, in the event of insufficient memory, may fail with
std::bad_alloc
(why?)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
variant & operator=(variant && rhs);
.fi

.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C++11 compatible compiler\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Every bounded type must fulfill the requirements of the
              MoveAssignable
              concept\&..RE
.RE
.PP
Effects:
.RS 4
If the contained type of
rhs
is the same as the contained type of
*this, then move assigns the content of
rhs
into the content of
*this\&. Otherwise, move constructs
*this
using the content of
rhs, destroying the previous content of
*this\&.
.RE
.PP
Throws:
.RS 4
If the contained type of
rhs
is the same as the contained type of
*this, then may fail with any exceptions arising from the move assignment of the content of
rhs
into the content
*this\&. Otherwise, may fail with any exceptions arising from the move constructor of the contained type of
rhs\&. Also, in the event of insufficient memory, may fail with
std::bad_alloc
(why?)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename T> variant & operator=(const T & rhs);
.fi

.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must be unambiguously convertible to
                one of the bounded types (i\&.e\&., T1,
                T2, etc\&.)\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Every bounded type must fulfill the requirements of the
                Assignable
                concept\&..RE
.RE
.PP
Effects:
.RS 4
If the contained type of
*this
is
T, then assigns
rhs
into the content of
*this\&. Otherwise, makes the content of
*this
the best conversion of
rhs
to one of the bounded types, as determined by standard overload resolution rules, destroying the previous content of
*this\&.
.RE
.PP
Throws:
.RS 4
If the contained type of
*this
is
T, then may fail with any exceptions arising from the assignment of
rhs
into the content
*this\&. Otherwise, may fail with any exceptions arising from the conversion of
rhs
to one of the bounded types\&. Also, in the event of insufficient memory, may fail with
std::bad_alloc
(why?)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename T> variant & operator=(T && rhs);
.fi

.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
C++11 compatible compiler\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rhs is an rvalue\&. Otherwise previous operator will be used\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must be unambiguously convertible to
                one of the bounded types (i\&.e\&., T1,
                T2, etc\&.)\&..RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Every bounded type must fulfill the requirements of the
                MoveAssignable
                concept\&..RE
.RE
.PP
Effects:
.RS 4
If the contained type of
*this
is
T, then move assigns
rhs
into the content of
*this\&. Otherwise, makes the content of
*this
the best conversion of
rhs
to one of the bounded types, as determined by standard overload resolution rules, destroying the previous content of
*this(conversion is usually done via move construction)\&.
.RE
.PP
Throws:
.RS 4
If the contained type of
*this
is
T, then may fail with any exceptions arising from the move assignment of
rhs
into the content
*this\&. Otherwise, may fail with any exceptions arising from the conversion of
rhs
to one of the bounded types\&. Also, in the event of insufficient memory, may fail with
std::bad_alloc
(why?)\&.
.RE
.RE

.SS "variant queries"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
int which() const;
.fi

.PP
Returns:
.RS 4
The zero\-based index into the set of bounded types of the contained type of
*this\&. (For instance, if called on a
variant<int, std::string>
object containing a
std::string,
which()
would return
1\&.)
.RE
.PP
Throws:
.RS 4
Will not throw\&..RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.PP
Returns:
.RS 4
false:
variant
always contains exactly one of its bounded types\&. (See
the section called &#8220;"Never-Empty" Guarantee&#8221;
for more information\&.)
.RE
.PP
Rationale:
.RS 4
Facilitates generic compatibility with boost::any\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&..RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
const std::type_info & type() const;
.fi

.PP
Notes:
.RS 4
boost::variant
usues Boost\&.TypeIndex library so actually
const boost::typeindex::type_info &
is returned\&. This method is available even if RTTI is off\&.
.RE
.PP
Returns:
.RS 4
typeid(x), where
x
is the the content of
*this\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&..RE
.RE

.SS "variant relational"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool operator==(const variant & rhs) const;
template<typename U> void operator==(const U &) const;
.fi

Equality comparison\&..PP
Notes:
.RS 4
The overload returning
void
exists only to prohibit implicit conversion of the operator\'s right\-hand side to
variant; thus, its use will (purposefully) result in a compile\-time error\&.
.RE
.PP
Requires:
.RS 4
Every bounded type of the
variant
must fulfill the requirements of the EqualityComparable concept\&.
.RE
.PP
Returns:
.RS 4
true
if
which() == rhs\&.which()
\fIand\fR
content_this == content_rhs, where
content_this
is the content of
*this
and
content_rhs
is the content of
rhs\&.
.RE
.PP
Throws:
.RS 4
If
which() == rhs\&.which()
then may fail with any exceptions arising from
operator==(T,T), where
T
is the contained type of
*this\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool operator!=(const variant & rhs) const;
template<typename U> void operator!=(const U &) const;
.fi

InEquality comparison\&..PP
Notes:
.RS 4
The overload returning
void
exists only to prohibit implicit conversion of the operator\'s right\-hand side to
variant; thus, its use will (purposefully) result in a compile\-time error\&.
.RE
.PP
Requires:
.RS 4
Every bounded type of the
variant
must fulfill the requirements of the EqualityComparable concept\&.
.RE
.PP
Returns:
.RS 4
true
if
!(*this == rhs)\&.
.RE
.PP
Throws:
.RS 4
If
which() == rhs\&.which()
then may fail with any exceptions arising from
operator==(T,T), where
T
is the contained type of
*this\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool operator<(const variant & rhs) const;
template<typename U> void operator<(const U &) const;
.fi

LessThan comparison\&..PP
Notes:
.RS 4
The overload returning
void
exists only to prohibit implicit conversion of the operator\'s right\-hand side to
variant; thus, its use will (purposefully) result in a compile\-time error\&.
.RE
.PP
Requires:
.RS 4
Every bounded type of the
variant
must fulfill the requirements of the LessThanComparable concept\&.
.RE
.PP
Returns:
.RS 4
If
which() == rhs\&.which()
then:
content_this < content_rhs, where
content_this
is the content of
*this
and
content_rhs
is the content of
rhs\&. Otherwise:
which() < rhs\&.which()\&.
.RE
.PP
Throws:
.RS 4
If
which() == rhs\&.which()
then may fail with any exceptions arising from
operator<(T,T), where
T
is the contained type of
*this\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
bool operator>(const variant & rhs) const;
template<typename U> void operator>(const U &) const;
.fi

GreaterThan comparison\&..PP
Notes:
.RS 4
The overload returning
void
exists only to prohibit implicit conversion of the operator\'s right\-hand side to
variant; thus, its use will (purposefully) result in a compile\-time error\&.
.RE
.PP
Requires:
.RS 4
Every bounded type of the
variant
must fulfill the requirements of the LessThanComparable concept\&.
.RE
.PP
Returns:
.RS 4
true if
rhs < *this\&.
.RE
.PP
Throws:
.RS 4
May fail with any exceptions arising from
operator<(T,T), where
T
is the contained type of
*this\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool operator<=(const variant & rhs) const;
template<typename U> void operator<=(const U &) const;
.fi

LessThan or Equal comparison\&..PP
Notes:
.RS 4
The overload returning
void
exists only to prohibit implicit conversion of the operator\'s right\-hand side to
variant; thus, its use will (purposefully) result in a compile\-time error\&.
.RE
.PP
Requires:
.RS 4
Every bounded type of the
variant
must fulfill the requirements of the LessThanComparable concept\&.
.RE
.PP
Returns:
.RS 4
true if
!(*this > rhs)\&.
.RE
.PP
Throws:
.RS 4
May fail with any exceptions arising from
operator<(T,T), where
T
is the contained type of
*this\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
bool operator>=(const variant & rhs) const;
template<typename U> void operator>=(const U &) const;
.fi

GreaterThan or Equal comparison\&..PP
Notes:
.RS 4
The overload returning
void
exists only to prohibit implicit conversion of the operator\'s right\-hand side to
variant; thus, its use will (purposefully) result in a compile\-time error\&.
.RE
.PP
Requires:
.RS 4
Every bounded type of the
variant
must fulfill the requirements of the LessThanComparable concept\&.
.RE
.PP
Returns:
.RS 4
true if
!(*this < lhs)\&.
.RE
.PP
Throws:
.RS 4
May fail with any exceptions arising from
operator<(T,T), where
T
is the contained type of
*this\&.
.RE
.RE


