.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::icl::interval_base_set \- Implements a set as a set of intervals (base class)
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/icl/interval_base_set\&.hpp>

template<typename SubType, typename DomainT, 
         ICL_COMPARE Compare = ICL_COMPARE_INSTANCE(ICL_COMPARE_DEFAULT, DomainT), 
         ICL_INTERVAL(ICL_COMPARE) Interval = ICL_INTERVAL_INSTANCE(ICL_INTERVAL_DEFAULT, DomainT, Compare), 
         ICL_ALLOC Alloc = std::allocator> 
class interval_base_set {
public:
  // types
  typedef interval_base_set< SubType, DomainT, Compare, Interval, Alloc >   type;                          
  typedef SubType                                                           sub_type;                        // The designated \fIderived\fR or \fIsub_type\fR of this base class\&. 
  typedef type                                                              overloadable_type;               // Auxilliary type for overloadresolution\&. 
  typedef DomainT                                                           domain_type;                     // The domain type of the set\&. 
  typedef DomainT                                                           codomain_type;                   // The codomaintype is the same as domain_type\&. 
  typedef DomainT                                                           element_type;                    // The element type of the set\&. 
  typedef interval_type                                                     segment_type;                    // The segment type of the set\&. 
  typedef difference_type_of< domain_type >::type                           difference_type;                 // The difference type of an interval which is sometimes different form the data_type\&. 
  typedef size_type_of< domain_type >::type                                 size_type;                       // The size type of an interval which is mostly std::size_t\&. 
  typedef exclusive_less_than< interval_type >                              interval_compare;                // Comparison functor for intervals\&. 
  typedef exclusive_less_than< interval_type >                              key_compare;                     // Comparison functor for keys\&. 
  typedef ICL_IMPL_SPACE::set< DomainT, domain_compare, Alloc< DomainT > >  atomized_type;                   // The atomized type representing the corresponding container of elements\&. 
  typedef Alloc< interval_type >                                            allocator_type;                  // The allocator type of the set\&. 
  typedef Alloc< DomainT >                                                  domain_allocator_type;           // allocator type of the corresponding element set 
  typedef ICL_IMPL_SPACE::set< interval_type, key_compare, allocator_type > ImplSetT;                        // Container type for the implementation\&. 
  typedef ImplSetT::key_type                                                key_type;                        // key type of the implementing container 
  typedef ImplSetT::key_type                                                data_type;                       // data type of the implementing container 
  typedef ImplSetT::value_type                                              value_type;                      // value type of the implementing container 
  typedef ImplSetT::pointer                                                 pointer;                         // pointer type 
  typedef ImplSetT::const_pointer                                           const_pointer;                   // const pointer type 
  typedef ImplSetT::reference                                               reference;                       // reference type 
  typedef ImplSetT::const_reference                                         const_reference;                 // const reference type 
  typedef ImplSetT::iterator                                                iterator;                        // iterator for iteration over intervals 
  typedef ImplSetT::const_iterator                                          const_iterator;                  // const_iterator for iteration over intervals 
  typedef ImplSetT::reverse_iterator                                        reverse_iterator;                // iterator for reverse iteration over intervals 
  typedef ImplSetT::const_reverse_iterator                                  const_reverse_iterator;          // const_iterator for iteration over intervals 
  typedef boost::icl::element_iterator< iterator >                          element_iterator;                // element iterator: Depreciated, see documentation\&. 
  typedef boost::icl::element_iterator< const_iterator >                    element_const_iterator;          // element const iterator: Depreciated, see documentation\&. 
  typedef boost::icl::element_iterator< reverse_iterator >                  element_reverse_iterator;        // element reverse iterator: Depreciated, see documentation\&. 
  typedef boost::icl::element_iterator< const_reverse_iterator >            element_const_reverse_iterator;  // element const reverse iterator: Depreciated, see documentation\&. 

  // construct/copy/destruct
  interval_base_set();
  interval_base_set(const interval_base_set &);
  interval_base_set(interval_base_set &&);
  interval_base_set & operator=(interval_base_set);

  // public member functions
  typedef ICL_INTERVAL_TYPE(Interval, DomainT, Compare);
  typedef ICL_COMPARE_DOMAIN(Compare, DomainT);
  typedef ICL_COMPARE_DOMAIN(Compare, segment_type);
   BOOST_STATIC_CONSTANT(int, fineness = 0);
  void swap(interval_base_set &);
  void clear();
  bool empty() const;
  size_type size() const;
  std::size_t iterative_size() const;
  const_iterator find(const element_type &) const;
  const_iterator find(const interval_type &) const;
  SubType & add(const element_type &);
  SubType & add(const segment_type &);
  iterator add(iterator, const segment_type &);
  SubType & subtract(const element_type &);
  SubType & subtract(const segment_type &);
  SubType & insert(const element_type &);
  SubType & insert(const segment_type &);
  iterator insert(iterator, const segment_type &);
  SubType & erase(const element_type &);
  SubType & erase(const segment_type &);
  void erase(iterator);
  void erase(iterator, iterator);
  SubType & flip(const element_type &);
  SubType & flip(const segment_type &);
  iterator begin();
  iterator end();
  const_iterator begin() const;
  const_iterator end() const;
  reverse_iterator rbegin();
  reverse_iterator rend();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator rend() const;
  iterator lower_bound(const value_type &);
  iterator upper_bound(const value_type &);
  const_iterator lower_bound(const value_type &) const;
  const_iterator upper_bound(const value_type &) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;

  // private member functions
  iterator _add(const segment_type &);
  iterator _add(iterator, const segment_type &);

  // protected member functions
  void add_front(const interval_type &, iterator &);
  void add_main(interval_type &, iterator &, const iterator &);
  void add_segment(const interval_type &, iterator &);
  void add_rear(const interval_type &, iterator &);
  sub_type * that();
  const sub_type * that() const;
};
.fi
.SH "DESCRIPTION"
.SS "interval_base_set public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
interval_base_set();
.fi

.sp
Default constructor for the empty object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
interval_base_set(const interval_base_set & src);
.fi

.sp
Copy constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
interval_base_set(interval_base_set && src);
.fi

.sp
Move constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
interval_base_set & operator=(interval_base_set src);
.fi

.sp
Move assignment operator
.RE

.SS "interval_base_set public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typedef ICL_INTERVAL_TYPE(Interval, DomainT, Compare);
.fi

The interval type of the set\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typedef ICL_COMPARE_DOMAIN(Compare, DomainT);
.fi

Comparison functor for domain values\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typedef ICL_COMPARE_DOMAIN(Compare, segment_type);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
 BOOST_STATIC_CONSTANT(int, fineness = 0);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void swap(interval_base_set & operand);
.fi

.sp
swap the content of containers
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void clear();
.fi

.sp
sets the container empty
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
is the container empty?
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
size_type size() const;
.fi

.sp
An interval set\'s size is it\'s cardinality
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
std::size_t iterative_size() const;
.fi

.sp
Size of the iteration over this container
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
const_iterator find(const element_type & key_value) const;
.fi

.sp
Find the interval, that contains element
key_value
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
const_iterator find(const interval_type & key_interval) const;
.fi

.sp
Find the first interval, that collides with interval
key_interval
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
SubType & add(const element_type & key);
.fi

.sp
Add a single element
key
to the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
SubType & add(const segment_type & inter_val);
.fi

.sp
Add an interval of elements
inter_val
to the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
iterator add(iterator prior_, const segment_type & inter_val);
.fi

.sp
Add an interval of elements
inter_val
to the set\&. Iterator
prior_
is a hint to the position
inter_val
can be inserted after\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
SubType & subtract(const element_type & key);
.fi

.sp
Subtract a single element
key
from the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
SubType & subtract(const segment_type & inter_val);
.fi

.sp
Subtract an interval of elements
inter_val
from the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
SubType & insert(const element_type & key);
.fi

.sp
Insert an element
key
into the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
SubType & insert(const segment_type & inter_val);
.fi

.sp
Insert an interval of elements
inter_val
to the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
iterator insert(iterator prior_, const segment_type & inter_val);
.fi

.sp
Insert an interval of elements
inter_val
to the set\&. Iterator
prior_
is a hint to the position
inter_val
can be inserted after\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
SubType & erase(const element_type & key);
.fi

.sp
Erase an element
key
from the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
SubType & erase(const segment_type & inter_val);
.fi

.sp
Erase an interval of elements
inter_val
from the set
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
void erase(iterator position);
.fi

.sp
Erase the interval that iterator
position
points to\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
void erase(iterator first, iterator past);
.fi

.sp
Erase all intervals in the range
[first,past)
of iterators\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
SubType & flip(const element_type & key);
.fi

.sp
If
*this
set contains
key
it is erased, otherwise it is added\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
SubType & flip(const segment_type & inter_val);
.fi

.sp
If
*this
set contains
inter_val
it is erased, otherwise it is added\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
iterator begin();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}

.sp

.nf
iterator end();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}

.sp

.nf
const_iterator begin() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}

.sp

.nf
const_iterator end() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}

.sp

.nf
reverse_iterator rbegin();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}

.sp

.nf
reverse_iterator rend();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}

.sp

.nf
const_reverse_iterator rbegin() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}

.sp

.nf
const_reverse_iterator rend() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}

.sp

.nf
iterator lower_bound(const value_type & interval);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}

.sp

.nf
iterator upper_bound(const value_type & interval);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}

.sp

.nf
const_iterator lower_bound(const value_type & interval) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}

.sp

.nf
const_iterator upper_bound(const value_type & interval) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & interval);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & interval) const;
.fi

.RE

.SS "interval_base_set private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
iterator _add(const segment_type & addend);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
iterator _add(iterator prior, const segment_type & addend);
.fi

.RE

.SS "interval_base_set protected member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void add_front(const interval_type & inter_val, iterator & first_);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void add_main(interval_type & inter_val, iterator & it_, 
              const iterator & last_);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void add_segment(const interval_type & inter_val, iterator & it_);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void add_rear(const interval_type & inter_val, iterator & it_);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
sub_type * that();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const sub_type * that() const;
.fi

.RE


