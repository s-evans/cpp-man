.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE T" 3 "" "" ""
.SH "NAME"
boost::date_time::tz_db_base \- Creates a database of time_zones from csv datafile\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/tz_db_base\&.hpp>

template<typename time_zone_type, typename rule_type> 
class tz_db_base {
public:
  // types
  typedef char                                                           char_type;             
  typedef time_zone_type::base_type                                      time_zone_base_type;   
  typedef time_zone_type::time_duration_type                             time_duration_type;    
  typedef time_zone_names_base< char_type >                              time_zone_names;       
  typedef boost::date_time::dst_adjustment_offsets< time_duration_type > dst_adjustment_offsets;
  typedef std::basic_string< char_type >                                 string_type;           

  // construct/copy/destruct
  tz_db_base();

  // public member functions
  void load_from_stream(std::istream &);
  void load_from_file(const std::string &);
  bool add_record(const string_type &, 
                  boost::shared_ptr< time_zone_base_type >);
  boost::shared_ptr< time_zone_base_type > 
  time_zone_from_region(const string_type &) const;
  std::vector< std::string > region_list() const;

  // private member functions
  rule_type * parse_rules(const string_type &, const string_type &) const;
  week_num get_week_num(int) const;
  void split_rule_spec(int &, int &, int &, string_type) const;
  bool parse_string(string_type &);
};
.fi
.SH "DESCRIPTION"
.PP
The csv file containing the zone_specs used by the
tz_db_base
is intended to be customized by the library user\&. When customizing this file (or creating your own) the file must follow a specific format\&.
.PP
This first line is expected to contain column headings and is therefore not processed by the
tz_db_base\&.
.PP
Each record (line) must have eleven fields\&. Some of those fields can be empty\&. Every field (even empty ones) must be enclosed in double\-quotes\&. Ex:

.sp
.if n \{\
.RS 4
.\}
.nf
"America/Phoenix" <\- string enclosed in quotes
""                <\- empty field

.fi
.if n \{\
.RE
.\}

.PP
Some fields represent a length of time\&. The format of these fields must be:

.sp
.if n \{\
.RS 4
.\}
.nf
"{+|\-}hh:mm[:ss]" <\- length\-of\-time format

.fi
.if n \{\
.RE
.\}
.sp
Where the plus or minus is mandatory and the seconds are optional\&.
.PP
Since some time zones do not use daylight savings it is not always necessary for every field in a zone_spec to contain a value\&. All zone_specs must have at least ID and GMT offset\&. Zones that use daylight savings must have all fields filled except: STD ABBR, STD NAME, DST NAME\&. You should take note that DST ABBR is mandatory for zones that use daylight savings (see field descriptions for further details)\&.
.PP
******* Fields and their description/details *********
.PP
ID: Contains the identifying string for the zone_spec\&. Any string will do as long as it\'s unique\&. No two ID\'s can be the same\&.
.PP
STD ABBR: STD NAME: DST ABBR: DST NAME: These four are all the names and abbreviations used by the time zone being described\&. While any string will do in these fields, care should be taken\&. These fields hold the strings that will be used in the output of many of the local_time classes\&. Ex:

.sp
.if n \{\
.RS 4
.\}
.nf
time_zone nyc = tz_db\&.time_zone_from_region("America/New_York");
local_time ny_time(date(2004, Aug, 30), IS_DST, nyc);
cout << ny_time\&.to_long_string() << endl;
// 2004\-Aug\-30 00:00:00 Eastern Daylight Time
cout << ny_time\&.to_short_string() << endl;
// 2004\-Aug\-30 00:00:00 EDT

.fi
.if n \{\
.RE
.\}

.PP
NOTE: The exact format/function names may vary \- see local_time documentation for further details\&.
.PP
GMT offset: This is the number of hours added to utc to get the local time before any daylight savings adjustments are made\&. Some examples are: America/New_York offset \-5 hours, & Africa/Cairo offset +2 hours\&. The format must follow the length\-of\-time format described above\&.
.PP
DST adjustment: The amount of time added to gmt_offset when daylight savings is in effect\&. The format must follow the length\-of\-time format described above\&.
.PP
DST Start Date rule: This is a specially formatted string that describes the day of year in which the transition take place\&. It holds three fields of it\'s own, separated by semicolons\&. The first field indicates the "nth" weekday of the month\&. The possible values are: 1 (first), 2 (second), 3 (third), 4 (fourth), 5 (fifth), and \-1 (last)\&. The second field indicates the day\-of\-week from 0\-6 (Sun=0)\&. The third field indicates the month from 1\-12 (Jan=1)\&.
.PP
Examples are: "\-1;5;9"="Last Friday of September", "2;1;3"="Second Monday of March"
.PP
Start time: Start time is the number of hours past midnight, on the day of the start transition, the transition takes place\&. More simply put, the time of day the transition is made (in 24 hours format)\&. The format must follow the length\-of\-time format described above with the exception that it must always be positive\&.
.PP
DST End date rule: See DST Start date rule\&. The difference here is this is the day daylight savings ends (transition to STD)\&.
.PP
End time: Same as Start time\&.
.SS "tz_db_base public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
tz_db_base();
.fi

Constructs an empty database\&. .RE

.SS "tz_db_base public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void load_from_stream(std::istream & in);
.fi

.sp
Process csv data file, may throw exceptions\&. May throw
bad_field_count
exceptions
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void load_from_file(const std::string & pathspec);
.fi

.sp
Process csv data file, may throw exceptions\&. May throw
data_not_accessible, or
bad_field_count
exceptions
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool add_record(const string_type & region, 
                boost::shared_ptr< time_zone_base_type > tz);
.fi

.sp
returns true if record successfully added to map Takes a region name in the form of "America/Phoenix", and a time_zone object for that region\&. The id string must be a unique name that does not already exist in the database\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
boost::shared_ptr< time_zone_base_type > 
time_zone_from_region(const string_type & region) const;
.fi

.sp
Returns a time_zone object built from the specs for the given region\&. Returns a time_zone object built from the specs for the given region\&. If region does not exist a local_time::record_not_found exception will be thrown
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
std::vector< std::string > region_list() const;
.fi

Returns a vector of strings holding the time zone regions in the database\&. .RE

.SS "tz_db_base private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
rule_type * parse_rules(const string_type & sr, const string_type & er) const;
.fi

parses rule specs for transition day rules .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
week_num get_week_num(int nth) const;
.fi

helper function for parse_rules() .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void split_rule_spec(int & nth, int & d, int & m, string_type rule) const;
.fi

splits the [start|end]_date_rule string into 3 ints .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
bool parse_string(string_type & s);
.fi

.sp
Take a line from the csv, turn it into a time_zone_type\&. Take a line from the csv, turn it into a time_zone_type, and add it to the map\&. Zone_specs in csv file are expected to have eleven fields that describe the time zone\&. Returns true if zone_spec successfully added to database
.RE


