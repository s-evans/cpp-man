.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::container::small_vector
.SH "SYNOPSIS"
.\" swap: Class template small_vector
.\" Class template small_vector: swap
.\" small_vector_base: Class template small_vector
.\" Class template small_vector: small_vector_base
.\" small_vector: Class template small_vector
.\" Class template small_vector: small_vector

.sp
.nf
// In header: <boost/container/small_vector\&.hpp>

template<typename T, std::size_t N, typename Allocator = new_allocator<T> > 
class small_vector :
  public boost::container::small_vector_base< T, Allocator >
{
public:
  // construct/copy/destruct
  small_vector();
  explicit small_vector(size_type);
  explicit small_vector(const allocator_type &);
  small_vector(size_type, const allocator_type &);
  small_vector(const small_vector &);
  small_vector(const small_vector &, const allocator_type &);
  small_vector(small_vector &&);
  small_vector(small_vector &&, const allocator_type &);
  small_vector(std::initializer_list< value_type >, 
               const allocator_type & = allocator_type());
  small_vector & operator=(const small_vector &);
  small_vector & operator=(small_vector &&);

  // public member functions
  void swap(small_vector &);
};
.fi
.SH "DESCRIPTION"
.PP
small_vector
is a vector\-like container optimized for the case when it contains few elements\&. It contains some preallocated elements in\-place, which can avoid the use of dynamic storage allocation when the actual number of elements is below that preallocated threshold\&.
.PP
small_vector<T, N, Allocator>
is convertible to
small_vector_base<T, Allocator>
that is independent from the preallocated element capacity, so client code does not need to be templated on that N argument\&.
.PP
All
boost::container::vector
member functions are inherited\&. See
vector
documentation for details\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of object that is stored in the small_vector
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
std::size_t N
.fi

.sp
The number of preallocated elements stored inside small_vector\&. It shall be less than Allocator::max_size();
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<T>
.fi

.sp
The allocator used for memory management when the number of elements exceeds N\&.
.RE

.SS "small_vector public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
small_vector();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit small_vector(size_type n);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit small_vector(const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
small_vector(size_type n, const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
small_vector(const small_vector & other);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
small_vector(const small_vector & other, const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
small_vector(small_vector && other);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
small_vector(small_vector && other, const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
small_vector(std::initializer_list< value_type > il, 
             const allocator_type & a = allocator_type());
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
small_vector & operator=(const small_vector & other);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
small_vector & operator=(small_vector && other);
.fi

.RE

.SS "small_vector public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" swap: Class template small_vector
.\" Class template small_vector: swap

.sp

.nf
void swap(small_vector & other);
.fi

.RE


