.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::container::static_vector \- A variable\-size array container with fixed capacity\&.
.SH "SYNOPSIS"
.\" value_type: Class template static_vector
.\" Class template static_vector: value_type
.\" swap: Class template static_vector
.\" Class template static_vector: swap
.\" static_vector: Class template static_vector
.\" Class template static_vector: static_vector
.\" size_type: Class template static_vector
.\" Class template static_vector: size_type
.\" reverse_iterator: Class template static_vector
.\" Class template static_vector: reverse_iterator
.\" resize: Class template static_vector
.\" Class template static_vector: resize
.\" reserve: Class template static_vector
.\" Class template static_vector: reserve
.\" rend: Class template static_vector
.\" Class template static_vector: rend
.\" reference: Class template static_vector
.\" Class template static_vector: reference
.\" rbegin: Class template static_vector
.\" Class template static_vector: rbegin
.\" push_back: Class template static_vector
.\" Class template static_vector: push_back
.\" pop_back: Class template static_vector
.\" Class template static_vector: pop_back
.\" pointer: Class template static_vector
.\" Class template static_vector: pointer
.\" nth: Class template static_vector
.\" Class template static_vector: nth
.\" iterator: Class template static_vector
.\" Class template static_vector: iterator
.\" insert: Class template static_vector
.\" Class template static_vector: insert
.\" index_of: Class template static_vector
.\" Class template static_vector: index_of
.\" front: Class template static_vector
.\" Class template static_vector: front
.\" erase: Class template static_vector
.\" Class template static_vector: erase
.\" end: Class template static_vector
.\" Class template static_vector: end
.\" emplace_back: Class template static_vector
.\" Class template static_vector: emplace_back
.\" emplace: Class template static_vector
.\" Class template static_vector: emplace
.\" difference_type: Class template static_vector
.\" Class template static_vector: difference_type
.\" const_reverse_iterator: Class template static_vector
.\" Class template static_vector: const_reverse_iterator
.\" const_reference: Class template static_vector
.\" Class template static_vector: const_reference
.\" const_pointer: Class template static_vector
.\" Class template static_vector: const_pointer
.\" const_iterator: Class template static_vector
.\" Class template static_vector: const_iterator
.\" clear: Class template static_vector
.\" Class template static_vector: clear
.\" begin: Class template static_vector
.\" Class template static_vector: begin
.\" back: Class template static_vector
.\" Class template static_vector: back
.\" at: Class template static_vector
.\" Class template static_vector: at
.\" assign: Class template static_vector
.\" Class template static_vector: assign

.sp
.nf
// In header: <boost/container/static_vector\&.hpp>

template<typename Value, std::size_t Capacity> 
class static_vector {
public:
  // types
  typedef base_t::value_type             value_type;              // The type of elements stored in the container\&. 
  typedef base_t::size_type              size_type;               // The unsigned integral type used by the container\&. 
  typedef base_t::difference_type        difference_type;         // The pointers difference type\&. 
  typedef base_t::pointer                pointer;                 // The pointer type\&. 
  typedef base_t::const_pointer          const_pointer;           // The const pointer type\&. 
  typedef base_t::reference              reference;               // The value reference type\&. 
  typedef base_t::const_reference        const_reference;         // The value const reference type\&. 
  typedef base_t::iterator               iterator;                // The iterator type\&. 
  typedef base_t::const_iterator         const_iterator;          // The const iterator type\&. 
  typedef base_t::reverse_iterator       reverse_iterator;        // The reverse iterator type\&. 
  typedef base_t::const_reverse_iterator const_reverse_iterator;  // The const reverse iterator\&. 

  // construct/copy/destruct
  static_vector() noexcept;
  explicit static_vector(size_type);
  static_vector(size_type, default_init_t);
  static_vector(size_type, value_type const &);
  template<typename Iterator> static_vector(Iterator, Iterator);
  static_vector(std::initializer_list< value_type >);
  static_vector(static_vector const &);
  template<std::size_t C> 
    static_vector(static_vector< value_type, C > const &);
  static_vector(static_vector &&);
  template<std::size_t C> static_vector(static_vector< value_type, C > &&);
  static_vector & operator=(const static_vector &);
  static_vector & operator=(std::initializer_list< value_type >);
  template<std::size_t C> 
    static_vector & operator=(static_vector< value_type, C > const &);
  static_vector & operator=(static_vector &&);
  template<std::size_t C> 
    static_vector & operator=(static_vector< value_type, C > &&);
  ~static_vector();

  // public member functions
  void swap(static_vector &);
  template<std::size_t C> void swap(static_vector< value_type, C > &);
  void resize(size_type);
  void resize(size_type, default_init_t);
  void resize(size_type, value_type const &);
  void reserve(size_type) noexcept;
  void push_back(value_type const &);
  void push_back(value_type &&);
  void pop_back();
  iterator insert(const_iterator, value_type const &);
  iterator insert(const_iterator, value_type &&);
  iterator insert(const_iterator, size_type, value_type const &);
  template<typename Iterator> 
    iterator insert(const_iterator, Iterator, Iterator);
  iterator insert(const_iterator, std::initializer_list< value_type >);
  iterator erase(const_iterator);
  iterator erase(const_iterator, const_iterator);
  template<typename Iterator> void assign(Iterator, Iterator);
  void assign(std::initializer_list< value_type >);
  void assign(size_type, value_type const &);
  template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace(const_iterator, Args &&\&.\&.\&.);
  void clear() noexcept;
  reference at(size_type);
  const_reference at(size_type) const;
  reference operator[](size_type);
  const_reference operator[](size_type) const;
  iterator nth(size_type);
  const_iterator nth(size_type) const;
  size_type index_of(iterator);
  size_type index_of(const_iterator) const;
  reference front();
  const_reference front() const;
  reference back();
  const_reference back() const;
  Value * data() noexcept;
  const Value * data() const noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  const_iterator cbegin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  const_iterator cend() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_reverse_iterator crend() const noexcept;
  size_type size() const noexcept;
  bool empty() const noexcept;

  // public static functions
  static size_type capacity() noexcept;
  static size_type max_size() noexcept;
};
.fi
.SH "DESCRIPTION"
.\" throw_bad_alloc: Class template static_vector
.\" Class template static_vector: throw_bad_alloc
.\" at: Class template static_vector
.\" Class template static_vector: at
.PP
static_vector
is a sequence container like
boost::container::vector
with contiguous storage that can change in size, along with the static allocation, low overhead, and fixed capacity of boost::array\&.
.PP
A
static_vector
is a sequence that supports random access to elements, constant time insertion and removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle\&. The number of elements in a
static_vector
may vary dynamically up to a fixed capacity because elements are stored within the object itself similarly to an array\&. However, objects are initialized as they are inserted into
static_vector
unlike C arrays or std::array which must construct all elements on instantiation\&. The behavior of
static_vector
enables the use of statically allocated elements in cases with complex object lifetime requirements that would otherwise not be trivially possible\&.
.PP
.PP \fBError Handling\fR. Insertion beyond the capacity result in throwing std::bad_alloc() if exceptions are enabled or calling throw_bad_alloc() if not enabled\&.
std::out_of_range is thrown if out of bound access is performed in
at()
if exceptions are enabled, throw_out_of_range() if not enabled\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Value
.fi

.sp
The type of element that will be stored\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
std::size_t Capacity
.fi

.sp
The maximum number of elements static_vector can store, fixed at compile time\&.
.RE

.SS "static_vector public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static_vector() noexcept;
.fi

Constructs an empty static_vector\&. .PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit static_vector(size_type count);
.fi

Constructs a static_vector containing count value initialized values\&. 
.PP \fBThrows\fR. If Value\'s value initialization throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of values which will be contained in the container\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
static_vector(size_type count, default_init_t);
.fi

Constructs a static_vector containing count default initialized values\&. 
.PP \fBThrows\fR. If Value\'s default initialization throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP \fBNote\fR. Non\-standard extension
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of values which will be contained in the container\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
static_vector(size_type count, value_type const & value);
.fi

Constructs a static_vector containing count copies of value\&. 
.PP \fBThrows\fR. If Value\'s copy constructor throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of copies of a values that will be contained in the container\&.
.RE
.PP
value
.RS 4
The value which will be used to copy construct values\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename Iterator> static_vector(Iterator first, Iterator last);
.fi

Constructs a static_vector containing copy of a range [first, last)\&. 
.PP \fBThrows\fR. If Value\'s constructor taking a dereferenced Iterator throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The iterator to the first element in range\&.
.RE
.PP
last
.RS 4
The iterator to the one after the last element in range\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
distance(first, last) <= capacity()
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Iterator must meet the
ForwardTraversalIterator
concept\&.
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
static_vector(std::initializer_list< value_type > il);
.fi

Constructs a static_vector containing copy of a range [il\&.begin(), il\&.end())\&. 
.PP \fBThrows\fR. If Value\'s constructor taking a dereferenced std::initializer_list throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
il
.RS 4
std::initializer_list with values to initialize vector\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
distance(il\&.begin(), il\&.end()) <= capacity()
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
static_vector(static_vector const & other);
.fi

Constructs a copy of other static_vector\&. 
.PP \fBThrows\fR. If Value\'s copy constructor throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be copied to this one\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<std::size_t C> 
  static_vector(static_vector< value_type, C > const & other);
.fi

Constructs a copy of other static_vector\&. 
.PP \fBThrows\fR. If Value\'s copy constructor throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be copied to this one\&.
.RE
.RE
.PP
Requires:
.RS 4
other\&.size() <= capacity()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
static_vector(static_vector && other);
.fi

Move constructor\&. Moves Values stored in the other static_vector to this one\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is true and Value\'s move constructor throws\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is false and Value\'s copy constructor throws\&. .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be moved to this one\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<std::size_t C> static_vector(static_vector< value_type, C > && other);
.fi

Move constructor\&. Moves Values stored in the other static_vector to this one\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is true and Value\'s move constructor throws\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is false and Value\'s copy constructor throws\&. .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be moved to this one\&.
.RE
.RE
.PP
Requires:
.RS 4
other\&.size() <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
static_vector & operator=(const static_vector & other);
.fi

Copy assigns Values stored in the other static_vector to this one\&. 
.PP \fBThrows\fR. If Value\'s copy constructor or copy assignment throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be copied to this one\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
static_vector & operator=(std::initializer_list< value_type > il);
.fi

.sp
Copy assigns Values stored in std::initializer_list to *this\&. 
.PP \fBThrows\fR. If Value\'s copy constructor or copy assignment throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
il
.RS 4
The std::initializer_list which content will be copied to this one\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
template<std::size_t C> 
  static_vector & operator=(static_vector< value_type, C > const & other);
.fi

Copy assigns Values stored in the other static_vector to this one\&. 
.PP \fBThrows\fR. If Value\'s copy constructor or copy assignment throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be copied to this one\&.
.RE
.RE
.PP
Requires:
.RS 4
other\&.size() <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
static_vector & operator=(static_vector && other);
.fi

Move assignment\&. Moves Values stored in the other static_vector to this one\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is true and Value\'s move constructor or move assignment throws\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is false and Value\'s copy constructor or copy assignment throws\&. .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be moved to this one\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
template<std::size_t C> 
  static_vector & operator=(static_vector< value_type, C > && other);
.fi

Move assignment\&. Moves Values stored in the other static_vector to this one\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is true and Value\'s move constructor or move assignment throws\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is false and Value\'s copy constructor or copy assignment throws\&. .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be moved to this one\&.
.RE
.RE
.PP
Requires:
.RS 4
other\&.size() <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
~static_vector();
.fi

.sp
Destructor\&. Destroys Values stored in this container\&. .PP \fBThrows\fR. Nothing
.PP \fBComplexity\fR. Linear O(N)\&.
.RE

.SS "static_vector public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" swap: Class template static_vector
.\" Class template static_vector: swap

.sp

.nf
void swap(static_vector & other);
.fi

Swaps contents of the other static_vector and this one\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is true and Value\'s move constructor or move assignment throws, .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is false and Value\'s copy constructor or copy assignment throws, .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be swapped with this one\'s content\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" swap: Class template static_vector
.\" Class template static_vector: swap

.sp

.nf
template<std::size_t C> void swap(static_vector< value_type, C > & other);
.fi

Swaps contents of the other static_vector and this one\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is true and Value\'s move constructor or move assignment throws, .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If has_nothrow_move<Value>::value is false and Value\'s copy constructor or copy assignment throws, .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
other
.RS 4
The
static_vector
which content will be swapped with this one\'s content\&.
.RE
.RE
.PP
Requires:
.RS 4
other\&.size() <= capacity() && size() <= other\&.capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" resize: Class template static_vector
.\" Class template static_vector: resize

.sp

.nf
void resize(size_type count);
.fi

.sp
Inserts or erases elements at the end such that the size becomes count\&. New elements are value initialized\&. 
.PP \fBThrows\fR. If Value\'s value initialization throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of elements which will be stored in the container\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" resize: Class template static_vector
.\" Class template static_vector: resize

.sp

.nf
void resize(size_type count, default_init_t);
.fi

.sp
Inserts or erases elements at the end such that the size becomes count\&. New elements are default initialized\&. 
.PP \fBThrows\fR. If Value\'s default initialization throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP \fBNote\fR. Non\-standard extension
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of elements which will be stored in the container\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" resize: Class template static_vector
.\" Class template static_vector: resize

.sp

.nf
void resize(size_type count, value_type const & value);
.fi

.sp
Inserts or erases elements at the end such that the size becomes count\&. New elements are copy constructed from value\&. 
.PP \fBThrows\fR. If Value\'s copy constructor throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of elements which will be stored in the container\&.
.RE
.PP
value
.RS 4
The value used to copy construct the new element\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" reserve: Class template static_vector
.\" Class template static_vector: reserve

.sp

.nf
void reserve(size_type count) noexcept;
.fi

.sp
This call has no effect because the Capacity of this container is constant\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of elements which the container should be able to contain\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" push_back: Class template static_vector
.\" Class template static_vector: push_back

.sp

.nf
void push_back(value_type const & value);
.fi

.sp
Adds a copy of value at the end\&. 
.PP \fBThrows\fR. If Value\'s copy constructor throws\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
value
.RS 4
The value used to copy construct the new element\&.
.RE
.RE
.PP
Requires:
.RS 4
size() < capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" push_back: Class template static_vector
.\" Class template static_vector: push_back

.sp

.nf
void push_back(value_type && value);
.fi

.sp
Moves value to the end\&. 
.PP \fBThrows\fR. If Value\'s move constructor throws\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
value
.RS 4
The value to move construct the new element\&.
.RE
.RE
.PP
Requires:
.RS 4
size() < capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" pop_back: Class template static_vector
.\" Class template static_vector: pop_back

.sp

.nf
void pop_back();
.fi

.sp
Destroys last value and decreases the size\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Requires:
.RS 4
!empty()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" insert: Class template static_vector
.\" Class template static_vector: insert

.sp

.nf
iterator insert(const_iterator p, value_type const & value);
.fi

.sp
Inserts a copy of element at p\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If Value\'s copy constructor or copy assignment throws .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If Value\'s move constructor or move assignment throws\&. .RE .RS 4
.PP \fBComplexity\fR. Constant or linear\&.
.PP
Parameters:
.RS 4
.PP
p
.RS 4
The position at which the new value will be inserted\&.
.RE
.PP
value
.RS 4
The value used to copy construct the new element\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
p
must be a valid iterator of
*this
in range
[begin(), end()]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
size() < capacity()
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" insert: Class template static_vector
.\" Class template static_vector: insert

.sp

.nf
iterator insert(const_iterator p, value_type && value);
.fi

.sp
Inserts a move\-constructed element at p\&. 
.PP \fBThrows\fR. If Value\'s move constructor or move assignment throws\&.
.PP \fBComplexity\fR. Constant or linear\&.
.PP
Parameters:
.RS 4
.PP
p
.RS 4
The position at which the new value will be inserted\&.
.RE
.PP
value
.RS 4
The value used to move construct the new element\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
p
must be a valid iterator of
*this
in range
[begin(), end()]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
size() < capacity()
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" insert: Class template static_vector
.\" Class template static_vector: insert

.sp

.nf
iterator insert(const_iterator p, size_type count, value_type const & value);
.fi

.sp
Inserts a count copies of value at p\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If Value\'s copy constructor or copy assignment throws\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If Value\'s move constructor or move assignment throws\&. .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The number of new elements which will be inserted\&.
.RE
.PP
p
.RS 4
The position at which new elements will be inserted\&.
.RE
.PP
value
.RS 4
The value used to copy construct new elements\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
p
must be a valid iterator of
*this
in range
[begin(), end()]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
size() + count <= capacity()
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" insert: Class template static_vector
.\" Class template static_vector: insert

.sp

.nf
template<typename Iterator> 
  iterator insert(const_iterator p, Iterator first, Iterator last);
.fi

Inserts a copy of a range [first, last) at p\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If Value\'s constructor and assignment taking a dereferenced Iterator\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If Value\'s move constructor or move assignment throws\&. .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The iterator to the first element of a range used to construct new elements\&.
.RE
.PP
last
.RS 4
The iterator to the one after the last element of a range used to construct new elements\&.
.RE
.PP
p
.RS 4
The position at which new elements will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
p
must be a valid iterator of
*this
in range
[begin(), end()]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
distance(first, last) <= capacity()
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Iterator
must meet the
ForwardTraversalIterator
concept\&.
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" insert: Class template static_vector
.\" Class template static_vector: insert

.sp

.nf
iterator insert(const_iterator p, std::initializer_list< value_type > il);
.fi

Inserts a copy of a range [il\&.begin(), il\&.end()) at p\&. 
.PP \fBThrows\fR. .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If Value\'s constructor and assignment taking a dereferenced std::initializer_list iterator\&. .RE .RS 4
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
il
.RS 4
The std::initializer_list which contains elements that will be inserted\&.
.RE
.PP
p
.RS 4
The position at which new elements will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
p
must be a valid iterator of
*this
in range
[begin(), end()]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
distance(il\&.begin(), il\&.end()) <= capacity()
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" erase: Class template static_vector
.\" Class template static_vector: erase

.sp

.nf
iterator erase(const_iterator p);
.fi

.sp
Erases Value from p\&. 
.PP \fBThrows\fR. If Value\'s move assignment throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
p
.RS 4
The position of the element which will be erased from the container\&.
.RE
.RE
.PP
Requires:
.RS 4
p
must be a valid iterator of
*this
in range
[begin(), end())
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" erase: Class template static_vector
.\" Class template static_vector: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

Erases Values from a range [first, last)\&. 
.PP \fBThrows\fR. If Value\'s move assignment throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The position of the first element of a range which will be erased from the container\&.
.RE
.PP
last
.RS 4
The position of the one after the last element of a range which will be erased from the container\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
first
and
last
must define a valid range
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
iterators must be in range
[begin(), end()]
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" assign: Class template static_vector
.\" Class template static_vector: assign

.sp

.nf
template<typename Iterator> void assign(Iterator first, Iterator last);
.fi

Assigns a range [first, last) of Values to this container\&. 
.PP \fBThrows\fR. If Value\'s copy constructor or copy assignment throws,
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The iterator to the first element of a range used to construct new content of this container\&.
.RE
.PP
last
.RS 4
The iterator to the one after the last element of a range used to construct new content of this container\&.
.RE
.RE
.PP
Requires:
.RS 4
distance(first, last) <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" assign: Class template static_vector
.\" Class template static_vector: assign

.sp

.nf
void assign(std::initializer_list< value_type > il);
.fi

Assigns a range [il\&.begin(), il\&.end()) of Values to this container\&. 
.PP \fBThrows\fR. If Value\'s copy constructor or copy assignment throws,
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Requires:
.RS 4
distance(il\&.begin(), il\&.end()) <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" assign: Class template static_vector
.\" Class template static_vector: assign

.sp

.nf
void assign(size_type count, value_type const & value);
.fi

.sp
Assigns a count copies of value to this container\&. 
.PP \fBThrows\fR. If Value\'s copy constructor or copy assignment throws\&.
.PP \fBComplexity\fR. Linear O(N)\&.
.PP
Parameters:
.RS 4
.PP
count
.RS 4
The new number of elements which will be container in the container\&.
.RE
.PP
value
.RS 4
The value which will be used to copy construct the new content\&.
.RE
.RE
.PP
Requires:
.RS 4
count <= capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" emplace_back: Class template static_vector
.\" Class template static_vector: emplace_back

.sp

.nf
template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&. args);
.fi

Inserts a Value constructed with std::forward<Args>(args)\&.\&.\&. in the end of the container\&. 
.PP \fBThrows\fR. If in\-place constructor throws or Value\'s move constructor throws\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
args
.RS 4
The arguments of the constructor of the new element which will be created at the end of the container\&.
.RE
.RE
.PP
Requires:
.RS 4
size() < capacity()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" emplace: Class template static_vector
.\" Class template static_vector: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(const_iterator p, Args &&\&.\&.\&. args);
.fi

Inserts a Value constructed with std::forward<Args>(args)\&.\&.\&. before p\&. 
.PP \fBThrows\fR. If in\-place constructor throws or if Value\'s move constructor or move assignment throws\&.
.PP \fBComplexity\fR. Constant or linear\&.
.PP
Parameters:
.RS 4
.PP
args
.RS 4
The arguments of the constructor of the new element\&.
.RE
.PP
p
.RS 4
The position at which new elements will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
p
must be a valid iterator of
*this
in range
[begin(), end()]
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
size() < capacity()
.RE
.RS 4

.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" clear: Class template static_vector
.\" Class template static_vector: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
Removes all elements from the container\&. .PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" at: Class template static_vector
.\" Class template static_vector: at

.sp

.nf
reference at(size_type i);
.fi

.sp
Returns reference to the i\-th element\&. 
.PP \fBThrows\fR. std::out_of_range exception by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
i
.RS 4
The element\'s index\&.
.RE
.RE
.PP
Requires:
.RS 4
i < size()
.RE
.PP
Returns:
.RS 4
reference to the i\-th element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" at: Class template static_vector
.\" Class template static_vector: at

.sp

.nf
const_reference at(size_type i) const;
.fi

.sp
Returns const reference to the i\-th element\&. 
.PP \fBThrows\fR. std::out_of_range exception by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
i
.RS 4
The element\'s index\&.
.RE
.RE
.PP
Requires:
.RS 4
i < size()
.RE
.PP
Returns:
.RS 4
const reference to the i\-th element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
reference operator[](size_type i);
.fi

.sp
Returns reference to the i\-th element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
i
.RS 4
The element\'s index\&.
.RE
.RE
.PP
Requires:
.RS 4
i < size()
.RE
.PP
Returns:
.RS 4
reference to the i\-th element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
const_reference operator[](size_type i) const;
.fi

.sp
Returns const reference to the i\-th element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
i
.RS 4
The element\'s index\&.
.RE
.RE
.PP
Requires:
.RS 4
i < size()
.RE
.PP
Returns:
.RS 4
const reference to the i\-th element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" nth: Class template static_vector
.\" Class template static_vector: nth

.sp

.nf
iterator nth(size_type i);
.fi

.sp
Returns a iterator to the i\-th element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
i
.RS 4
The element\'s index\&.
.RE
.RE
.PP
Requires:
.RS 4
i =< size()
.RE
.PP
Returns:
.RS 4
a iterator to the i\-th element\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" nth: Class template static_vector
.\" Class template static_vector: nth

.sp

.nf
const_iterator nth(size_type i) const;
.fi

.sp
Returns a const_iterator to the i\-th element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Parameters:
.RS 4
.PP
i
.RS 4
The element\'s index\&.
.RE
.RE
.PP
Requires:
.RS 4
i =< size()
.RE
.PP
Returns:
.RS 4
a const_iterator to the i\-th element\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" index_of: Class template static_vector
.\" Class template static_vector: index_of

.sp

.nf
size_type index_of(iterator p);
.fi

.sp
Returns the index of the element pointed by p\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Requires:
.RS 4
begin() <= p <= end()
.RE
.PP
Returns:
.RS 4
The index of the element pointed by p\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" index_of: Class template static_vector
.\" Class template static_vector: index_of

.sp

.nf
size_type index_of(const_iterator p) const;
.fi

.sp
Returns the index of the element pointed by p\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Requires:
.RS 4
begin() <= p <= end()
.RE
.PP
Returns:
.RS 4
a const_iterator to the i\-th element\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" front: Class template static_vector
.\" Class template static_vector: front

.sp

.nf
reference front();
.fi

.sp
Returns reference to the first element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
reference to the first element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" front: Class template static_vector
.\" Class template static_vector: front

.sp

.nf
const_reference front() const;
.fi

.sp
Returns const reference to the first element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
const reference to the first element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" back: Class template static_vector
.\" Class template static_vector: back

.sp

.nf
reference back();
.fi

.sp
Returns reference to the last element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
reference to the last element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" back: Class template static_vector
.\" Class template static_vector: back

.sp

.nf
const_reference back() const;
.fi

.sp
Returns const reference to the first element\&. 
.PP \fBThrows\fR. Nothing by default\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Returns:
.RS 4
const reference to the last element from the beginning of the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}

.sp

.nf
Value * data() noexcept;
.fi

Pointer such that [data(), data() + size()) is a valid range\&. For a non\-empty vector data() == &front()\&. .PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}

.sp

.nf
const Value * data() const noexcept;
.fi

Const pointer such that [data(), data() + size()) is a valid range\&. For a non\-empty vector data() == &front()\&. .PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" begin: Class template static_vector
.\" Class template static_vector: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
Returns iterator to the first element\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
iterator to the first element contained in the vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" begin: Class template static_vector
.\" Class template static_vector: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
Returns const iterator to the first element\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_iterator to the first element contained in the vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
Returns const iterator to the first element\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_iterator to the first element contained in the vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" end: Class template static_vector
.\" Class template static_vector: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
Returns iterator to the one after the last element\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
iterator pointing to the one after the last element contained in the vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" end: Class template static_vector
.\" Class template static_vector: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
Returns const iterator to the one after the last element\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_iterator pointing to the one after the last element contained in the vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
Returns const iterator to the one after the last element\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_iterator pointing to the one after the last element contained in the vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" rbegin: Class template static_vector
.\" Class template static_vector: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
Returns reverse iterator to the first element of the reversed container\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
reverse_iterator pointing to the beginning of the reversed
static_vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" rbegin: Class template static_vector
.\" Class template static_vector: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
Returns const reverse iterator to the first element of the reversed container\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_reverse_iterator pointing to the beginning of the reversed
static_vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
Returns const reverse iterator to the first element of the reversed container\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_reverse_iterator pointing to the beginning of the reversed
static_vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" rend: Class template static_vector
.\" Class template static_vector: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
Returns reverse iterator to the one after the last element of the reversed container\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
reverse_iterator pointing to the one after the last element of the reversed
static_vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" rend: Class template static_vector
.\" Class template static_vector: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
Returns const reverse iterator to the one after the last element of the reversed container\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_reverse_iterator pointing to the one after the last element of the reversed
static_vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
Returns const reverse iterator to the one after the last element of the reversed container\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
const_reverse_iterator pointing to the one after the last element of the reversed
static_vector\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
Returns the number of stored elements\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
Number of elements contained in the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
Queries if the container contains elements\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
true if the number of elements contained in the container is equal to 0\&.
.RE
.RE

.SS "static_vector public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static size_type capacity() noexcept;
.fi

.sp
Returns container\'s capacity\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
container\'s capacity\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static size_type max_size() noexcept;
.fi

.sp
Returns container\'s capacity\&. 
.PP \fBThrows\fR. Nothing\&.
.PP \fBComplexity\fR. Constant O(1)\&.
.PP
Returns:
.RS 4
container\'s capacity\&.
.RE
.RE


