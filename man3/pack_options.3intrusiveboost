.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLAT" 3 "" "" ""
.SH "NAME"
boost::intrusive::pack_options
.SH "SYNOPSIS"
.\" type: Struct template pack_options
.\" Struct template pack_options: type
.\" pack_options: Struct template pack_options
.\" Struct template pack_options: pack_options

.sp
.nf
// In header: <boost/intrusive/pack_options\&.hpp>

template<typename DefaultOptions, class\&.\&.\&. Options> 
struct pack_options {
  // types
  typedef unspecified_type type;
};
.fi
.SH "DESCRIPTION"
.\" my_pointer_type: Struct template pack_options
.\" Struct template pack_options: my_pointer_type
.\" int_type: Struct template pack_options
.\" Struct template pack_options: int_type
.\" int_type: Struct template pack_options
.\" Struct template pack_options: int_type
.\" BOOST_INTRUSIVE_OPTION_TYPE: Struct template pack_options
.\" Struct template pack_options: BOOST_INTRUSIVE_OPTION_TYPE
.\" BOOST_INTRUSIVE_OPTION_CONSTANT: Struct template pack_options
.\" Struct template pack_options: BOOST_INTRUSIVE_OPTION_CONSTANT
.\" BOOST_INTRUSIVE_OPTION_TYPE: Struct template pack_options
.\" Struct template pack_options: BOOST_INTRUSIVE_OPTION_TYPE
.\" BOOST_INTRUSIVE_OPTION_CONSTANT: Struct template pack_options
.\" Struct template pack_options: BOOST_INTRUSIVE_OPTION_CONSTANT
.PP
This class is a utility that takes:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a default options class defining initial static constant and typedefs
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
several options defined with BOOST_INTRUSIVE_OPTION_CONSTANT and BOOST_INTRUSIVE_OPTION_TYPE
.RE
.sp
.RE

.PP
and packs them together in a new type that defines all options as member typedefs or static constant values\&. Given options of form:
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
BOOST_INTRUSIVE_OPTION_TYPE(my_pointer, VoidPointer, VoidPointer, my_pointer_type)
BOOST_INTRUSIVE_OPTION_CONSTANT(incremental, bool, Enabled, is_incremental)

.fi
.if n \{\
.RE
.\}

.PP
the following expression
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
struct default_options
{
  typedef long      int_type;
  static const int  int_constant = \-1;
};

pack_options< default_options, my_pointer<void*>, incremental<true> >::type

.fi
.if n \{\
.RE
.\}

.PP
will create a type that will contain the following typedefs/constants
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
struct unspecified_type
{
   //Default options
   typedef long      int_type;
   static const int  int_constant  = \-1;

   //Packed options (will ovewrite any default option)
   typedef void*     my_pointer_type;
   static const bool is_incremental = true;
};

.fi
.if n \{\
.RE
.\}

.PP
If an option is specified in the default options argument and later redefined as an option, the last definition will prevail\&.

