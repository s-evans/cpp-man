.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "TYPE LINK_MODE_TYPE" 3 "" "" ""
.SH "NAME"
boost::intrusive::link_mode_type
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/intrusive/link_mode\&.hpp>


enum link_mode_type { normal_link, safe_link, auto_unlink };
.fi
.SH "DESCRIPTION"
.PP
This enumeration defines the type of
value_traits
that can be defined for Boost\&.Intrusive containers
.PP
normal_link
.RS 4
If this linking policy is specified in a
value_traits
class as the
link_mode, containers configured with such
value_traits
won\'t set the hooks of the erased values to a default state\&. Containers also won\'t check that the hooks of the new values are default initialized\&.
.RE
.PP
safe_link
.RS 4
If this linking policy is specified in a
value_traits
class as the
link_mode, containers configured with such
value_traits
will set the hooks of the erased values to a default state\&. Containers also will check that the hooks of the new values are default initialized\&.
.RE
.PP
auto_unlink
.RS 4
Same as "safe_link" but the user type is an auto\-unlink type, so the containers with constant\-time size features won\'t be compatible with
value_traits
configured with this policy\&. Containers also know that the a value can be silently erased from the container without using any function provided by the containers\&.
.RE

