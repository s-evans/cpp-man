.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::signals2::signal_type \- Specify a the template type parameters of a boost::signals2::signal using named parameters\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/signals2/signal_type\&.hpp>

template<typename A0, typename A1 = boost::parameter::void_, 
         typename A2 = boost::parameter::void_, 
         typename A3 = boost::parameter::void_, 
         typename A4 = boost::parameter::void_, 
         typename A5 = boost::parameter::void_, 
         typename A6 = boost::parameter::void_> 
class signal_type {
public:
  // types
  typedef \fIimplementation\fR\fI\-\fR\fIdetail\fR                                           signature_type;             
  typedef \fIimplementation\fR\fI\-\fR\fIdetail\fR                                           combiner_type;              
  typedef \fIimplementation\fR\fI\-\fR\fIdetail\fR                                           group_type;                 
  typedef \fIimplementation\fR\fI\-\fR\fIdetail\fR                                           group_compare_type;         
  typedef \fIimplementation\fR\fI\-\fR\fIdetail\fR                                           slot_function_type;         
  typedef \fIimplementation\fR\fI\-\fR\fIdetail\fR                                           extended_slot_function_type;
  typedef \fIimplementation\fR\fI\-\fR\fIdetail\fR                                           mutex_type;                 
  typedef typename signal<signature_type, combiner_type, \&.\&.\&., mutex_type> type;                       
};
.fi
.SH "DESCRIPTION"
.PP
The
signal_type
metafunction employs the Boost\&.Parameter library to allow users to specify the template type parameters of a
signals2::signal
using named parameters\&. The resulting signal type is provided through the
signal_type::type
typedef\&. Named template type parameters can enhance readability of code, and provide convenience for specifying classes which have a large number of template parameters\&.
.PP
The template type parameters may be passed positionally, similarly to passing them to the
signals2::signal
class directly\&. Or, they may be passed as named template parameters by wrapping them in one of the template keyword classes provided in the
boost::signals2::keywords
namespace\&. The supported template keywords are:
keywords::signature_type,
keywords::combiner_type,
keywords::group_type,
keywords::group_compare_type,
keywords::slot_function_type,
keywords::extended_slot_function_type, and
keywords::mutex_type\&.
.PP
The default types for unspecified template type parameters are the same as those for the
signal
class\&.
.PP
Named template type parameters are especially convenient when you only wish to change a few of a signal\'s template type parameters from their defaults, and the parameters you wish to change are near the end of the signal\'s template parameter list\&. For example, if you only wish to change the
Mutex
template type parameter of a signal, you might write:

.sp
.if n \{\
.RS 4
.\}
.nf
namespace bs2 = boost::signals2;
using bs2::keywords;
bs2::signal_type<void (), mutex_type<bs2::dummy_mutex> >::type sig;

.fi
.if n \{\
.RE
.\}
.sp
.PP
For comparison, to specify the same type using the signal class directly looks like:

.sp
.if n \{\
.RS 4
.\}
.nf
namespace bs2 = boost::signals2;
bs2::signal
  <
    void (),
    bs2::optional_last_value<void>,
    int,
    std::less<int>,
    boost::function<void ()>,
    boost::function<void (const connection &)>,
    bs2::dummy_mutex
  > sig;

.fi
.if n \{\
.RE
.\}

