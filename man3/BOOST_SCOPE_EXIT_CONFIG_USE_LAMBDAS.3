.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BO" 3 "" "" ""
.SH "NAME"
BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS \- Force to use C++11 lambda functions to implement scope exits\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/scope_exit\&.hpp>

BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS
.fi
.SH "DESCRIPTION"
.PP
If programmers define this configuration macro on a C++11 compiler for which the Boost\&.Config macro
BOOST_NO_CXX11_LAMBDAS
is not defined, the
BOOST_SCOPE_EXIT
and
BOOST_SCOPE_EXIT_TPL
macros will use C++11 lambda functions to declare scope exits\&. By default this macro is not defined\&.
.PP
\fBWarning:\fR
When scope exits are implemented using lambda functions, the syntax of the capture list follows the exact same syntax of C++11 lambda captures which is in general different from the legacy capture syntax of this library\&. For example, C++11 lambdas require to capture data members by capturing the object
this
while this library always allowed to capture data members directly\&. Therefore, when this configuration macro is defined,
BOOST_SCOPE_EXIT
and
BOOST_SCOPE_EXIT_TPL
are no longer backward compatible (and this is why this macro is not defined by default)\&.
.PP
A semicolon
;
can be used instead of
BOOST_SCOPE_EXIT_END
when this configuration macro is defined (but it is recommended to always use
BOOST_SCOPE_EXIT_END
so to maximize portability)\&.
.PP
\fBNote:\fR
This configuration macro does not control the definition of
BOOST_SCOPE_EXIT_ALL
which is always and automatically defined on compilers that support C++11 lambda functions\&.
.PP
\fBSee:\fR
BOOST_SCOPE_EXIT,
BOOST_SCOPE_EXIT_TPL,
BOOST_SCOPE_EXIT_END\&.

