.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTION TEMPL" 3 "" "" ""
.SH "NAME"
boost::algorithm::clamp_range
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/algorithm/clamp\&.hpp>


template<typename Range, typename OutputIterator, typename Pred> 
  boost::disable_if_c< boost::is_same< Range, OutputIterator >::value, OutputIterator >::type 
  clamp_range(const Range & r, OutputIterator out, 
              typename std::iterator_traits< typename boost::range_iterator< const Range >::type >::value_type const & lo, 
              typename std::iterator_traits< typename boost::range_iterator< const Range >::type >::value_type const & hi, 
              Pred p);
.fi
.SH "DESCRIPTION"
.PP

.PP
Parameters:
.RS 4
.PP
hi
.RS 4
The upper bound of the range to be clamped to
.RE
.PP
lo
.RS 4
The lower bound of the range to be clamped to
.RE
.PP
out
.RS 4
An output iterator to write the clamped values into
.RE
.PP
p
.RS 4
A predicate to use to compare the values\&. p ( a, b ) returns a boolean\&.
.RE
.PP
r
.RS 4
The range of values to be clamped
.RE
.RE
.PP
Returns:
.RS 4
clamp the sequence of values [first, last) into [ lo, hi ] using the comparison predicate p\&.
.RE

