.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS CORE" 3 "" "" ""
.SH "NAME"
boost::log::core \- Logging library core class\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/core/core\&.hpp>


class core {
public:
  // types
  typedef \fIunspecified\fR exception_handler_type;  // Exception handler function type\&. 

  // construct/copy/destruct
  core(core const &) = delete;
  core & operator=(core const &) = delete;
  ~core();

  // public member functions
  bool set_logging_enabled(bool = true);
  bool get_logging_enabled() const;
  void set_filter(filter const &);
  void reset_filter();
  void add_sink(shared_ptr< sinks::sink > const &);
  void remove_sink(shared_ptr< sinks::sink > const &);
  void remove_all_sinks();
  void flush();
  std::pair< attribute_set::iterator, bool > 
  add_global_attribute(attribute_name const &, attribute const &);
  void remove_global_attribute(attribute_set::iterator);
  attribute_set get_global_attributes() const;
  void set_global_attributes(attribute_set const &);
  std::pair< attribute_set::iterator, bool > 
  add_thread_attribute(attribute_name const &, attribute const &);
  void remove_thread_attribute(attribute_set::iterator);
  attribute_set get_thread_attributes() const;
  void set_thread_attributes(attribute_set const &);
  void set_exception_handler(exception_handler_type const &);
  record open_record(attribute_set const &);
  record open_record(attribute_value_set const &);
  record open_record(attribute_value_set &&);
  void push_record(record &&);

  // public static functions
  static core_ptr get();
};
.fi
.SH "DESCRIPTION"
.PP
The logging core is used to interconnect log sources and sinks\&. It also provides a number of basic features, like global filtering and global and thread\-specific attribute storage\&.
.PP
The logging core is a singleton\&. Users can acquire the core instance by calling the static method
get\&.
.SS "core public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
core(core const &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
core & operator=(core const &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
~core();
.fi

.sp
Destructor\&. Destroys the core, releases any sinks and attributes that were registered\&.
.RE

.SS "core public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool set_logging_enabled(bool enabled = true);
.fi

.sp
The method enables or disables logging\&.
.sp
Setting this status to
false
allows you to completely wipe out any logging activity, including filtering and generation of attribute values\&. It is useful if you want to completely disable logging in a running application\&. The state of logging does not alter any other properties of the logging library, such as filters or sinks, so you can enable logging with the very same settings that you had when the logging was disabled\&. This feature may also be useful if you want to perform major changes to logging configuration and don\'t want your application to block on opening or pushing a log record\&.
.sp
By default logging is enabled\&.
.sp

.PP
Parameters:
.RS 4
.PP
enabled
.RS 4
The actual flag of logging activity\&.
.RE
.RE
.PP
Returns:
.RS 4
The previous value of enabled/disabled logging flag
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool get_logging_enabled() const;
.fi

.sp
The method allows to detect if logging is enabled\&. See the comment for
set_logging_enabled\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void set_filter(filter const & filter);
.fi

.sp
The method sets the global logging filter\&. The filter is applied to every log record that is processed\&.
.sp

.PP
Parameters:
.RS 4
.PP
filter
.RS 4
The filter function object to be installed\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void reset_filter();
.fi

.sp
The method removes the global logging filter\&. All log records are passed to sinks without global filtering applied\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void add_sink(shared_ptr< sinks::sink > const & s);
.fi

.sp
The method adds a new sink\&. The sink is included into logging process immediately after being added and until being removed\&. No sink can be added more than once at the same time\&. If the sink is already registered, the call is ignored\&.
.sp

.PP
Parameters:
.RS 4
.PP
s
.RS 4
The sink to be registered\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void remove_sink(shared_ptr< sinks::sink > const & s);
.fi

.sp
The method removes the sink from the output\&. The sink will not receive any log records after removal\&. The call has no effect if the sink is not registered\&.
.sp

.PP
Parameters:
.RS 4
.PP
s
.RS 4
The sink to be unregistered\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
void remove_all_sinks();
.fi

.sp
The method removes all registered sinks from the output\&. The sinks will not receive any log records after removal\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
void flush();
.fi

.sp
The method performs flush on all registered sinks\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
This method may take long time to complete as it may block until all sinks manage to process all buffered log records\&. The call will also block all logging attempts until the operation completes\&.
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
std::pair< attribute_set::iterator, bool > 
add_global_attribute(attribute_name const & name, attribute const & attr);
.fi

.sp
The method adds an attribute to the global attribute set\&. The attribute will be implicitly added to every log record\&.
.sp

.PP
Parameters:
.RS 4
.PP
attr
.RS 4
The attribute factory\&.
.RE
.PP
name
.RS 4
The attribute name\&.
.RE
.RE
.PP
Returns:
.RS 4
A pair of values\&. If the second member is
true, then the attribute is added and the first member points to the attribute\&. Otherwise the attribute was not added and the first member points to the attribute that prevents addition\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
void remove_global_attribute(attribute_set::iterator it);
.fi

.sp
The method removes an attribute from the global attribute set\&.
.sp

.PP
Parameters:
.RS 4
.PP
it
.RS 4
Iterator to the previously added attribute\&.
.RE
.RE
.PP
Requires:
.RS 4
The attribute was added with the
add_global_attribute
call\&.
.RE
.PP
Postconditions:
.RS 4
The attribute is no longer registered as a global attribute\&. The iterator is invalidated after removal\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
attribute_set get_global_attributes() const;
.fi

.sp
The method returns a copy of the complete set of currently registered global attributes\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
void set_global_attributes(attribute_set const & attrs);
.fi

.sp
The method replaces the complete set of currently registered global attributes with the provided set\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The method invalidates all iterators and references that may have been returned from the
add_global_attribute
method\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
attrs
.RS 4
The set of attributes to be installed\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
std::pair< attribute_set::iterator, bool > 
add_thread_attribute(attribute_name const & name, attribute const & attr);
.fi

.sp
The method adds an attribute to the thread\-specific attribute set\&. The attribute will be implicitly added to every log record made in the current thread\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
In single\-threaded build the effect is the same as adding the attribute globally\&. This, however, does not imply that iterators to thread\-specific and global attributes are interchangeable\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
attr
.RS 4
The attribute factory\&.
.RE
.PP
name
.RS 4
The attribute name\&.
.RE
.RE
.PP
Returns:
.RS 4
A pair of values\&. If the second member is
true, then the attribute is added and the first member points to the attribute\&. Otherwise the attribute was not added and the first member points to the attribute that prevents addition\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
void remove_thread_attribute(attribute_set::iterator it);
.fi

.sp
The method removes an attribute from the thread\-specific attribute set\&.
.sp

.PP
Parameters:
.RS 4
.PP
it
.RS 4
Iterator to the previously added attribute\&.
.RE
.RE
.PP
Requires:
.RS 4
The attribute was added with the
add_thread_attribute
call\&.
.RE
.PP
Postconditions:
.RS 4
The attribute is no longer registered as a thread\-specific attribute\&. The iterator is invalidated after removal\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
attribute_set get_thread_attributes() const;
.fi

.sp
The method returns a copy of the complete set of currently registered thread\-specific attributes\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
void set_thread_attributes(attribute_set const & attrs);
.fi

.sp
The method replaces the complete set of currently registered thread\-specific attributes with the provided set\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The method invalidates all iterators and references that may have been returned from the
add_thread_attribute
method\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
attrs
.RS 4
The set of attributes to be installed\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
void set_exception_handler(exception_handler_type const & handler);
.fi

.sp
The method sets exception handler function\&. The function will be called with no arguments in case if an exception occurs during either
open_record
or
push_record
method execution\&. Since exception handler is called from a
catch
statement, the exception can be rethrown in order to determine its type\&.
.sp
By default no handler is installed, thus any exception is propagated as usual\&.
.sp
\fBSee Also:\fRSee also: utility/exception_handler\&.hpp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The exception handler can be invoked in several threads concurrently\&. Thread interruptions are not affected by exception handlers\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
handler
.RS 4
Exception handling function
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
record open_record(attribute_set const & source_attributes);
.fi

.sp
The method attempts to open a new record to be written\&. While attempting to open a log record all filtering is applied\&. A successfully opened record can be pushed further to sinks by calling the
push_record
method or simply destroyed by destroying the returned object\&.
.sp
More than one open records are allowed, such records exist independently\&. All attribute values are acquired during opening the record and do not interact between records\&.
.sp
The returned records can be copied, however, they must not be passed between different threads\&.
.sp

\fBThrows:\fR
If an exception handler is installed, only throws if the handler throws\&. Otherwise may throw if one of the sinks throws, or some system resource limitation is reached\&.
.PP
Parameters:
.RS 4
.PP
source_attributes
.RS 4
The set of source\-specific attributes to be attached to the record to be opened\&.
.RE
.RE
.PP
Returns:
.RS 4
A valid log record if the record is opened, an invalid record object if not (e\&.g\&. because it didn\'t pass filtering)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
record open_record(attribute_value_set const & source_attributes);
.fi

.sp
The method attempts to open a new record to be written\&. While attempting to open a log record all filtering is applied\&. A successfully opened record can be pushed further to sinks by calling the
push_record
method or simply destroyed by destroying the returned object\&.
.sp
More than one open records are allowed, such records exist independently\&. All attribute values are acquired during opening the record and do not interact between records\&.
.sp
The returned records can be copied, however, they must not be passed between different threads\&.
.sp

\fBThrows:\fR
If an exception handler is installed, only throws if the handler throws\&. Otherwise may throw if one of the sinks throws, or some system resource limitation is reached\&.
.PP
Parameters:
.RS 4
.PP
source_attributes
.RS 4
The set of source\-specific attribute values to be attached to the record to be opened\&.
.RE
.RE
.PP
Returns:
.RS 4
A valid log record if the record is opened, an invalid record object if not (e\&.g\&. because it didn\'t pass filtering)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
record open_record(attribute_value_set && source_attributes);
.fi

.sp
The method attempts to open a new record to be written\&. While attempting to open a log record all filtering is applied\&. A successfully opened record can be pushed further to sinks by calling the
push_record
method or simply destroyed by destroying the returned object\&.
.sp
More than one open records are allowed, such records exist independently\&. All attribute values are acquired during opening the record and do not interact between records\&.
.sp
The returned records can be copied, however, they must not be passed between different threads\&.
.sp

\fBThrows:\fR
If an exception handler is installed, only throws if the handler throws\&. Otherwise may throw if one of the sinks throws, or some system resource limitation is reached\&.
.PP
Parameters:
.RS 4
.PP
source_attributes
.RS 4
The set of source\-specific attribute values to be attached to the record to be opened\&. The contents of this container are unspecified after this call\&.
.RE
.RE
.PP
Returns:
.RS 4
A valid log record if the record is opened, an invalid record object if not (e\&.g\&. because it didn\'t pass filtering)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
void push_record(record && rec);
.fi

.sp
The method pushes the record to sinks\&. The record is moved from in the process\&.
.sp

\fBThrows:\fR
If an exception handler is installed, only throws if the handler throws\&. Otherwise may throw if one of the sinks throws\&.
.PP
Parameters:
.RS 4
.PP
rec
.RS 4
A previously successfully opened log record\&.
.RE
.RE
.PP
Requires:
.RS 4
!!rec == true
.RE
.PP
Postconditions:
.RS 4
!rec == true
.RE
.RE

.SS "core public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static core_ptr get();
.fi

.sp

.PP
Returns:
.RS 4
The method returns a pointer to the logging core singleton instance\&.
.RE
.RE


