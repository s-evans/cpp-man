.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE QU" 3 "" "" ""
.SH "NAME"
boost::units::quantity \- class declaration
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/units/quantity\&.hpp>

template<typename Unit, typename Y> 
class quantity {
public:
  // types
  typedef quantity< Unit, Y > this_type; 
  typedef Y                   value_type;
  typedef Unit                unit_type; 

  // construct/copy/destruct
  quantity();
  quantity(unspecified_null_pointer_constant_type);
  quantity(const this_type &);
  template<typename YY> 
    quantity(const quantity< Unit, YY > &, \fIunspecified\fR = 0);
  template<typename YY> 
    explicit quantity(const quantity< Unit, YY > &, \fIunspecified\fR = 0);
  template<typename Unit2, typename YY> 
    explicit quantity(const quantity< Unit2, YY > &, \fIunspecified\fR = 0);
  template<typename Unit2, typename YY> 
    quantity(const quantity< Unit2, YY > &, \fIunspecified\fR = 0);
  explicit quantity(const value_type &, int);
  this_type & operator=(const this_type &);
  template<typename YY> this_type & operator=(const quantity< Unit, YY > &);
  template<typename Unit2, typename YY> 
    this_type & operator=(const quantity< Unit2, YY > &);

  // private member functions
   BOOST_MPL_ASSERT_NOT(\fIunspecified\fR);

  // public member functions
  const value_type & value() const;
  template<typename Unit2, typename YY> 
    this_type & operator+=(const quantity< Unit2, YY > &);
  template<typename Unit2, typename YY> 
    this_type & operator\-=(const quantity< Unit2, YY > &);
  template<typename Unit2, typename YY> 
    this_type & operator*=(const quantity< Unit2, YY > &);
  template<typename Unit2, typename YY> 
    this_type & operator/=(const quantity< Unit2, YY > &);
  this_type & operator*=(const value_type &);
  this_type & operator/=(const value_type &);

  // public static functions
  static this_type from_value(const value_type &);
};
.fi
.SH "DESCRIPTION"
.SS "quantity public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
quantity();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
quantity(unspecified_null_pointer_constant_type);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
quantity(const this_type & source);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename YY> 
  quantity(const quantity< Unit, YY > & source, \fIunspecified\fR = 0);
.fi

implicit conversion between value types is allowed if allowed for value types themselves .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename YY> 
  explicit quantity(const quantity< Unit, YY > & source, \fIunspecified\fR = 0);
.fi

implicit conversion between value types is not allowed if not allowed for value types themselves .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename Unit2, typename YY> 
  explicit quantity(const quantity< Unit2, YY > & source, \fIunspecified\fR = 0);
.fi

explicit conversion between different unit systems is allowed if implicit conversion is disallowed .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename Unit2, typename YY> 
  quantity(const quantity< Unit2, YY > & source, \fIunspecified\fR = 0);
.fi

implicit conversion between different unit systems is allowed if each fundamental dimension is implicitly convertible .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
explicit quantity(const value_type & val, int);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
this_type & operator=(const this_type & source);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename YY> 
  this_type & operator=(const quantity< Unit, YY > & source);
.fi

implicit assignment between value types is allowed if allowed for value types themselves .RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
template<typename Unit2, typename YY> 
  this_type & operator=(const quantity< Unit2, YY > & source);
.fi

implicit assignment between different unit systems is allowed if each fundamental dimension is implicitly convertible .RE

.SS "quantity private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
 BOOST_MPL_ASSERT_NOT(\fIunspecified\fR);
.fi

.RE

.SS "quantity public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
const value_type & value() const;
.fi

.sp
constant accessor to value can add a quantity of the same type if add_typeof_helper<value_type,value_type>::type is convertible to value_type
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Unit2, typename YY> 
  this_type & operator+=(const quantity< Unit2, YY > & source);
.fi

can subtract a quantity of the same type if subtract_typeof_helper<value_type,value_type>::type is convertible to value_type .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename Unit2, typename YY> 
  this_type & operator\-=(const quantity< Unit2, YY > & source);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename Unit2, typename YY> 
  this_type & operator*=(const quantity< Unit2, YY > & source);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename Unit2, typename YY> 
  this_type & operator/=(const quantity< Unit2, YY > & source);
.fi

can multiply a quantity by a scalar value_type if multiply_typeof_helper<value_type,value_type>::type is convertible to value_type .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
this_type & operator*=(const value_type & source);
.fi

can divide a quantity by a scalar value_type if divide_typeof_helper<value_type,value_type>::type is convertible to value_type .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
this_type & operator/=(const value_type & source);
.fi

.RE

.SS "quantity public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static this_type from_value(const value_type & val);
.fi

Construct quantity directly from value_type (potentially dangerous)\&. .RE

.SS "Specializations"

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Class template quantity<BOOST_UNITS_DIMENSIONLESS_UNIT(System), Y>
.RE

