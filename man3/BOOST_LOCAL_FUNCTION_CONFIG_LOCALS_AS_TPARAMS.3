.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MAC" 3 "" "" ""
.SH "NAME"
BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS \- Specify when local functions can be passed as template parameters without introducing any run\-time overhead\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/local_function/config\&.hpp>

BOOST_LOCAL_FUNCTION_CONFIG_LOCALS_AS_TPARAMS
.fi
.SH "DESCRIPTION"
.PP
If this macro is defined to
1, this library will assume that the compiler allows to pass local classes as template parameters:

.sp
.if n \{\
.RS 4
.\}
.nf
template<typename T> void f(void) {}

int main(void) {
    struct local_class {};
    f<local_class>();
    return 0;
}

.fi
.if n \{\
.RE
.\}
.sp
This is the case for C++11 compilers and some C++03 compilers (e\&.g\&., MSVC), but it is not the case in general for most C++03 compilers (including GCC)\&. This will allow the library to pass local functions as template parameters without introducing any run\-time overhead (specifically without preventing the compiler from optimizing local function calls by inlining their assembly code)\&.
.PP
If this macro is defined to
0
instead, this library will introduce a run\-time overhead associated to resolving a function pointer call in order to still allow to pass the local functions as template parameters\&.
.PP
It is recommended to leave this macro undefined\&. In this case, the library will automatically define this macro to
0
if the Boost\&.Config macro
BOOST_NO_CXX11_LOCAL_CLASS_TEMPLATE_PARAMETERS
is defined for the specific compiler, and to
1
otherwise\&.
.PP
\fBSee:\fR
Getting Started
section,
Advanced Topics
section,
BOOST_LOCAL_FUNCTION_NAME\&.

