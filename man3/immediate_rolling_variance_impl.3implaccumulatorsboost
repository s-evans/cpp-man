.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUC" 3 "" "" ""
.SH "NAME"
boost::accumulators::impl::immediate_rolling_variance_impl \- Iterative calculation of the rolling variance\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/accumulators/statistics/rolling_variance\&.hpp>

template<typename Sample> 
struct immediate_rolling_variance_impl : public accumulator_base {
  // types
  typedef numeric::functional::fdiv< Sample, std::size_t >::result_type result_type;

  // construct/copy/destruct
  template<typename Args> immediate_rolling_variance_impl(Args const &);

  // public member functions
  template<typename Args> void operator()(Args const &);
  template<typename Args> result_type result(Args const &) const;

  // private member functions
  template<typename T> 
    void prevent_underflow(T &, 
                           typename boost::enable_if< boost::is_arithmetic< T >, T >::type * = 0);
  template<typename T> 
    void prevent_underflow(T &, 
                           typename boost::disable_if< boost::is_arithmetic< T >, T >::type * = 0);
};
.fi
.SH "DESCRIPTION"
.PP
Iterative calculation of sample variance
\&\s-2\u[1]\d\s+2[IMAGE]\&\s-2\u[2]\d\s+2 [$\sigma_n^2$]
is done as follows, see also
\m[blue]\fBhttp://en\&.wikipedia\&.org/wiki/Algorithms_for_calculating_variance\fR\m[]\&. For a rolling window of size
\&\s-2\u[3]\d\s+2[IMAGE]\&\s-2\u[4]\d\s+2 [$N$], for the first
\&\s-2\u[5]\d\s+2[IMAGE]\&\s-2\u[4]\d\s+2 [$N$]
samples, the variance is computed according to the formula
\fBEquation 1.7. \fR \&\s-2\u[6]\d\s+2.sp .RS 4 [IMAGE]\&\s-2\u[7]\d\s+2 \e[ \esigma_n^2 = \efrac{1}{n\-1} \esum_{i = 1}^n (x_i \- \emu_n)^2 = \efrac{1}{n\-1}M_{2,n}, \e] .RE
where the sum of squares
\&\s-2\u[8]\d\s+2[IMAGE]\&\s-2\u[9]\d\s+2 [$M_{2,n}$]
can be recursively computed as:
\fBEquation 1.8. \fR \&\s-2\u[10]\d\s+2.sp .RS 4 [IMAGE]\&\s-2\u[11]\d\s+2 \e[ M_{2,n} = \esum_{i = 1}^n (x_i \- \emu_n)^2 = M_{2,n\-1} + (x_n \- \emu_n)(x_n \- \emu_{n\-1}), \e] .RE
and the estimate of the sample mean as:
\fBEquation 1.9. \fR \&\s-2\u[12]\d\s+2.sp .RS 4 [IMAGE]\&\s-2\u[13]\d\s+2 \e[ \emu_n = \efrac{1}{n} \esum_{i = 1}^n x_i = \emu_{n\-1} + \efrac{1}{n}(x_n \- \emu_{n\-1})\&. \e] .RE
For further samples, when the rolling window is fully filled with data, one has to take into account that the oldest sample
\&\s-2\u[14]\d\s+2[IMAGE]\&\s-2\u[15]\d\s+2 [$x_{n-N}$]
is dropped from the window\&. The sample variance over the window now becomes:
\fBEquation 1.10. \fR \&\s-2\u[16]\d\s+2.sp .RS 4 [IMAGE]\&\s-2\u[17]\d\s+2 \e[ \esigma_n^2 = \efrac{1}{N\-1} \esum_{i = n\-N+1}^n (x_i \- \emu_n)^2 = \efrac{1}{n\-1}M_{2,n}, \e] .RE
where the sum of squares
\&\s-2\u[18]\d\s+2[IMAGE]\&\s-2\u[9]\d\s+2 [$M_{2,n}$]
now equals:
\fBEquation 1.11. \fR \&\s-2\u[19]\d\s+2.sp .RS 4 [IMAGE]\&\s-2\u[20]\d\s+2 \e[ M_{2,n} = \esum_{i = n\-N+1}^n (x_i \- \emu_n)^2 = M_{2,n\-1} + (x_n \- \emu_n)(x_n \- \emu_{n\-1}) \- (x_{n\-N} \- \emu_n)(x_{n\-N} \- \emu_{n\-1}), \e] .RE
and the estimated mean is:
\fBEquation 1.12. \fR \&\s-2\u[21]\d\s+2.sp .RS 4 [IMAGE]\&\s-2\u[22]\d\s+2 \e[ \emu_n = \efrac{1}{N} \esum_{i = n\-N+1}^n x_i = \emu_{n\-1} + \efrac{1}{n}(x_n \- x_{n\-N})\&. \e] .RE
.PP
Note that the sample variance is not defined for
\&\s-2\u[23]\d\s+2[IMAGE]\&\s-2\u[24]\d\s+2 [$n <= 1$]\&.
.SS "immediate_rolling_variance_impl public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Args> immediate_rolling_variance_impl(Args const & args);
.fi

.RE

.SS "immediate_rolling_variance_impl public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Args> void operator()(Args const & args);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Args> result_type result(Args const & args) const;
.fi

.RE

.SS "immediate_rolling_variance_impl private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename T> 
  void prevent_underflow(T & non_negative_number, 
                         typename boost::enable_if< boost::is_arithmetic< T >, T >::type * = 0);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename T> 
  void prevent_underflow(T & non_arithmetic_quantity, 
                         typename boost::disable_if< boost::is_arithmetic< T >, T >::type * = 0);
.fi

.RE


