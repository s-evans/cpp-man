.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEM" 3 "" "" ""
.SH "NAME"
boost::container::scoped_allocator_adaptor
.SH "SYNOPSIS"
.\" void_pointer: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: void_pointer
.\" value_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: value_type
.\" swap: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: swap
.\" size_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: size_type
.\" rebind: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: rebind
.\" propagate_on_container_swap: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: propagate_on_container_swap
.\" propagate_on_container_move_assignment: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: propagate_on_container_move_assignment
.\" propagate_on_container_copy_assignment: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: propagate_on_container_copy_assignment
.\" pointer: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: pointer
.\" outer_traits_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_traits_type
.\" outer_allocator_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_allocator_type
.\" outer_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_allocator
.\" other: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: other
.\" is_always_equal: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: is_always_equal
.\" inner_traits_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: inner_traits_type
.\" inner_allocator_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: inner_allocator_type
.\" inner_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: inner_allocator
.\" difference_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: difference_type
.\" destroy: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: destroy
.\" deallocate: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: deallocate
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct
.\" const_void_pointer: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: const_void_pointer
.\" const_pointer: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: const_pointer
.\" allocate: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: allocate

.sp
.nf
// In header: <boost/container/scoped_allocator\&.hpp>

template<typename OuterAlloc, typename\&.\&.\&. InnerAllocs> 
class scoped_allocator_adaptor {
public:
  // types
  typedef OuterAlloc                                        outer_allocator_type;                  
  typedef allocator_traits< OuterAlloc >                    outer_traits_type;                     
  typedef base_type::inner_allocator_type                   inner_allocator_type;                  
  typedef allocator_traits< inner_allocator_type >          inner_traits_type;                     
  typedef outer_traits_type::value_type                     value_type;                            
  typedef outer_traits_type::size_type                      size_type;                             
  typedef outer_traits_type::difference_type                difference_type;                       
  typedef outer_traits_type::pointer                        pointer;                               
  typedef outer_traits_type::const_pointer                  const_pointer;                         
  typedef outer_traits_type::void_pointer                   void_pointer;                          
  typedef outer_traits_type::const_void_pointer             const_void_pointer;                    
  typedef base_type::propagate_on_container_copy_assignment propagate_on_container_copy_assignment;
  typedef base_type::propagate_on_container_move_assignment propagate_on_container_move_assignment;
  typedef base_type::propagate_on_container_swap            propagate_on_container_swap;           
  typedef base_type::is_always_equal                        is_always_equal;                       

  // member classes/structs/unions
  template<typename U> 
  struct rebind {
    // types
    typedef scoped_allocator_adaptor< typename outer_traits_type::template portable_rebind_alloc< U >::type, InnerAllocs\&.\&.\&.> other;
  };

  // construct/copy/destruct
  scoped_allocator_adaptor();
  scoped_allocator_adaptor(const scoped_allocator_adaptor &);
  scoped_allocator_adaptor(scoped_allocator_adaptor &&);
  template<typename OuterA2> 
    scoped_allocator_adaptor(OuterA2 &&, const InnerAllocs &\&.\&.\&.);
  template<typename OuterA2> 
    scoped_allocator_adaptor(const scoped_allocator_adaptor< OuterA2, InnerAllocs\&.\&.\&.> &);
  template<typename OuterA2> 
    scoped_allocator_adaptor(scoped_allocator_adaptor< OuterA2, InnerAllocs\&.\&.\&.> &&);
  scoped_allocator_adaptor & operator=(const scoped_allocator_adaptor &);
  scoped_allocator_adaptor & operator=(scoped_allocator_adaptor &&);
  ~scoped_allocator_adaptor();

  // public member functions
  void swap(scoped_allocator_adaptor &);
  outer_allocator_type & outer_allocator() noexcept;
  const outer_allocator_type & outer_allocator() const noexcept;
  inner_allocator_type & inner_allocator() noexcept;
  inner_allocator_type const & inner_allocator() const noexcept;
  size_type max_size() const noexcept;
  template<typename T> void destroy(T *) noexcept;
  pointer allocate(size_type);
  pointer allocate(size_type, const_void_pointer);
  void deallocate(pointer, size_type);
  scoped_allocator_adaptor select_on_container_copy_construction() const;
  template<typename T, class\&.\&.\&. Args> void construct(T *, Args &&\&.\&.\&.);
  template<typename T1, typename T2> void construct(std::pair< T1, T2 > *);
  template<typename T1, typename T2> void construct(\fIunspecified\fR);
  template<typename T1, typename T2, typename U, typename V> 
    void construct(std::pair< T1, T2 > *, U &&, V &&);
  template<typename T1, typename T2, typename U, typename V> 
    void construct(\fIunspecified\fR, U &&, V &&);
  template<typename T1, typename T2, typename U, typename V> 
    void construct(std::pair< T1, T2 > *, const std::pair< U, V > &);
  template<typename T1, typename T2, typename U, typename V> 
    void construct(\fIunspecified\fR, \fIunspecified\fR);
  template<typename T1, typename T2, typename U, typename V> 
    void construct(std::pair< T1, T2 > *, std::pair< U, V > &&);
  template<typename T1, typename T2, typename U, typename V> 
    void construct(\fIunspecified\fR, \fIunspecified\fR);

  // friend functions
  friend void swap(scoped_allocator_adaptor &, scoped_allocator_adaptor &);
};
.fi
.SH "DESCRIPTION"
.\" outer_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_allocator
.\" outer_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_allocator
.PP
This class is a C++03\-compatible implementation of std::scoped_allocator_adaptor\&. The class template
scoped_allocator_adaptor
is an allocator template that specifies the memory resource (the outer allocator) to be used by a container (as any other allocator does) and also specifies an inner allocator resource to be passed to the constructor of every element within the container\&.
.PP
This adaptor is instantiated with one outer and zero or more inner allocator types\&. If instantiated with only one allocator type, the inner allocator becomes the
scoped_allocator_adaptor
itself, thus using the same allocator resource for the container and every element within the container and, if the elements themselves are containers, each of their elements recursively\&. If instantiated with more than one allocator, the first allocator is the outer allocator for use by the container, the second allocator is passed to the constructors of the container\'s elements, and, if the elements themselves are containers, the third allocator is passed to the elements\' elements, and so on\&. If containers are nested to a depth greater than the number of allocators, the last allocator is used repeatedly, as in the single\-allocator case, for any remaining recursions\&.
.PP
[\fBNote\fR: The
scoped_allocator_adaptor
is derived from the outer allocator type so it can be substituted for the outer allocator type in most expressions\&. \-end note]
.PP
In the construct member functions,
OUTERMOST(x)
is x if x does not have an
outer_allocator()
member function and
OUTERMOST(x\&.outer_allocator())
otherwise;
OUTERMOST_ALLOC_TRAITS(x)
is
allocator_traits<decltype(OUTERMOST(x))>\&.
.PP
[\fBNote\fR:
OUTERMOST(x)
and
OUTERMOST_ALLOC_TRAITS(x)
are recursive operations\&. It is incumbent upon the definition of
outer_allocator()
to ensure that the recursion terminates\&. It will terminate for all instantiations of
scoped_allocator_adaptor\&. \-end note]
.SS "scoped_allocator_adaptor public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" outer_traits_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_traits_type

typedef
allocator_traits<
OuterAlloc
>
outer_traits_type;
.sp
Type: For exposition only
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" inner_allocator_type: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: inner_allocator_type

typedef
base_type::inner_allocator_type
inner_allocator_type;
.sp
Type:
scoped_allocator_adaptor<OuterAlloc>
if
sizeof\&.\&.\&.(InnerAllocs)
is zero; otherwise,
scoped_allocator_adaptor<InnerAllocs\&.\&.\&.>\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" propagate_on_container_copy_assignment: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: propagate_on_container_copy_assignment

typedef
base_type::propagate_on_container_copy_assignment
propagate_on_container_copy_assignment;
.sp
Type: A type with a constant boolean
value
== true if
allocator_traits<Allocator>::propagate_on_container_copy_assignment::value
is true for any
Allocator
in the set of
OuterAlloc
and
InnerAllocs\&.\&.\&., false otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" propagate_on_container_move_assignment: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: propagate_on_container_move_assignment

typedef
base_type::propagate_on_container_move_assignment
propagate_on_container_move_assignment;
.sp
Type: A type with a constant boolean
value
== true if
allocator_traits<Allocator>::propagate_on_container_move_assignment::value
is true for any
Allocator
in the set of
OuterAlloc
and
InnerAllocs\&.\&.\&., false otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" propagate_on_container_swap: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: propagate_on_container_swap

typedef
base_type::propagate_on_container_swap
propagate_on_container_swap;
.sp
Type: A type with a constant boolean
value
== true if
allocator_traits<Allocator>::propagate_on_container_swap::value
is true for any
Allocator
in the set of
OuterAlloc
and
InnerAllocs\&.\&.\&., false otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" is_always_equal: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: is_always_equal

typedef
base_type::is_always_equal
is_always_equal;
.sp
Type: A type with a constant boolean
value
== true if
allocator_traits<Allocator>::is_always_equal::value
is true for all
Allocator
in the set of
OuterAlloc
and
InnerAllocs\&.\&.\&., false otherwise\&.
.RE

.SS "scoped_allocator_adaptor public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
scoped_allocator_adaptor();
.fi

.sp
\fBEffects\fR: value\-initializes the OuterAlloc base class and the inner allocator object\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
scoped_allocator_adaptor(const scoped_allocator_adaptor & other);
.fi

.sp
\fBEffects\fR: initializes each allocator within the adaptor with the corresponding allocator from other\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
scoped_allocator_adaptor(scoped_allocator_adaptor && other);
.fi

.sp
\fBEffects\fR: move constructs each allocator within the adaptor with the corresponding allocator from other\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename OuterA2> 
  scoped_allocator_adaptor(OuterA2 && outerAlloc, 
                           const InnerAllocs &\&.\&.\&. innerAllocs);
.fi

.sp
\fBRequires\fR: OuterAlloc shall be constructible from OuterA2\&.
.sp
\fBEffects\fR: initializes the OuterAlloc base class with boost::forward<OuterA2>(outerAlloc) and inner with innerAllocs\&.\&.\&.(hence recursively initializing each allocator within the adaptor with the corresponding allocator from the argument list)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename OuterA2> 
  scoped_allocator_adaptor(const scoped_allocator_adaptor< OuterA2, InnerAllocs\&.\&.\&.> & other);
.fi

.sp
\fBRequires\fR: OuterAlloc shall be constructible from OuterA2\&.
.sp
\fBEffects\fR: initializes each allocator within the adaptor with the corresponding allocator from other\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename OuterA2> 
  scoped_allocator_adaptor(scoped_allocator_adaptor< OuterA2, InnerAllocs\&.\&.\&.> && other);
.fi

.sp
\fBRequires\fR: OuterAlloc shall be constructible from OuterA2\&.
.sp
\fBEffects\fR: initializes each allocator within the adaptor with the corresponding allocator rvalue from other\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
scoped_allocator_adaptor & operator=(const scoped_allocator_adaptor & other);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
scoped_allocator_adaptor & operator=(scoped_allocator_adaptor && other);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
~scoped_allocator_adaptor();
.fi

.RE

.SS "scoped_allocator_adaptor public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" swap: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: swap

.sp

.nf
void swap(scoped_allocator_adaptor & r);
.fi

.sp
\fBEffects\fR: swaps *this with r\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" outer_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_allocator

.sp

.nf
outer_allocator_type & outer_allocator() noexcept;
.fi

.sp
\fBReturns\fR:
static_cast<OuterAlloc&>(*this)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" outer_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: outer_allocator

.sp

.nf
const outer_allocator_type & outer_allocator() const noexcept;
.fi

.sp
\fBReturns\fR:
static_cast<const OuterAlloc&>(*this)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" inner_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: inner_allocator

.sp

.nf
inner_allocator_type & inner_allocator() noexcept;
.fi

.sp
\fBReturns\fR: *this if
sizeof\&.\&.\&.(InnerAllocs)
is zero; otherwise, inner\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" inner_allocator: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: inner_allocator

.sp

.nf
inner_allocator_type const & inner_allocator() const noexcept;
.fi

.sp
\fBReturns\fR: *this if
sizeof\&.\&.\&.(InnerAllocs)
is zero; otherwise, inner\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBReturns\fR:
allocator_traits<OuterAlloc>::max_size(outer_allocator())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" destroy: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: destroy

.sp

.nf
template<typename T> void destroy(T * p) noexcept;
.fi

.sp
\fBEffects\fR: calls
OUTERMOST_ALLOC_TRAITS(*this)::destroy(OUTERMOST(*this), p)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" allocate: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: allocate

.sp

.nf
pointer allocate(size_type n);
.fi

.sp
\fBReturns\fR:
allocator_traits<OuterAlloc>::allocate(outer_allocator(), n)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" allocate: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: allocate

.sp

.nf
pointer allocate(size_type n, const_void_pointer hint);
.fi

.sp
\fBReturns\fR:
allocator_traits<OuterAlloc>::allocate(outer_allocator(), n, hint)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" deallocate: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: deallocate

.sp

.nf
void deallocate(pointer p, size_type n);
.fi

.sp
\fBEffects\fR:
allocator_traits<OuterAlloc>::deallocate(outer_allocator(), p, n)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
scoped_allocator_adaptor select_on_container_copy_construction() const;
.fi

.sp
\fBReturns\fR: A new
scoped_allocator_adaptor
object where each allocator Allocator in the adaptor is initialized from the result of calling
allocator_traits<Allocator>::select_on_container_copy_construction()
on the corresponding allocator in *this\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T, class\&.\&.\&. Args> void construct(T * p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: 1) If
uses_allocator<T, inner_allocator_type>::value
is false calls
OUTERMOST_ALLOC_TRAITS(*this)::construct (OUTERMOST(*this), p, std::forward<Args>(args)\&.\&.\&.)\&.
.sp
2) Otherwise, if
uses_allocator<T, inner_allocator_type>::value
is true and
is_constructible<T, allocator_arg_t, inner_allocator_type, Args\&.\&.\&.>::value
is true, calls
OUTERMOST_ALLOC_TRAITS(*this)::construct(OUTERMOST(*this), p, allocator_arg, inner_allocator(), std::forward<Args>(args)\&.\&.\&.)\&.
.sp
[\fBNote\fR: In compilers without advanced decltype SFINAE support,
is_constructible
can\'t be implemented so that condition will be replaced by constructible_with_allocator_prefix<T>::value\&. \-end note]
.sp
3) Otherwise, if uses_allocator<T, inner_allocator_type>::value is true and
is_constructible<T, Args\&.\&.\&., inner_allocator_type>::value
is true, calls
OUTERMOST_ALLOC_TRAITS(*this)::construct(OUTERMOST(*this), p, std::forward<Args>(args)\&.\&.\&., inner_allocator())\&.
.sp
[\fBNote\fR: In compilers without advanced decltype SFINAE support,
is_constructible
can\'t be implemented so that condition will be replaced by
constructible_with_allocator_suffix<T>::value\&. \-end note]
.sp
4) Otherwise, the program is ill\-formed\&.
.sp
[\fBNote\fR: An error will result if
uses_allocator
evaluates to true but the specific constructor does not take an allocator\&. This definition prevents a silent failure to pass an inner allocator to a contained element\&. \-end note]
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2> void construct(std::pair< T1, T2 > * p);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2> void construct(\fIunspecified\fR p);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2, typename U, typename V> 
  void construct(std::pair< T1, T2 > * p, U && x, V && y);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2, typename U, typename V> 
  void construct(\fIunspecified\fR p, U && x, V && y);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2, typename U, typename V> 
  void construct(std::pair< T1, T2 > * p, const std::pair< U, V > & x);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2, typename U, typename V> 
  void construct(\fIunspecified\fR p, \fIunspecified\fR x);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2, typename U, typename V> 
  void construct(std::pair< T1, T2 > * p, std::pair< U, V > && x);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" construct: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: construct

.sp

.nf
template<typename T1, typename T2, typename U, typename V> 
  void construct(\fIunspecified\fR p, \fIunspecified\fR x);
.fi

.RE

.SS "scoped_allocator_adaptor friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" swap: Class template scoped_allocator_adaptor
.\" Class template scoped_allocator_adaptor: swap

.sp

.nf
friend void swap(scoped_allocator_adaptor & l, scoped_allocator_adaptor & r);
.fi

.sp
\fBEffects\fR: swaps *this with r\&.
.RE


