.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE S" 3 "" "" ""
.SH "NAME"
boost::lockfree::spsc_queue
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/lockfree/spsc_queue\&.hpp>

template<typename T, \&.\&.\&. Options> 
class spsc_queue {
public:
  // types
  typedef T                                 value_type;
  typedef implementation_defined::allocator allocator; 
  typedef implementation_defined::size_type size_type; 

  // construct/copy/destruct
  spsc_queue(void);
  template<typename U> 
    explicit spsc_queue(typename allocator::template rebind< U >::other const &);
  explicit spsc_queue(allocator const &);
  explicit spsc_queue(size_type);
  template<typename U> 
    spsc_queue(size_type, 
               typename allocator::template rebind< U >::other const &);
  spsc_queue(size_type, allocator_arg const &);

  // public member functions
  bool push(T const &);
  bool pop();
  template<typename U> 
    boost::enable_if< typename is_convertible< T, U >::type, bool >::type 
    pop(U &);
  size_type push(T const *, size_type);
  template<size_type size> size_type push(T const (&));
  template<typename ConstIterator> 
    ConstIterator push(ConstIterator, ConstIterator);
  size_type pop(T *, size_type);
  template<size_type size> size_type pop(T(&));
  template<typename OutputIterator> 
    boost::disable_if< typename is_convertible< T, OutputIterator >::type, size_type >::type 
    pop(OutputIterator);
  template<typename Functor> bool consume_one(Functor &);
  template<typename Functor> bool consume_one(Functor const &);
  template<typename Functor> size_type consume_all(Functor &);
  template<typename Functor> size_type consume_all(Functor const &);
  size_type read_available() const;
  size_type write_available() const;
  const T & front() const;
  T & front();
  void reset(void);
};
.fi
.SH "DESCRIPTION"
.PP
The
spsc_queue
class provides a single\-writer/single\-reader fifo queue, pushing and popping is wait\-free\&.
.PP
\fBPolicies:\fR

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::capacity<>, optional
&#9618;.br&#9618;
If this template argument is passed to the options, the size of the ringbuffer is set at compile\-time\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::allocator<>, defaults to
boost::lockfree::allocator<std::allocator<T>>
&#9618;.br&#9618;
Specifies the allocator that is used to allocate the ringbuffer\&. This option is only valid, if the ringbuffer is configured to be sized at run\-time
.RE
.sp
.RE

.PP
\fBRequirements:\fR

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must have a default constructor
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must be copyable
.RE
.sp
.RE

.SS "spsc_queue public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
spsc_queue(void);
.fi

.sp
Constructs a
spsc_queue
.sp

.PP
Requires:
.RS 4
spsc_queue
must be configured to be sized at compile\-time
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename U> 
  explicit spsc_queue(typename allocator::template rebind< U >::other const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit spsc_queue(allocator const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
explicit spsc_queue(size_type element_count);
.fi

.sp
Constructs a
spsc_queue
for element_count elements
.sp

.PP
Requires:
.RS 4
spsc_queue
must be configured to be sized at run\-time
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename U> 
  spsc_queue(size_type element_count, 
             typename allocator::template rebind< U >::other const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
spsc_queue(size_type element_count, allocator_arg const & alloc);
.fi

.RE

.SS "spsc_queue public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool push(T const & t);
.fi

.sp
Pushes object t to the ringbuffer\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to push data to the
spsc_queue
.RE
.PP
Postconditions:
.RS 4
object will be pushed to the
spsc_queue, unless it is full\&.
.RE
.PP
Returns:
.RS 4
true, if the push operation is successful\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool pop();
.fi

.sp
Pops one object from ringbuffer\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to pop data to the
spsc_queue
.RE
.PP
Postconditions:
.RS 4
if ringbuffer is not empty, object will be discarded\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if ringbuffer was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename U> 
  boost::enable_if< typename is_convertible< T, U >::type, bool >::type 
  pop(U & ret);
.fi

.sp
Pops one object from ringbuffer\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to pop data to the
spsc_queue
.RE
.PP
Postconditions:
.RS 4
if ringbuffer is not empty, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if ringbuffer was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
size_type push(T const * t, size_type size);
.fi

.sp
Pushes as many objects from the array t as there is space\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to push data to the
spsc_queue
.RE
.PP
Returns:
.RS 4
number of pushed items
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<size_type size> size_type push(T const (&) t);
.fi

.sp
Pushes as many objects from the array t as there is space available\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to push data to the
spsc_queue
.RE
.PP
Returns:
.RS 4
number of pushed items
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename ConstIterator> 
  ConstIterator push(ConstIterator begin, ConstIterator end);
.fi

.sp
Pushes as many objects from the range [begin, end) as there is space \&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to push data to the
spsc_queue
.RE
.PP
Returns:
.RS 4
iterator to the first element, which has not been pushed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
size_type pop(T * ret, size_type size);
.fi

.sp
Pops a maximum of size objects from ringbuffer\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to pop data to the
spsc_queue
.RE
.PP
Returns:
.RS 4
number of popped items
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<size_type size> size_type pop(T(&) ret);
.fi

.sp
Pops a maximum of size objects from
spsc_queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to pop data to the
spsc_queue
.RE
.PP
Returns:
.RS 4
number of popped items
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename OutputIterator> 
  boost::disable_if< typename is_convertible< T, OutputIterator >::type, size_type >::type 
  pop(OutputIterator it);
.fi

.sp
Pops objects to the output iterator it
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only one thread is allowed to pop data to the
spsc_queue
.RE
.PP
Returns:
.RS 4
number of popped items
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename Functor> bool consume_one(Functor & f);
.fi

.sp
consumes one element via a functor
.sp
pops one element from the queue and applies the functor on this object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if one element was consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
template<typename Functor> bool consume_one(Functor const & f);
.fi

.sp
consumes one element via a functor
.sp
pops one element from the queue and applies the functor on this object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if one element was consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
template<typename Functor> size_type consume_all(Functor & f);
.fi

.sp
consumes all elements via a functor
.sp
sequentially pops all elements from the queue and applies the functor on each object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
number of elements that are consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
template<typename Functor> size_type consume_all(Functor const & f);
.fi

.sp
consumes all elements via a functor
.sp
sequentially pops all elements from the queue and applies the functor on each object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
number of elements that are consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
size_type read_available() const;
.fi

.sp
get number of elements that are available for read
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free, should only be called from the consumer thread
.sp .5v
.RE

.PP
Returns:
.RS 4
number of available elements that can be popped from the
spsc_queue
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
size_type write_available() const;
.fi

.sp
get write space to write elements
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free, should only be called from the producer thread
.sp .5v
.RE

.PP
Returns:
.RS 4
number of elements that can be pushed to the
spsc_queue
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
const T & front() const;
.fi

.sp
get reference to element in the front of the queue
.sp
Availability of front element can be checked using read_available()\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only a consuming thread is allowed to check front element
.RE
.PP
Requires:
.RS 4
read_available() > 0\&. If ringbuffer is empty, it\'s undefined behaviour to invoke this method\&.
.RE
.PP
Returns:
.RS 4
reference to the first element in the queue
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
T & front();
.fi

.sp
get reference to element in the front of the queue
.sp
Availability of front element can be checked using read_available()\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and wait\-free
.sp .5v
.RE

.PP
Requires:
.RS 4
only a consuming thread is allowed to check front element
.RE
.PP
Requires:
.RS 4
read_available() > 0\&. If ringbuffer is empty, it\'s undefined behaviour to invoke this method\&.
.RE
.PP
Returns:
.RS 4
reference to the first element in the queue
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
void reset(void);
.fi

.sp
reset the ringbuffer
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not thread\-safe
.sp .5v
.RE

.RE


