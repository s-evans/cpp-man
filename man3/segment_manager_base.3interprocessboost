.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPL" 3 "" "" ""
.SH "NAME"
boost::interprocess::segment_manager_base
.SH "SYNOPSIS"
.\" zero_free_memory: Class template segment_manager_base
.\" Class template segment_manager_base: zero_free_memory
.\" void_pointer: Class template segment_manager_base
.\" Class template segment_manager_base: void_pointer
.\" shrink_to_fit: Class template segment_manager_base
.\" Class template segment_manager_base: shrink_to_fit
.\" segment_manager_base_type: Class template segment_manager_base
.\" Class template segment_manager_base: segment_manager_base_type
.\" segment_manager_base: Class template segment_manager_base
.\" Class template segment_manager_base: segment_manager_base
.\" mutex_family: Class template segment_manager_base
.\" Class template segment_manager_base: mutex_family
.\" memory_algorithm: Class template segment_manager_base
.\" Class template segment_manager_base: memory_algorithm
.\" grow: Class template segment_manager_base
.\" Class template segment_manager_base: grow
.\" get_min_size: Class template segment_manager_base
.\" Class template segment_manager_base: get_min_size
.\" deallocate: Class template segment_manager_base
.\" Class template segment_manager_base: deallocate
.\" check_sanity: Class template segment_manager_base
.\" Class template segment_manager_base: check_sanity
.\" allocate_aligned: Class template segment_manager_base
.\" Class template segment_manager_base: allocate_aligned
.\" allocate: Class template segment_manager_base
.\" Class template segment_manager_base: allocate
.\" all_memory_deallocated: Class template segment_manager_base
.\" Class template segment_manager_base: all_memory_deallocated

.sp
.nf
// In header: <boost/interprocess/segment_manager\&.hpp>

template<typename MemoryAlgorithm> 
class segment_manager_base : private MemoryAlgorithm {
public:
  // types
  typedef segment_manager_base< MemoryAlgorithm > segment_manager_base_type;
  typedef MemoryAlgorithm::void_pointer           void_pointer;             
  typedef MemoryAlgorithm::mutex_family           mutex_family;             
  typedef MemoryAlgorithm                         memory_algorithm;         

  // construct/copy/destruct
  segment_manager_base(size_type, size_type);

  // public member functions
  size_type get_size() const;
  size_type get_free_memory() const;
  void * allocate(size_type, const std::nothrow_t &);
  void * allocate(size_type);
  void * allocate_aligned(size_type, size_type, const std::nothrow_t &);
  void * allocate_aligned(size_type, size_type);
  void deallocate(void *);
  void grow(size_type);
  void shrink_to_fit();
  bool all_memory_deallocated();
  bool check_sanity();
  void zero_free_memory();
  size_type size(const void *) const;

  // public static functions
  static size_type get_min_size(size_type);

  // public data members
  static const size_type PayloadPerAllocation;
};
.fi
.SH "DESCRIPTION"
.PP
This object is the public base class of segment manager\&. This class only depends on the memory allocation algorithm and implements all the allocation features not related to named or unique objects\&.
.PP
Storing a reference to
segment_manager
forces the holder class to be dependent on index types and character types\&. When such dependence is not desirable and only anonymous and raw allocations are needed,
segment_manager_base
is the correct answer\&.
.SS "segment_manager_base public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
segment_manager_base(size_type sz, size_type reserved_bytes);
.fi

.sp
Constructor of the
segment_manager_base
.sp
"size" is the size of the memory segment where the basic segment manager is being constructed\&.
.sp
"reserved_bytes" is the number of bytes after the end of the memory algorithm object itself that the memory algorithm will exclude from dynamic allocation
.sp
Can throw
.RE

.SS "segment_manager_base public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
size_type get_size() const;
.fi

.sp
Returns the size of the memory segment
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
size_type get_free_memory() const;
.fi

.sp
Returns the number of free bytes of the memory segment
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" allocate: Class template segment_manager_base
.\" Class template segment_manager_base: allocate

.sp

.nf
void * allocate(size_type nbytes, const std::nothrow_t &);
.fi

.sp
Allocates nbytes bytes\&. This function is only used in single\-segment management\&. Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" allocate: Class template segment_manager_base
.\" Class template segment_manager_base: allocate

.sp

.nf
void * allocate(size_type nbytes);
.fi

.sp
Allocates nbytes bytes\&. Throws
boost::interprocess::bad_alloc
on failure
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" allocate_aligned: Class template segment_manager_base
.\" Class template segment_manager_base: allocate_aligned

.sp

.nf
void * allocate_aligned(size_type nbytes, size_type alignment, 
                        const std::nothrow_t &);
.fi

.sp
Allocates nbytes bytes\&. This function is only used in single\-segment management\&. Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" allocate_aligned: Class template segment_manager_base
.\" Class template segment_manager_base: allocate_aligned

.sp

.nf
void * allocate_aligned(size_type nbytes, size_type alignment);
.fi

.sp
Allocates nbytes bytes\&. This function is only used in single\-segment management\&. Throws
bad_alloc
when fails
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" deallocate: Class template segment_manager_base
.\" Class template segment_manager_base: deallocate

.sp

.nf
void deallocate(void * addr);
.fi

.sp
Deallocates the bytes allocated with allocate/allocate_many() pointed by addr
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" grow: Class template segment_manager_base
.\" Class template segment_manager_base: grow

.sp

.nf
void grow(size_type extra_size);
.fi

.sp
Increases managed memory in extra_size bytes more\&. This only works with single\-segment management\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" shrink_to_fit: Class template segment_manager_base
.\" Class template segment_manager_base: shrink_to_fit

.sp

.nf
void shrink_to_fit();
.fi

.sp
Decreases managed memory to the minimum\&. This only works with single\-segment management\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" all_memory_deallocated: Class template segment_manager_base
.\" Class template segment_manager_base: all_memory_deallocated

.sp

.nf
bool all_memory_deallocated();
.fi

.sp
Returns the result of "all_memory_deallocated()" function of the used memory algorithm
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" check_sanity: Class template segment_manager_base
.\" Class template segment_manager_base: check_sanity

.sp

.nf
bool check_sanity();
.fi

.sp
Returns the result of "check_sanity()" function of the used memory algorithm
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" zero_free_memory: Class template segment_manager_base
.\" Class template segment_manager_base: zero_free_memory

.sp

.nf
void zero_free_memory();
.fi

.sp
Writes to zero free memory (memory not yet allocated) of the memory algorithm
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
size_type size(const void * ptr) const;
.fi

Returns the size of the buffer previously allocated pointed by ptr\&. .RE

.SS "segment_manager_base public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" get_min_size: Class template segment_manager_base
.\" Class template segment_manager_base: get_min_size

.sp

.nf
static size_type get_min_size(size_type size);
.fi

.sp
Obtains the minimum size needed by the segment manager
.RE

.SS "segment_manager_base public public data members"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static const size_type PayloadPerAllocation;
.fi

.sp
This constant indicates the payload size associated with each allocation of the memory algorithm
.RE


