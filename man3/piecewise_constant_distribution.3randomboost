.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS" 3 "" "" ""
.SH "NAME"
boost::random::piecewise_constant_distribution
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/random/piecewise_constant_distribution\&.hpp>

template<typename RealType = double, typename WeightType = double> 
class piecewise_constant_distribution {
public:
  // types
  typedef std::size_t input_type; 
  typedef RealType    result_type;

  // member classes/structs/unions

  class param_type {
  public:
    // types
    typedef piecewise_constant_distribution distribution_type;

    // construct/copy/destruct
    param_type();
    template<typename IntervalIter, typename WeightIter> 
      param_type(IntervalIter, IntervalIter, WeightIter);
    template<typename T, typename F> 
      param_type(const std::initializer_list< T > &, F);
    template<typename IntervalRange, typename WeightRange> 
      param_type(const IntervalRange &, const WeightRange &);
    template<typename F> param_type(std::size_t, RealType, RealType, F);

    // friend functions
    template<typename CharT, typename Traits> 
      friend std::basic_ostream< CharT, Traits > & 
      operator<<(std::basic_ostream< CharT, Traits > &, const param_type &);
    template<typename CharT, typename Traits> 
      friend std::basic_istream< CharT, Traits > & 
      operator>>(std::basic_istream< CharT, Traits > &, const param_type &);
    friend bool operator==(const param_type &, const param_type &);
    friend bool operator!=(const param_type &, const param_type &);

    // public member functions
    std::vector< RealType > intervals() const;
    std::vector< RealType > densities() const;
  };

  // construct/copy/destruct
  piecewise_constant_distribution();
  template<typename IntervalIter, typename WeightIter> 
    piecewise_constant_distribution(IntervalIter, IntervalIter, WeightIter);
  template<typename T, typename F> 
    piecewise_constant_distribution(std::initializer_list< T >, F);
  template<typename IntervalsRange, typename WeightsRange> 
    piecewise_constant_distribution(const IntervalsRange &, 
                                    const WeightsRange &);
  template<typename F> 
    piecewise_constant_distribution(std::size_t, RealType, RealType, F);
  explicit piecewise_constant_distribution(const param_type &);

  // public member functions
  template<typename URNG> RealType operator()(URNG &) const;
  template<typename URNG> 
    RealType operator()(URNG &, const param_type &) const;
  result_type min() const;
  result_type max() const;
  std::vector< RealType > densities() const;
  std::vector< RealType > intervals() const;
  param_type param() const;
  void param(const param_type &);
  void reset();

  // friend functions
  template<typename CharT, typename Traits> 
    friend std::basic_ostream< CharT, Traits > & 
    operator<<(std::basic_ostream< CharT, Traits > &, 
               const piecewise_constant_distribution &);
  template<typename CharT, typename Traits> 
    friend std::basic_istream< CharT, Traits > & 
    operator>>(std::basic_istream< CharT, Traits > &, 
               const piecewise_constant_distribution &);
  friend bool operator==(const piecewise_constant_distribution &, 
                         const piecewise_constant_distribution &);
  friend bool operator!=(const piecewise_constant_distribution &, 
                         const piecewise_constant_distribution &);
};
.fi
.SH "DESCRIPTION"
.PP
The class
piecewise_constant_distribution
models a
random distribution
\&.
.SS "piecewise_constant_distribution public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
piecewise_constant_distribution();
.fi

.sp
Creates a new
piecewise_constant_distribution
with a single interval, [0, 1)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename IntervalIter, typename WeightIter> 
  piecewise_constant_distribution(IntervalIter first_interval, 
                                  IntervalIter last_interval, 
                                  WeightIter first_weight);
.fi

.sp
Constructs a
piecewise_constant_distribution
from two iterator ranges containing the interval boundaries and the interval weights\&. If there are less than two boundaries, then this is equivalent to the default constructor and creates a single interval, [0, 1)\&.
.sp
The values of the interval boundaries must be strictly increasing, and the number of weights must be one less than the number of interval boundaries\&. If there are extra weights, they are ignored\&.
.sp
For example,
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
double intervals[] = { 0\&.0, 1\&.0, 4\&.0 };
double weights[] = { 1\&.0, 1\&.0 };
piecewise_constant_distribution<> dist(
    &intervals[0], &intervals[0] + 3, &weights[0]);

.fi
.if n \{\
.RE
.\}

.sp
The distribution has a 50% chance of producing a value between 0 and 1 and a 50% chance of producing a value between 1 and 4\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename T, typename F> 
  piecewise_constant_distribution(std::initializer_list< T > il, F f);
.fi

.sp
Constructs a
piecewise_constant_distribution
from an initializer_list containing the interval boundaries and a unary function specifying the weights\&. Each weight is determined by calling the function at the midpoint of the corresponding interval\&.
.sp
If the initializer_list contains less than two elements, this is equivalent to the default constructor and the distribution will produce values uniformly distributed in the range [0, 1)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename IntervalsRange, typename WeightsRange> 
  piecewise_constant_distribution(const IntervalsRange & intervals_arg, 
                                  const WeightsRange & weights_arg);
.fi

.sp
Constructs a
piecewise_constant_distribution
from Boost\&.Range ranges holding the interval boundaries and the weights\&. If there are less than two interval boundaries, this is equivalent to the default constructor and the distribution will produce values uniformly distributed in the range [0, 1)\&. The number of weights must be one less than the number of interval boundaries\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename F> 
  piecewise_constant_distribution(std::size_t nw, RealType xmin, 
                                  RealType xmax, F f);
.fi

.sp
Constructs a
piecewise_constant_distribution
that approximates a function\&. The range of the distribution is [xmin, xmax)\&. This range is divided into nw equally sized intervals and the weights are found by calling the unary function f on the midpoints of the intervals\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
explicit piecewise_constant_distribution(const param_type & param);
.fi

.sp
Constructs a
piecewise_constant_distribution
from its parameters\&.
.RE

.SS "piecewise_constant_distribution public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename URNG> RealType operator()(URNG & urng) const;
.fi

.sp
Returns a value distributed according to the parameters of the piecewist_constant_distribution\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename URNG> 
  RealType operator()(URNG & urng, const param_type & param) const;
.fi

.sp
Returns a value distributed according to the parameters specified by param\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
result_type min() const;
.fi

.sp
Returns the smallest value that the distribution can produce\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
result_type max() const;
.fi

.sp
Returns the largest value that the distribution can produce\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
std::vector< RealType > densities() const;
.fi

.sp
Returns a vector containing the probability density over each interval\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
std::vector< RealType > intervals() const;
.fi

.sp
Returns a vector containing the interval boundaries\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
param_type param() const;
.fi

.sp
Returns the parameters of the distribution\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
void param(const param_type & param);
.fi

.sp
Sets the parameters of the distribution\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
void reset();
.fi

.sp
Effects: Subsequent uses of the distribution do not depend on values produced by any engine prior to invoking reset\&.
.RE

.SS "piecewise_constant_distribution friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename CharT, typename Traits> 
  friend std::basic_ostream< CharT, Traits > & 
  operator<<(std::basic_ostream< CharT, Traits > & os, 
             const piecewise_constant_distribution & pcd);
.fi

.sp
Writes a distribution to a
std::ostream\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename CharT, typename Traits> 
  friend std::basic_istream< CharT, Traits > & 
  operator>>(std::basic_istream< CharT, Traits > & is, 
             const piecewise_constant_distribution & pcd);
.fi

.sp
Reads a distribution from a
std::istream
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator==(const piecewise_constant_distribution & lhs, 
                       const piecewise_constant_distribution & rhs);
.fi

.sp
Returns true if the two distributions will return the same sequence of values, when passed equal generators\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator!=(const piecewise_constant_distribution & lhs, 
                       const piecewise_constant_distribution & rhs);
.fi

.sp
Returns true if the two distributions may return different sequences of values, when passed equal generators\&.
.RE


