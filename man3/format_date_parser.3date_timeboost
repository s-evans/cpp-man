.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::date_time::format_date_parser \- Class with generic date parsing using a format string\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/format_date_parser\&.hpp>

template<typename date_type, typename charT> 
class format_date_parser {
public:
  // types
  typedef std::basic_string< charT >                string_type;          
  typedef std::basic_istringstream< charT >         stringstream_type;    
  typedef std::istreambuf_iterator< charT >         stream_itr_type;      
  typedef string_type::const_iterator               const_itr;            
  typedef date_type::year_type                      year_type;            
  typedef date_type::month_type                     month_type;           
  typedef date_type::day_type                       day_type;             
  typedef date_type::duration_type                  duration_type;        
  typedef date_type::day_of_week_type               day_of_week_type;     
  typedef date_type::day_of_year_type               day_of_year_type;     
  typedef string_parse_tree< charT >                parse_tree_type;      
  typedef parse_tree_type::parse_match_result_type  match_results;        
  typedef std::vector< std::basic_string< charT > > input_collection_type;

  // construct/copy/destruct
  format_date_parser(const string_type &, const input_collection_type &, 
                     const input_collection_type &, 
                     const input_collection_type &, 
                     const input_collection_type &);
  format_date_parser(const string_type &, const std::locale &);
  format_date_parser(const format_date_parser< date_type, charT > &);

  // public member functions
  string_type format() const;
  void format(string_type);
  void short_month_names(const input_collection_type &);
  void long_month_names(const input_collection_type &);
  void short_weekday_names(const input_collection_type &);
  void long_weekday_names(const input_collection_type &);
  date_type parse_date(const string_type &, const string_type &, 
                       const special_values_parser< date_type, charT > &) const;
  date_type parse_date(std::istreambuf_iterator< charT > &, 
                       std::istreambuf_iterator< charT > &, 
                       const special_values_parser< date_type, charT > &) const;
  date_type parse_date(std::istreambuf_iterator< charT > &, 
                       std::istreambuf_iterator< charT > &, string_type, 
                       const special_values_parser< date_type, charT > &) const;
  month_type parse_month(std::istreambuf_iterator< charT > &, 
                         std::istreambuf_iterator< charT > &, string_type) const;
  month_type parse_month(std::istreambuf_iterator< charT > &, 
                         std::istreambuf_iterator< charT > &, string_type, 
                         match_results &) const;
  day_type parse_var_day_of_month(std::istreambuf_iterator< charT > &, 
                                  std::istreambuf_iterator< charT > &) const;
  day_type parse_day_of_month(std::istreambuf_iterator< charT > &, 
                              std::istreambuf_iterator< charT > &) const;
  day_of_week_type 
  parse_weekday(std::istreambuf_iterator< charT > &, 
                std::istreambuf_iterator< charT > &, string_type) const;
  day_of_week_type 
  parse_weekday(std::istreambuf_iterator< charT > &, 
                std::istreambuf_iterator< charT > &, string_type, 
                match_results &) const;
  year_type parse_year(std::istreambuf_iterator< charT > &, 
                       std::istreambuf_iterator< charT > &, string_type) const;
  year_type parse_year(std::istreambuf_iterator< charT > &, 
                       std::istreambuf_iterator< charT > &, string_type, 
                       match_results &) const;
};
.fi
.SH "DESCRIPTION"
.PP
The following is the set of recognized format specifiers
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
a \- Short weekday name
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A \- Long weekday name
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
b \- Abbreviated month name
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
B \- Full month name
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
d \- Day of the month as decimal 01 to 31
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
j \- Day of year as decimal from 001 to 366
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
m \- Month name as a decimal 01 to 12
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
U \- Week number 00 to 53 with first Sunday as the first day of week 1?
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
w \- Weekday as decimal number 0 to 6 where Sunday == 0
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
W \- Week number 00 to 53 where Monday is first day of week 1
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
x \- facet default date representation
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
y \- Year without the century \- eg: 04 for 2004
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Y \- Year with century
.RE
.sp
.RE

.PP
The weekday specifiers (a and A) do not add to the date construction, but they provide a way to skip over the weekday names for formats that provide them\&.
.PP
todo
<ndash></ndash>
Another interesting feature that this approach could provide is an option to fill in any missing fields with the current values from the clock\&. So if you have m\-d the parser would detect the missing year value and fill it in using the clock\&.
.PP
todo
<ndash></ndash>
What to do with the x\&. x in the classic facet is just bad\&.\&.\&.
.SS "format_date_parser public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
format_date_parser(const string_type & format_str, 
                   const input_collection_type & month_short_names, 
                   const input_collection_type & month_long_names, 
                   const input_collection_type & weekday_short_names, 
                   const input_collection_type & weekday_long_names);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
format_date_parser(const string_type & format_str, const std::locale & locale);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
format_date_parser(const format_date_parser< date_type, charT > & fdp);
.fi

.RE

.SS "format_date_parser public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
string_type format() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void format(string_type format_str);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void short_month_names(const input_collection_type & month_names);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void long_month_names(const input_collection_type & month_names);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void short_weekday_names(const input_collection_type & weekday_names);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void long_weekday_names(const input_collection_type & weekday_names);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
date_type parse_date(const string_type & value, 
                     const string_type & format_str, 
                     const special_values_parser< date_type, charT > & sv_parser) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
date_type parse_date(std::istreambuf_iterator< charT > & sitr, 
                     std::istreambuf_iterator< charT > & stream_end, 
                     const special_values_parser< date_type, charT > & sv_parser) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
date_type parse_date(std::istreambuf_iterator< charT > & sitr, 
                     std::istreambuf_iterator< charT > & stream_end, 
                     string_type format_str, 
                     const special_values_parser< date_type, charT > & sv_parser) const;
.fi

.sp
Of all the objects that the
format_date_parser
can parse, only a date can be a special value\&. Therefore, only parse_date checks for special_values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
month_type parse_month(std::istreambuf_iterator< charT > & sitr, 
                       std::istreambuf_iterator< charT > & stream_end, 
                       string_type format_str) const;
.fi

Throws bad_month if unable to parse\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
month_type parse_month(std::istreambuf_iterator< charT > & sitr, 
                       std::istreambuf_iterator< charT > & stream_end, 
                       string_type format_str, match_results & mr) const;
.fi

Throws bad_month if unable to parse\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
day_type parse_var_day_of_month(std::istreambuf_iterator< charT > & sitr, 
                                std::istreambuf_iterator< charT > & stream_end) const;
.fi

Expects 1 or 2 digits 1\-31\&. Throws bad_day_of_month if unable to parse\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
day_type parse_day_of_month(std::istreambuf_iterator< charT > & sitr, 
                            std::istreambuf_iterator< charT > & stream_end) const;
.fi

Expects 2 digits 01\-31\&. Throws bad_day_of_month if unable to parse\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
day_of_week_type 
parse_weekday(std::istreambuf_iterator< charT > & sitr, 
              std::istreambuf_iterator< charT > & stream_end, 
              string_type format_str) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
day_of_week_type 
parse_weekday(std::istreambuf_iterator< charT > & sitr, 
              std::istreambuf_iterator< charT > & stream_end, 
              string_type format_str, match_results & mr) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
year_type parse_year(std::istreambuf_iterator< charT > & sitr, 
                     std::istreambuf_iterator< charT > & stream_end, 
                     string_type format_str) const;
.fi

throws bad_year if unable to parse .RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
year_type parse_year(std::istreambuf_iterator< charT > & sitr, 
                     std::istreambuf_iterator< charT > & stream_end, 
                     string_type format_str, match_results & mr) const;
.fi

throws bad_year if unable to parse .RE


