.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE LIST" 3 "" "" ""
.SH "NAME"
boost::intrusive::list
.SH "SYNOPSIS"
.\" value_type: Class template list
.\" Class template list: value_type
.\" value_traits: Class template list
.\" Class template list: value_traits
.\" unique_and_dispose: Class template list
.\" Class template list: unique_and_dispose
.\" unique: Class template list
.\" Class template list: unique
.\" swap: Class template list
.\" Class template list: swap
.\" splice: Class template list
.\" Class template list: splice
.\" sort: Class template list
.\" Class template list: sort
.\" size_type: Class template list
.\" Class template list: size_type
.\" size: Class template list
.\" Class template list: size
.\" shift_forward: Class template list
.\" Class template list: shift_forward
.\" shift_backwards: Class template list
.\" Class template list: shift_backwards
.\" s_iterator_to: Class template list
.\" Class template list: s_iterator_to
.\" reverse_iterator: Class template list
.\" Class template list: reverse_iterator
.\" reverse: Class template list
.\" Class template list: reverse
.\" rend: Class template list
.\" Class template list: rend
.\" remove_if: Class template list
.\" Class template list: remove_if
.\" remove_and_dispose_if: Class template list
.\" Class template list: remove_and_dispose_if
.\" remove_and_dispose: Class template list
.\" Class template list: remove_and_dispose
.\" remove: Class template list
.\" Class template list: remove
.\" reference: Class template list
.\" Class template list: reference
.\" rbegin: Class template list
.\" Class template list: rbegin
.\" push_front: Class template list
.\" Class template list: push_front
.\" push_back: Class template list
.\" Class template list: push_back
.\" pop_front_and_dispose: Class template list
.\" Class template list: pop_front_and_dispose
.\" pop_front: Class template list
.\" Class template list: pop_front
.\" pop_back_and_dispose: Class template list
.\" Class template list: pop_back_and_dispose
.\" pop_back: Class template list
.\" Class template list: pop_back
.\" pointer: Class template list
.\" Class template list: pointer
.\" node_traits: Class template list
.\" Class template list: node_traits
.\" node_ptr: Class template list
.\" Class template list: node_ptr
.\" node_algorithms: Class template list
.\" Class template list: node_algorithms
.\" node: Class template list
.\" Class template list: node
.\" merge: Class template list
.\" Class template list: merge
.\" iterator_to: Class template list
.\" Class template list: iterator_to
.\" iterator: Class template list
.\" Class template list: iterator
.\" insert: Class template list
.\" Class template list: insert
.\" header_holder_type: Class template list
.\" Class template list: header_holder_type
.\" front: Class template list
.\" Class template list: front
.\" erase_and_dispose: Class template list
.\" Class template list: erase_and_dispose
.\" erase: Class template list
.\" Class template list: erase
.\" end: Class template list
.\" Class template list: end
.\" dispose_and_assign: Class template list
.\" Class template list: dispose_and_assign
.\" difference_type: Class template list
.\" Class template list: difference_type
.\" container_from_end_iterator: Class template list
.\" Class template list: container_from_end_iterator
.\" const_reverse_iterator: Class template list
.\" Class template list: const_reverse_iterator
.\" const_reference: Class template list
.\" Class template list: const_reference
.\" const_pointer: Class template list
.\" Class template list: const_pointer
.\" const_node_ptr: Class template list
.\" Class template list: const_node_ptr
.\" const_iterator: Class template list
.\" Class template list: const_iterator
.\" clone_from: Class template list
.\" Class template list: clone_from
.\" clear_and_dispose: Class template list
.\" Class template list: clear_and_dispose
.\" clear: Class template list
.\" Class template list: clear
.\" check: Class template list
.\" Class template list: check
.\" cend: Class template list
.\" Class template list: cend
.\" cbegin: Class template list
.\" Class template list: cbegin
.\" begin: Class template list
.\" Class template list: begin
.\" back: Class template list
.\" Class template list: back
.\" assign: Class template list
.\" Class template list: assign

.sp
.nf
// In header: <boost/intrusive/list\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class list {
public:
  // types
  typedef ValueTraits                                          value_traits;          
  typedef value_traits::pointer                                pointer;               
  typedef value_traits::const_pointer                          const_pointer;         
  typedef pointer_traits< pointer >::element_type              value_type;            
  typedef pointer_traits< pointer >::reference                 reference;             
  typedef pointer_traits< const_pointer >::reference           const_reference;       
  typedef pointer_traits< pointer >::difference_type           difference_type;       
  typedef SizeType                                             size_type;             
  typedef list_iterator< value_traits, false >                 iterator;              
  typedef list_iterator< value_traits, true >                  const_iterator;        
  typedef boost::intrusive::reverse_iterator< iterator >       reverse_iterator;      
  typedef boost::intrusive::reverse_iterator< const_iterator > const_reverse_iterator;
  typedef value_traits::node_traits                            node_traits;           
  typedef node_traits::node                                    node;                  
  typedef node_traits::node_ptr                                node_ptr;              
  typedef node_traits::const_node_ptr                          const_node_ptr;        
  typedef circular_list_algorithms< node_traits >              node_algorithms;       
  typedef \fIunspecified\fR                                          header_holder_type;    

  // construct/copy/destruct
  explicit list(const value_traits & = value_traits());
  template<typename Iterator> 
    list(Iterator, Iterator, const value_traits & = value_traits());
  list(list &&);
  list & operator=(list &&);
  ~list();

  // public member functions
  void push_back(reference);
  void push_front(reference);
  void pop_back();
  template<typename Disposer> void pop_back_and_dispose(Disposer);
  void pop_front();
  template<typename Disposer> void pop_front_and_dispose(Disposer);
  reference front();
  const_reference front() const;
  reference back();
  const_reference back() const;
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  reverse_iterator rbegin();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator crbegin() const;
  reverse_iterator rend();
  const_reverse_iterator rend() const;
  const_reverse_iterator crend() const;
  size_type size() const;
  bool empty() const;
  void swap(list &);
  void shift_backwards(size_type = 1);
  void shift_forward(size_type = 1);
  iterator erase(const_iterator);
  iterator erase(const_iterator, const_iterator);
  iterator erase(const_iterator, const_iterator, size_type);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, const_iterator, Disposer);
  void clear();
  template<typename Disposer> void clear_and_dispose(Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(const list &, Cloner, Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(list &&, Cloner, Disposer);
  iterator insert(const_iterator, reference);
  template<typename Iterator> void insert(const_iterator, Iterator, Iterator);
  template<typename Iterator> void assign(Iterator, Iterator);
  template<typename Iterator, typename Disposer> 
    void dispose_and_assign(Disposer, Iterator, Iterator);
  void splice(const_iterator, list &);
  void splice(const_iterator, list &, const_iterator);
  void splice(const_iterator, list &, const_iterator, const_iterator);
  void splice(const_iterator, list &, const_iterator, const_iterator, 
              size_type);
  void sort();
  template<typename Predicate> void sort(Predicate);
  void merge(list &);
  template<typename Predicate> void merge(list &, Predicate);
  void reverse();
  void remove(const_reference);
  template<typename Disposer> 
    void remove_and_dispose(const_reference, Disposer);
  template<typename Pred> void remove_if(Pred);
  template<typename Pred, typename Disposer> 
    void remove_and_dispose_if(Pred, Disposer);
  void unique();
  template<typename BinaryPredicate> void unique(BinaryPredicate);
  template<typename Disposer> void unique_and_dispose(Disposer);
  template<typename BinaryPredicate, typename Disposer> 
    void unique_and_dispose(BinaryPredicate, Disposer);
  iterator iterator_to(reference);
  const_iterator iterator_to(const_reference) const;
  void check() const;

  // public static functions
  static list & container_from_end_iterator(iterator);
  static const list & container_from_end_iterator(const_iterator);
  static iterator s_iterator_to(reference);
  static const_iterator s_iterator_to(const_reference);

  // public data members
  static const bool constant_time_size;
  static const bool stateful_value_traits;
  static const bool has_container_from_iterator;
};
.fi
.SH "DESCRIPTION"
.PP
The class template list is an intrusive container that mimics most of the interface of std::list as described in the C++ standard\&.
.PP
The template parameter
T
is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
base_hook<>/member_hook<>/value_traits<>,
constant_time_size<>
and
size_type<>\&.
.SS "list public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit list(const value_traits & v_traits = value_traits());
.fi

.sp
\fBEffects\fR: constructs an empty list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" distance: Class template list
.\" Class template list: distance

.sp

.nf
template<typename Iterator> 
  list(Iterator b, Iterator e, const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Constructs a list equal to the range [first,last)\&.
.sp
\fBComplexity\fR: Linear in distance(b, e)\&. No copy constructors are called\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
list(list && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
list & operator=(list && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~list();
.fi

.sp
\fBEffects\fR: If it\'s not a safe\-mode or an auto\-unlink value_type the destructor does nothing (ie\&. no code is generated)\&. Otherwise it detaches all elements from this\&. In this case the objects in the list are not deleted (i\&.e\&. no destructors are called), but the hooks according to the ValueTraits template parameter are set to their default value\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the list, if it\'s a safe\-mode or auto\-unlink value \&. Otherwise constant\&.
.RE

.SS "list public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" push_back: Class template list
.\" Class template list: push_back

.sp

.nf
void push_back(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue\&.
.sp
\fBEffects\fR: Inserts the value in the back of the list\&. No copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" push_front: Class template list
.\" Class template list: push_front

.sp

.nf
void push_front(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue\&.
.sp
\fBEffects\fR: Inserts the value in the front of the list\&. No copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" pop_back: Class template list
.\" Class template list: pop_back

.sp

.nf
void pop_back();
.fi

.sp
\fBEffects\fR: Erases the last element of the list\&. No destructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" pop_back_and_dispose: Class template list
.\" Class template list: pop_back_and_dispose

.sp

.nf
template<typename Disposer> void pop_back_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the last element of the list\&. No destructors are called\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" pop_front: Class template list
.\" Class template list: pop_front

.sp

.nf
void pop_front();
.fi

.sp
\fBEffects\fR: Erases the first element of the list\&. No destructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" pop_front_and_dispose: Class template list
.\" Class template list: pop_front_and_dispose

.sp

.nf
template<typename Disposer> void pop_front_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the first element of the list\&. No destructors are called\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" front: Class template list
.\" Class template list: front

.sp

.nf
reference front();
.fi

.sp
\fBEffects\fR: Returns a reference to the first element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" front: Class template list
.\" Class template list: front

.sp

.nf
const_reference front() const;
.fi

.sp
\fBEffects\fR: Returns a const_reference to the first element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" back: Class template list
.\" Class template list: back

.sp

.nf
reference back();
.fi

.sp
\fBEffects\fR: Returns a reference to the last element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" back: Class template list
.\" Class template list: back

.sp

.nf
const_reference back() const;
.fi

.sp
\fBEffects\fR: Returns a const_reference to the last element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" begin: Class template list
.\" Class template list: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" begin: Class template list
.\" Class template list: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" cbegin: Class template list
.\" Class template list: cbegin

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" end: Class template list
.\" Class template list: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" end: Class template list
.\" Class template list: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" cend: Class template list
.\" Class template list: cend

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a constant iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" rbegin: Class template list
.\" Class template list: rbegin

.sp

.nf
reverse_iterator rbegin();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" rbegin: Class template list
.\" Class template list: rbegin

.sp

.nf
const_reverse_iterator rbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" rend: Class template list
.\" Class template list: rend

.sp

.nf
reverse_iterator rend();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" rend: Class template list
.\" Class template list: rend

.sp

.nf
const_reverse_iterator rend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" size: Class template list
.\" Class template list: size

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements contained in the list\&. if constant\-time size option is disabled\&. Constant time otherwise\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the list contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" swap: Class template list
.\" Class template list: swap

.sp

.nf
void swap(list & other);
.fi

.sp
\fBEffects\fR: Swaps the elements of x and *this\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" shift_backwards: Class template list
.\" Class template list: shift_backwards

.sp

.nf
void shift_backwards(size_type n = 1);
.fi

.sp
\fBEffects\fR: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third\&.\&.\&. the last element becomes the first one\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of shifts\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" shift_forward: Class template list
.\" Class template list: shift_forward

.sp

.nf
void shift_forward(size_type n = 1);
.fi

.sp
\fBEffects\fR: Moves forward all the elements, so that the second element becomes the first, the third becomes the second\&.\&.\&. the first element becomes the last one\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of shifts\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" end: Class template list
.\" Class template list: end
.\" erase: Class template list
.\" Class template list: erase

.sp

.nf
iterator erase(const_iterator i);
.fi

.sp
\fBEffects\fR: Erases the element pointed by i of the list\&. No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed element, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" end: Class template list
.\" Class template list: end
.\" erase: Class template list
.\" Class template list: erase

.sp

.nf
iterator erase(const_iterator b, const_iterator e);
.fi

.sp
\fBRequires\fR: b and e must be valid iterators to elements in *this\&.
.sp
\fBEffects\fR: Erases the element range pointed by b and e No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of erased elements if it\'s a safe\-mode or auto\-unlink value, or constant\-time size is enabled\&. Constant\-time otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" end: Class template list
.\" Class template list: end
.\" distance: Class template list
.\" Class template list: distance
.\" erase: Class template list
.\" Class template list: erase

.sp

.nf
iterator erase(const_iterator b, const_iterator e, size_type n);
.fi

.sp
\fBRequires\fR: b and e must be valid iterators to elements in *this\&. n must be distance(b, e)\&.
.sp
\fBEffects\fR: Erases the element range pointed by b and e No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of erased elements if it\'s a safe\-mode or auto\-unlink value is enabled\&. Constant\-time otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" end: Class template list
.\" Class template list: end
.\" erase_and_dispose: Class template list
.\" Class template list: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator i, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element pointed by i of the list\&. No destructors are called\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed element, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" end: Class template list
.\" Class template list: end
.\" erase_and_dispose: Class template list
.\" Class template list: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator b, const_iterator e, 
                             Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element range pointed by b and e No destructors are called\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements erased\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" clear: Class template list
.\" Class template list: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all the elements of the container\&. No destructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements of the list\&. if it\'s a safe\-mode or auto\-unlink value_type\&. Constant time otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" clear_and_dispose: Class template list
.\" Class template list: clear_and_dispose

.sp

.nf
template<typename Disposer> void clear_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements of the container\&. No destructors are called\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements of the list\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" clone_from: Class template list
.\" Class template list: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(const list & src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" clone_from: Class template list
.\" Class template list: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(list && src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" insert: Class template list
.\" Class template list: insert

.sp

.nf
iterator insert(const_iterator p, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts the value before the position pointed by p\&.
.sp
\fBReturns\fR: An iterator to the inserted element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&. No copy constructors are called\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" insert: Class template list
.\" Class template list: insert

.sp

.nf
template<typename Iterator> 
  void insert(const_iterator p, Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type and p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts the range pointed by b and e before the position p\&. No copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" assign: Class template list
.\" Class template list: assign

.sp

.nf
template<typename Iterator> void assign(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Clears the list and inserts the range pointed by b and e\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted plus linear to the elements contained in the list if it\'s a safe\-mode or auto\-unlink value\&. Linear to the number of elements inserted in the list otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" dispose_and_assign: Class template list
.\" Class template list: dispose_and_assign

.sp

.nf
template<typename Iterator, typename Disposer> 
  void dispose_and_assign(Disposer disposer, Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Clears the list and inserts the range pointed by b and e\&. No destructors or copy constructors are called\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted plus linear to the elements contained in the list\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" splice: Class template list
.\" Class template list: splice

.sp

.nf
void splice(const_iterator p, list & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" splice: Class template list
.\" Class template list: splice

.sp

.nf
void splice(const_iterator p, list & x, const_iterator new_ele);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&. new_ele must point to an element contained in list x\&.
.sp
\fBEffects\fR: Transfers the value pointed by new_ele, from list x to this list, before the element pointed by p\&. No destructors or copy constructors are called\&. If p == new_ele or p == ++new_ele, this function is a null operation\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" splice: Class template list
.\" Class template list: splice

.sp

.nf
void splice(const_iterator p, list & x, const_iterator f, const_iterator e);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&. f and e must point to elements contained in list x\&.
.sp
\fBEffects\fR: Transfers the range pointed by f and e from list x to this list, before the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements transferred if constant\-time size option is enabled\&. Constant\-time otherwise\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" splice: Class template list
.\" Class template list: splice

.sp

.nf
void splice(const_iterator p, list & x, const_iterator f, const_iterator e, 
            size_type n);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&. f and e must point to elements contained in list x\&. n == distance(f, e)
.sp
\fBEffects\fR: Transfers the range pointed by f and e from list x to this list, before the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" sort: Class template list
.\" Class template list: sort

.sp

.nf
void sort();
.fi

.sp
\fBEffects\fR: This function sorts the list *this according to std::less<value_type>\&. The sort is stable, that is, the relative order of equivalent elements is preserved\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or std::less<value_type> throws\&. Basic guarantee\&.
.sp
\fBNotes\fR: Iterators and references are not invalidated\&.
.sp
\fBComplexity\fR: The number of comparisons is approximately N log N, where N is the list\'s size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" sort: Class template list
.\" Class template list: sort

.sp

.nf
template<typename Predicate> void sort(Predicate p);
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering
.sp
\fBEffects\fR: This function sorts the list *this according to p\&. The sort is stable, that is, the relative order of equivalent elements is preserved\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the predicate throws\&. Basic guarantee\&.
.sp
\fBNotes\fR: This won\'t throw if list_base_hook<> or
list_member_hook
are used\&. Iterators and references are not invalidated\&.
.sp
\fBComplexity\fR: The number of comparisons is approximately N log N, where N is the list\'s size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" size: Class template list
.\" Class template list: size
.\" merge: Class template list
.\" Class template list: merge

.sp

.nf
void merge(list & x);
.fi

.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this according to std::less<value_type>\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If std::less<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references are not invalidated
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" size: Class template list
.\" Class template list: size
.\" merge: Class template list
.\" Class template list: merge

.sp

.nf
template<typename Predicate> void merge(list & x, Predicate p);
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If the predicate throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" reverse: Class template list
.\" Class template list: reverse

.sp

.nf
void reverse();
.fi

.sp
\fBEffects\fR: Reverses the order of elements in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: This function is linear time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" size: Class template list
.\" Class template list: size
.\" remove: Class template list
.\" Class template list: remove

.sp

.nf
void remove(const_reference value);
.fi

.sp
\fBEffects\fR: Removes all the elements that compare equal to value\&. No destructors are called\&.
.sp
\fBThrows\fR: If std::equal_to<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" size: Class template list
.\" Class template list: size
.\" remove_and_dispose: Class template list
.\" Class template list: remove_and_dispose

.sp

.nf
template<typename Disposer> 
  void remove_and_dispose(const_reference value, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes all the elements that compare equal to value\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If std::equal_to<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" size: Class template list
.\" Class template list: size
.\" remove_if: Class template list
.\" Class template list: remove_if

.sp

.nf
template<typename Pred> void remove_if(Pred pred);
.fi

.sp
\fBEffects\fR: Removes all the elements for which a specified predicate is satisfied\&. No destructors are called\&.
.sp
\fBThrows\fR: If pred throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() calls to the predicate\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" size: Class template list
.\" Class template list: size
.\" remove_and_dispose_if: Class template list
.\" Class template list: remove_and_dispose_if

.sp

.nf
template<typename Pred, typename Disposer> 
  void remove_and_dispose_if(Pred pred, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes all the elements for which a specified predicate is satisfied\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If pred throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" unique: Class template list
.\" Class template list: unique

.sp

.nf
void unique();
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that are equal from the list\&. No destructors are called\&.
.sp
\fBThrows\fR: If std::equal_to<value_type throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1 comparisons calls to pred())\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" unique: Class template list
.\" Class template list: unique

.sp

.nf
template<typename BinaryPredicate> void unique(BinaryPredicate pred);
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list\&. No destructors are called\&.
.sp
\fBThrows\fR: If pred throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1 comparisons equality comparisons)\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" unique_and_dispose: Class template list
.\" Class template list: unique_and_dispose

.sp

.nf
template<typename Disposer> void unique_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that are equal from the list\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If std::equal_to<value_type throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1) comparisons equality comparisons\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" unique_and_dispose: Class template list
.\" Class template list: unique_and_dispose

.sp

.nf
template<typename BinaryPredicate, typename Disposer> 
  void unique_and_dispose(BinaryPredicate pred, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If pred throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1) comparisons equality comparisons\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" iterator_to: Class template list
.\" Class template list: iterator_to

.sp

.nf
iterator iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be a reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns a const_iterator pointing to the element
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" iterator_to: Class template list
.\" Class template list: iterator_to

.sp

.nf
const_iterator iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be a const reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns an iterator pointing to the element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" check: Class template list
.\" Class template list: check

.sp

.nf
void check() const;
.fi

.sp
\fBEffects\fR: Asserts the integrity of the container\&.
.sp
\fBComplexity\fR: Linear time\&.
.sp
\fBNote\fR: The method has no effect when asserts are turned off (e\&.g\&., with NDEBUG)\&. Experimental function, interface might change in future versions\&.
.RE

.SS "list public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" container_from_end_iterator: Class template list
.\" Class template list: container_from_end_iterator

.sp

.nf
static list & container_from_end_iterator(iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end iterator of list\&.
.sp
\fBEffects\fR: Returns a const reference to the list associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" container_from_end_iterator: Class template list
.\" Class template list: container_from_end_iterator

.sp

.nf
static const list & container_from_end_iterator(const_iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end const_iterator of list\&.
.sp
\fBEffects\fR: Returns a const reference to the list associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" s_iterator_to: Class template list
.\" Class template list: s_iterator_to

.sp

.nf
static iterator s_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be a reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns a const_iterator pointing to the element
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&. This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" s_iterator_to: Class template list
.\" Class template list: s_iterator_to

.sp

.nf
static const_iterator s_iterator_to(const_reference value);
.fi

.sp
\fBRequires\fR: value must be a const reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns an iterator pointing to the element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&. This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


