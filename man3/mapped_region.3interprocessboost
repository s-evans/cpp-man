.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS MAPPED_REGION" 3 "" "" ""
.SH "NAME"
boost::interprocess::mapped_region
.SH "SYNOPSIS"
.\" swap: Class mapped_region
.\" Class mapped_region: swap
.\" shrink_by: Class mapped_region
.\" Class mapped_region: shrink_by
.\" mapped_region: Class mapped_region
.\" Class mapped_region: mapped_region
.\" mapped_region: Class mapped_region
.\" Class mapped_region: mapped_region
.\" get_page_size: Class mapped_region
.\" Class mapped_region: get_page_size
.\" flush: Class mapped_region
.\" Class mapped_region: flush
.\" advise: Class mapped_region
.\" Class mapped_region: advise

.sp
.nf
// In header: <boost/interprocess/mapped_region\&.hpp>


class mapped_region {
public:
  enum advice_types;
  // construct/copy/destruct
  template<typename MemoryMappable> 
    mapped_region(const MemoryMappable &, mode_t, offset_t = 0, 
                  std::size_t = 0, const void * = 0, 
                  map_options_t = default_map_options);
  mapped_region();
  mapped_region(mapped_region &&);
  mapped_region & operator=(mapped_region &&);
  ~mapped_region();

  // public member functions
  void swap(mapped_region &);
  std::size_t get_size() const;
  void * get_address() const;
  mode_t get_mode() const;
  bool flush(std::size_t = 0, std::size_t = 0, bool = true);
  bool shrink_by(std::size_t, bool = true);
  bool advise(advice_types);

  // public static functions
  static std::size_t get_page_size();
};
.fi
.SH "DESCRIPTION"
.PP
The
mapped_region
class represents a portion or region created from a memory_mappable object\&.
.PP
The OS can map a region bigger than the requested one, as region must be multiple of the page size, but
mapped_region
will always refer to the region specified by the user\&.
.SS "mapped_region public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" mapped_region: Class mapped_region
.\" Class mapped_region: mapped_region

.sp

.nf
template<typename MemoryMappable> 
  mapped_region(const MemoryMappable & mapping, mode_t mode, 
                offset_t offset = 0, std::size_t size = 0, 
                const void * address = 0, 
                map_options_t map_options = default_map_options);
.fi

.sp
Creates a mapping region of the mapped memory "mapping", starting in offset "offset", and the mapping\'s size will be "size"\&. The mapping can be opened for read only, read\-write or copy\-on\-write\&.
.sp
If an address is specified, both the offset and the address must be multiples of the page size\&.
.sp
The map is created using "default_map_options"\&. This flag is OS dependant and it should not be changed unless the user needs to specify special options\&.
.sp
In Windows systems "map_options" is a DWORD value passed as "dwDesiredAccess" to "MapViewOfFileEx"\&. If "default_map_options" is passed it\'s initialized to zero\&. "map_options" is XORed with FILE_MAP_[COPY|READ|WRITE]\&.
.sp
In UNIX systems and POSIX mappings "map_options" is an int value passed as "flags" to "mmap"\&. If "default_map_options" is specified it\'s initialized to MAP_NOSYNC if that option exists and to zero otherwise\&. "map_options" XORed with MAP_PRIVATE or MAP_SHARED\&.
.sp
In UNIX systems and XSI mappings "map_options" is an int value passed as "shmflg" to "shmat"\&. If "default_map_options" is specified it\'s initialized to zero\&. "map_options" is XORed with SHM_RDONLY if needed\&.
.sp
The OS could allocate more pages than size/page_size(), but get_address() will always return the address passed in this function (if not null) and get_size() will return the specified size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
mapped_region();
.fi

.sp
Default constructor\&. Address will be 0 (nullptr)\&. Size will be 0\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
mapped_region(mapped_region && other);
.fi

.sp
Move constructor\&. *this will be constructed taking ownership of "other"\'s region and "other" will be left in default constructor state\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
mapped_region & operator=(mapped_region && other);
.fi

.sp
Move assignment\&. If *this owns a memory mapped region, it will be destroyed and it will take ownership of "other"\'s memory mapped region\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~mapped_region();
.fi

.sp
Destroys the mapped region\&. Does not throw
.RE

.SS "mapped_region public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" swap: Class mapped_region
.\" Class mapped_region: swap

.sp

.nf
void swap(mapped_region & other);
.fi

.sp
Swaps the
mapped_region
with another mapped region
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
std::size_t get_size() const;
.fi

Returns the size of the mapping\&. Never throws\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void * get_address() const;
.fi

.sp
Returns the base address of the mapping\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
mode_t get_mode() const;
.fi

.sp
Returns the mode of the mapping used to construct the mapped region\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" flush: Class mapped_region
.\" Class mapped_region: flush

.sp

.nf
bool flush(std::size_t mapping_offset = 0, std::size_t numbytes = 0, 
           bool async = true);
.fi

.sp
Flushes to the disk a byte range within the mapped memory\&. If \'async\' is true, the function will return before flushing operation is completed If \'async\' is false, function will return once data has been written into the underlying device (i\&.e\&., in mapped files OS cached information is written to disk)\&. Never throws\&. Returns false if operation could not be performed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" shrink_by: Class mapped_region
.\" Class mapped_region: shrink_by

.sp

.nf
bool shrink_by(std::size_t bytes, bool from_back = true);
.fi

.sp
Shrinks current mapped region\&. If after shrinking there is no longer need for a previously mapped memory page, accessing that page can trigger a segmentation fault\&. Depending on the OS, this operation might fail (XSI shared memory), it can decommit storage and free a portion of the virtual address space (e\&.g\&.POSIX) or this function can release some physical memory wihout freeing any virtual address space(Windows)\&. Returns true on success\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" advise: Class mapped_region
.\" Class mapped_region: advise

.sp

.nf
bool advise(advice_types advise);
.fi

.sp
Advises the implementation on the expected behavior of the application with respect to the data in the region\&. The implementation may use this information to optimize handling of the region data\&. This function has no effect on the semantics of access to memory in the region, although it may affect the performance of access\&. If the advise type is not known to the implementation, the function returns false\&. True otherwise\&.
.RE

.SS "mapped_region public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" get_page_size: Class mapped_region
.\" Class mapped_region: get_page_size

.sp

.nf
static std::size_t get_page_size();
.fi

.sp
Returns the size of the page\&. This size is the minimum memory that will be used by the system when mapping a memory mappable source and will restrict the address and the offset to map\&.
.RE


