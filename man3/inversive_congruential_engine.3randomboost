.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS " 3 "" "" ""
.SH "NAME"
boost::random::inversive_congruential_engine
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/random/inversive_congruential\&.hpp>

template<typename IntType, IntType a, IntType b, IntType p> 
class inversive_congruential_engine {
public:
  // types
  typedef IntType result_type;

  // construct/copy/destruct
  inversive_congruential_engine();
  explicit inversive_congruential_engine(IntType);
  template<typename SeedSeq> explicit inversive_congruential_engine(SeedSeq &);
  template<typename It> inversive_congruential_engine(It &, It);

  // public static functions
  static result_type min();
  static result_type max();

  // public member functions
  void seed();
  void seed(IntType);
  template<typename SeedSeq> void seed(SeedSeq &);
  template<typename It> void seed(It &, It);
  IntType operator()();
  template<typename Iter> void generate(Iter, Iter);
  void discard(boost::uintmax_t);

  // friend functions
  template<typename CharT, typename Traits> 
    friend std::basic_ostream< CharT, Traits > & 
    operator<<(std::basic_ostream< CharT, Traits > &, 
               const inversive_congruential_engine &);
  template<typename CharT, typename Traits> 
    friend std::basic_istream< CharT, Traits > & 
    operator>>(std::basic_istream< CharT, Traits > &, 
               const inversive_congruential_engine &);
  friend bool operator==(const inversive_congruential_engine &, 
                         const inversive_congruential_engine &);
  friend bool operator!=(const inversive_congruential_engine &, 
                         const inversive_congruential_engine &);

  // public data members
  static const bool has_fixed_range;
  static const result_type multiplier;
  static const result_type increment;
  static const result_type modulus;
  static const IntType default_seed;
};
.fi
.SH "DESCRIPTION"
.PP
Instantiations of class template
inversive_congruential_engine
model a
pseudo\-random number generator
\&. It uses the inversive congruential algorithm (ICG) described in
.PP

.PP "Inversive pseudorandom number generators: concepts, results and links", Peter Hellekalek, In: "Proceedings of the 1995 Winter Simulation Conference", C\&. Alexopoulos, K\&. Kang, W\&.R\&. Lilegdon, and D\&. Goldsman (editors), 1995, pp\&. 255\-262\&. \m[blue]\fBftp://random\&.mat\&.sbg\&.ac\&.at/pub/data/wsc95\&.ps\fR\m[]
.PP
The output sequence is defined by x(n+1) = (a*inv(x(n)) \- b) (mod p), where x(0), a, b, and the prime number p are parameters of the generator\&. The expression inv(k) denotes the multiplicative inverse of k in the field of integer numbers modulo p, with inv(0) := 0\&.
.PP
The template parameter IntType shall denote a signed integral type large enough to hold p; a, b, and p are the parameters of the generators\&. The template parameter val is the validation value checked by validation\&.
.PP

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
The implementation currently uses the Euclidian Algorithm to compute the multiplicative inverse\&. Therefore, the inversive generators are about 10\-20 times slower than the others (see section"performance")\&. However, the paper talks of only 3x slowdown, so the Euclidian Algorithm is probably not optimal for calculating the multiplicative inverse\&.
.sp .5v
.RE

.SS "inversive_congruential_engine public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
inversive_congruential_engine();
.fi

.sp
Constructs an
inversive_congruential_engine, seeding it with the default seed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit inversive_congruential_engine(IntType x0);
.fi

.sp
Constructs an
inversive_congruential_engine, seeding it with
x0\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename SeedSeq> 
  explicit inversive_congruential_engine(SeedSeq & seq);
.fi

.sp
Constructs an
inversive_congruential_engine, seeding it with values produced by a call to
seq\&.generate()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename It> inversive_congruential_engine(It & first, It last);
.fi

.sp
Constructs an
inversive_congruential_engine, seeds it with values taken from the itrator range [first, last), and adjusts first to point to the element after the last one used\&. If there are not enough elements, throws
std::invalid_argument\&.
.sp
first and last must be input iterators\&.
.RE

.SS "inversive_congruential_engine public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static result_type min();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static result_type max();
.fi

.RE

.SS "inversive_congruential_engine public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void seed();
.fi

.sp
Calls seed(default_seed)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void seed(IntType x0);
.fi

.sp
If c mod m is zero and x0 mod m is zero, changes the current value of the generator to 1\&. Otherwise, changes it to x0 mod m\&. If c is zero, distinct seeds in the range [1,m) will leave the generator in distinct states\&. If c is not zero, the range is [0,m)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename SeedSeq> void seed(SeedSeq & seq);
.fi

.sp
Seeds an
inversive_congruential_engine
using values from a SeedSeq\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename It> void seed(It & first, It last);
.fi

.sp
seeds an
inversive_congruential_engine
with values taken from the itrator range [first, last) and adjusts
first
to point to the element after the last one used\&. If there are not enough elements, throws
std::invalid_argument\&.
.sp
first
and
last
must be input iterators\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
IntType operator()();
.fi

.sp
Returns the next output of the generator\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename Iter> void generate(Iter first, Iter last);
.fi

.sp
Fills a range with random values
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
void discard(boost::uintmax_t z);
.fi

.sp
Advances the state of the generator by
z\&.
.RE

.SS "inversive_congruential_engine friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename CharT, typename Traits> 
  friend std::basic_ostream< CharT, Traits > & 
  operator<<(std::basic_ostream< CharT, Traits > & os, 
             const inversive_congruential_engine & x);
.fi

.sp
Writes the textual representation of the generator to a
std::ostream\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename CharT, typename Traits> 
  friend std::basic_istream< CharT, Traits > & 
  operator>>(std::basic_istream< CharT, Traits > & is, 
             const inversive_congruential_engine & x);
.fi

.sp
Reads the textual representation of the generator from a
std::istream\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator==(const inversive_congruential_engine & x, 
                       const inversive_congruential_engine & y);
.fi

.sp
Returns true if the two generators will produce identical sequences of outputs\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator!=(const inversive_congruential_engine & lhs, 
                       const inversive_congruential_engine & rhs);
.fi

.sp
Returns true if the two generators will produce different sequences of outputs\&.
.RE


