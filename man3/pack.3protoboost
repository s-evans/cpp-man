.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT PACK" 3 "" "" ""
.SH "NAME"
boost::proto::pack \- To turn an expression into a pseudo\-parameter pack containing the expression\'s children, for the purpose of expanding the pack expression within a CallableTransform or ObjectTransform\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/transform/impl\&.hpp>


struct pack {
};
.fi
.SH "DESCRIPTION"
.PP

proto::pack
is useful within
CallableTransforms and
ObjectTransforms when one wishes to unpack an expression into a function call or an object constructor\&.
proto::pack
turns a Proto expression into a pseudo\-parameter pack, which may appear in an unpacking pattern to be expanded with the "\&.\&.\&." syntax\&.
.PP

\fBExample:\fR
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
// The following demonstrates how to use a pseudo\-pack expansion
// to unpack an expression into a function call\&.

struct do_sum : proto::callable
{
    typedef int result_type;
    
    int operator()(int i) const { return i; }
    int operator()(int i, int j) const { return i + j; }
    int operator()(int i, int j, int k) const { return i + j + k; }
};

// Take any n\-ary expression where the children are all int terminals and sum all the ints
struct sum
  : proto::when<
  
        // Match any nary expression where the children are all int terminals
        proto::nary_expr<_, proto::vararg<proto::terminal<int> > >

        // Turn the current expression into a pseudo\-parameter pack, then expand it,
        // extracting the value from each child in turn\&.
      , do_sum(proto::_value(proto::pack(_))\&.\&.\&.)
    >
{};

int main()
{
    proto::terminal<int>::type i = {42};
    int result = sum()( i(3,5) ); // Creates a ternary functional\-call expression
    std::cout << "Sum of 42, 3, and 5 : " << result << std::endl;
}
.fi
.if n \{\
.RE
.\}
.sp

.PP
The above program displays:
.PP

Sum of 42, 3, and 5 : 50
.PP
In the above example, the type
proto::_value(proto::pack(_))
is a so\-called
\fIunpacking pattern\fR, described below\&.
.PP

\fBUnpacking Patterns:\fR
.PP
Composite transforms (either
CallableTransforms or
ObjectTransforms) usually have the form
X(A0,&#8230;An)\&. However, when the argument list in a composite transform is terminated with a C\-style vararg ellipsis as in
X(A0,&#8230;An \&.\&.\&.), the final argument
An
is treated as an
\fIunpacking pattern\fR\&.
.PP
An unpacking pattern must itself be a composite transform; that is, it must be a function type representing either a
CallableTransform
or an
ObjectTransform\&. The type
proto::pack(_)
must appear exactly once in the unpacking pattern\&. This type will receive a substitution when the unpacking pattern is expanded\&.
.PP
A composite transform like
X(A0,&#8230;An \&.\&.\&.), when evaluated against a given expression
\fIE\fR, state and data, is evaluated as if it were
X(A0,&#8230;An\-1,\fIS\fR)
where
\fIS\fR
is a type sequence computed as follows:
.PP
Let
\fISUB\fR(A,B)
be a type function that replaces every occurence of
proto::pack(_)
within
A
with
B\&.

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                If the expression \fIE\fR is a terminal (i\&.e\&. it has arity 0), \fIS\fR
                is the one\-element sequence containing \fISUB\fR(An, proto::_value)\&.
              .RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                If the expression \fIE\fR is a non\-terminal, \fIS\fR is the sequence
                \fISUB\fR(An, proto::_child_c<0>),&#8230;
                \fISUB\fR(An, proto::_child_c<\fIM\fR\-1>), where
                \fIM\fR is the arity of the expression \fIE\fR\&.
              .RE
.sp
.RE


