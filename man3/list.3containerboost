.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE LIST" 3 "" "" ""
.SH "NAME"
boost::container::list
.SH "SYNOPSIS"
.\" value_type: Class template list
.\" Class template list: value_type
.\" unique: Class template list
.\" Class template list: unique
.\" swap: Class template list
.\" Class template list: swap
.\" stored_allocator_type: Class template list
.\" Class template list: stored_allocator_type
.\" sort: Class template list
.\" Class template list: sort
.\" size_type: Class template list
.\" Class template list: size_type
.\" reverse_iterator: Class template list
.\" Class template list: reverse_iterator
.\" resize: Class template list
.\" Class template list: resize
.\" rend: Class template list
.\" Class template list: rend
.\" remove_if: Class template list
.\" Class template list: remove_if
.\" remove: Class template list
.\" Class template list: remove
.\" reference: Class template list
.\" Class template list: reference
.\" rbegin: Class template list
.\" Class template list: rbegin
.\" push_front: Class template list
.\" Class template list: push_front
.\" push_back: Class template list
.\" Class template list: push_back
.\" pop_front: Class template list
.\" Class template list: pop_front
.\" pop_back: Class template list
.\" Class template list: pop_back
.\" pointer: Class template list
.\" Class template list: pointer
.\" merge: Class template list
.\" Class template list: merge
.\" list: Class template list
.\" Class template list: list
.\" iterator: Class template list
.\" Class template list: iterator
.\" insert: Class template list
.\" Class template list: insert
.\" get_stored_allocator: Class template list
.\" Class template list: get_stored_allocator
.\" front: Class template list
.\" Class template list: front
.\" erase: Class template list
.\" Class template list: erase
.\" end: Class template list
.\" Class template list: end
.\" emplace_back: Class template list
.\" Class template list: emplace_back
.\" emplace: Class template list
.\" Class template list: emplace
.\" difference_type: Class template list
.\" Class template list: difference_type
.\" const_reverse_iterator: Class template list
.\" Class template list: const_reverse_iterator
.\" const_reference: Class template list
.\" Class template list: const_reference
.\" const_pointer: Class template list
.\" Class template list: const_pointer
.\" const_iterator: Class template list
.\" Class template list: const_iterator
.\" clear: Class template list
.\" Class template list: clear
.\" begin: Class template list
.\" Class template list: begin
.\" back: Class template list
.\" Class template list: back
.\" assign: Class template list
.\" Class template list: assign
.\" allocator_type: Class template list
.\" Class template list: allocator_type

.sp
.nf
// In header: <boost/container/list\&.hpp>

template<typename T, typename Allocator = new_allocator<T> > 
class list {
public:
  // types
  typedef T                                                                  value_type;            
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef implementation_defined                                             stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  list();
  explicit list(const allocator_type &) noexcept;
  explicit list(size_type);
  list(size_type, const allocator_type &);
  list(size_type, const T &, const Allocator & = Allocator());
  list(const list &);
  list(list &&);
  list(const list &, const allocator_type &);
  list(list &&, const allocator_type &);
  template<typename InpIt> list(InpIt, InpIt, const Allocator & = Allocator());
  list(std::initializer_list< value_type >, const Allocator & = Allocator());
  list & operator=(const list &);
  list & operator=(list &&) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
  list & operator=(std::initializer_list< value_type >);
  ~list();

  // public member functions
  void assign(size_type, const T &);
  template<typename InpIt> void assign(InpIt, InpIt);
  void assign(std::initializer_list< value_type >);
  allocator_type get_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_iterator cbegin() const noexcept;
  const_iterator cend() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const noexcept;
  size_type size() const noexcept;
  size_type max_size() const noexcept;
  void resize(size_type);
  void resize(size_type, const T &);
  reference front() noexcept;
  const_reference front() const noexcept;
  reference back() noexcept;
  const_reference back() const noexcept;
  template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> void emplace_front(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace(const_iterator, Args &&\&.\&.\&.);
  void push_front(const T &);
  void push_front(T &&);
  void push_back(const T &);
  void push_back(T &&);
  iterator insert(const_iterator, const T &);
  iterator insert(const_iterator, T &&);
  iterator insert(const_iterator, size_type, const T &);
  template<typename InpIt> iterator insert(const_iterator, InpIt, InpIt);
  iterator insert(const_iterator, std::initializer_list< value_type >);
  void pop_front() noexcept;
  void pop_back() noexcept;
  iterator erase(const_iterator) noexcept;
  iterator erase(const_iterator, const_iterator) noexcept;
  void swap(list &) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
  void clear() noexcept;
  void splice(const_iterator, list &) noexcept;
  void splice(const_iterator, list &&) noexcept;
  void splice(const_iterator, list &, const_iterator) noexcept;
  void splice(const_iterator, list &&, const_iterator) noexcept;
  void splice(const_iterator, list &, const_iterator, const_iterator) noexcept;
  void splice(const_iterator, list &&, const_iterator, const_iterator) noexcept;
  void splice(const_iterator, list &, const_iterator, const_iterator, 
              size_type) noexcept;
  void splice(const_iterator, list &&, const_iterator, const_iterator, 
              size_type) noexcept;
  void remove(const T &);
  template<typename Pred> void remove_if(Pred);
  void unique();
  template<typename BinaryPredicate> void unique(BinaryPredicate);
  void merge(list &);
  void merge(list &&);
  template<typename StrictWeakOrdering> 
    void merge(list &, const StrictWeakOrdering &);
  template<typename StrictWeakOrdering> 
    void merge(list &&, StrictWeakOrdering);
  void sort();
  template<typename StrictWeakOrdering> void sort(StrictWeakOrdering);
  void reverse() noexcept;

  // friend functions
  friend bool operator==(const list &, const list &);
  friend bool operator!=(const list &, const list &);
  friend bool operator<(const list &, const list &);
  friend bool operator>(const list &, const list &);
  friend bool operator<=(const list &, const list &);
  friend bool operator>=(const list &, const list &);
  friend void swap(list &, list &);
};
.fi
.SH "DESCRIPTION"
.PP
A list is a doubly linked list\&. That is, it is a Sequence that supports both forward and backward traversal, and (amortized) constant time insertion and removal of elements at the beginning or the end, or in the middle\&. Lists have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed\&. The ordering of iterators may be changed (that is, list<T>::iterator might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of object that is stored in the list
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<T>
.fi

.sp
The allocator used for all internal memory management
.RE

.SS "list public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
list();
.fi

.sp
\fBEffects\fR: Default constructs a list\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit list(const allocator_type & a) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a list taking the allocator as parameter\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit list(size_type n);
.fi

.sp
\fBEffects\fR: Constructs a list and inserts n value\-initialized value_types\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
list(size_type n, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
list(size_type n, const T & value, const Allocator & a = Allocator());
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
list(const list & x);
.fi

.sp
\fBEffects\fR: Copy constructs a list\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
list(list && x);
.fi

.sp
\fBEffects\fR: Move constructor\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocator_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
list(const list & x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a list using the specified allocator\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
list(list && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructor sing the specified allocator\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocation or value_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant if a == x\&.get_allocator(), linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename InpIt> 
  list(InpIt first, InpIt last, const Allocator & a = Allocator());
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts a copy of the range [first, last) in the list\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced InIt throws\&.
.sp
\fBComplexity\fR: Linear to the range [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
list(std::initializer_list< value_type > il, 
     const Allocator & a = Allocator());
.fi

.sp
\fBEffects\fR: Constructs a list that will use a copy of allocator a and inserts a copy of the range [il\&.begin(), il\&.end()) in the list\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
list & operator=(const list & x);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as x\&.
.sp
\fBPostcondition\fR: this\->size() == x\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements in x\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
list & operator=(list && x) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Move assignment\&. All x\'s values are transferred to *this\&.
.sp
\fBPostcondition\fR: x\&.empty()\&. *this contains a the elements x had before the function\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
list & operator=(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as il\&.
.sp
\fBPostcondition\fR: this\->size() == il\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements in x\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
~list();
.fi

.sp
\fBEffects\fR: Destroys the list\&. All stored values are destroyed and used memory is deallocated\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements\&.
.RE

.SS "list public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" assign: Class template list
.\" Class template list: assign

.sp

.nf
void assign(size_type n, const T & val);
.fi

.sp
\fBEffects\fR: Assigns the n copies of val to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" assign: Class template list
.\" Class template list: assign

.sp

.nf
template<typename InpIt> void assign(InpIt first, InpIt last);
.fi

.sp
\fBEffects\fR: Assigns the the range [first, last) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing InpIt throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" assign: Class template list
.\" Class template list: assign

.sp

.nf
void assign(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Assigns the the range [il\&.begin(), il\&.end()) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a copy of the internal allocator\&.
.sp
\fBThrows\fR: If allocator\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" get_stored_allocator: Class template list
.\" Class template list: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" get_stored_allocator: Class template list
.\" Class template list: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" begin: Class template list
.\" Class template list: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" begin: Class template list
.\" Class template list: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" end: Class template list
.\" Class template list: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" end: Class template list
.\" Class template list: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rbegin: Class template list
.\" Class template list: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" rbegin: Class template list
.\" Class template list: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rend: Class template list
.\" Class template list: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template list
.\" Class template list: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
\fBEffects\fR: Returns true if the list contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" resize: Class template list
.\" Class template list: resize

.sp

.nf
void resize(size_type new_size);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are value initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" resize: Class template list
.\" Class template list: resize

.sp

.nf
void resize(size_type new_size, const T & x);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are copy constructed from x\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" front: Class template list
.\" Class template list: front

.sp

.nf
reference front() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the first element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" front: Class template list
.\" Class template list: front

.sp

.nf
const_reference front() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the first element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" back: Class template list
.\" Class template list: back

.sp

.nf
reference back() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the first element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" back: Class template list
.\" Class template list: back

.sp

.nf
const_reference back() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the first element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" emplace_back: Class template list
.\" Class template list: emplace_back

.sp

.nf
template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the end of the list\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s in\-place constructor throws\&.
.sp
\fBComplexity\fR: Constant
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> void emplace_front(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the beginning of the list\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s in\-place constructor throws\&.
.sp
\fBComplexity\fR: Constant
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" emplace: Class template list
.\" Class template list: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. before p\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s in\-place constructor throws\&.
.sp
\fBComplexity\fR: Constant
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" push_front: Class template list
.\" Class template list: push_front

.sp

.nf
void push_front(const T & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x at the beginning of the list\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" push_front: Class template list
.\" Class template list: push_front

.sp

.nf
void push_front(T && x);
.fi

.sp
\fBEffects\fR: Constructs a new element in the beginning of the list and moves the resources of x to this new element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" push_back: Class template list
.\" Class template list: push_back

.sp

.nf
void push_back(const T & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x at the end of the list\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" push_back: Class template list
.\" Class template list: push_back

.sp

.nf
void push_back(T && x);
.fi

.sp
\fBEffects\fR: Constructs a new element in the end of the list and moves the resources of x to this new element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" insert: Class template list
.\" Class template list: insert

.sp

.nf
iterator insert(const_iterator p, const T & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of x before p\&.
.sp
\fBReturns\fR: an iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws or x\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" insert: Class template list
.\" Class template list: insert

.sp

.nf
iterator insert(const_iterator p, T && x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a new element before p with x\'s resources\&.
.sp
\fBReturns\fR: an iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" insert: Class template list
.\" Class template list: insert

.sp

.nf
iterator insert(const_iterator p, size_type n, const T & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts n copies of x before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if n is 0\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" insert: Class template list
.\" Class template list: insert

.sp

.nf
template<typename InpIt> 
  iterator insert(const_iterator p, InpIt first, InpIt last);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [first, last) range before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if first == last\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced InpIt throws\&.
.sp
\fBComplexity\fR: Linear to distance [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" insert: Class template list
.\" Class template list: insert

.sp

.nf
iterator insert(const_iterator p, std::initializer_list< value_type > il);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [il\&.begin(), il\&.end()) range before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if if\&.begin() == il\&.end()\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to distance [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" pop_front: Class template list
.\" Class template list: pop_front

.sp

.nf
void pop_front() noexcept;
.fi

.sp
\fBEffects\fR: Removes the first element from the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" pop_back: Class template list
.\" Class template list: pop_back

.sp

.nf
void pop_back() noexcept;
.fi

.sp
\fBEffects\fR: Removes the last element from the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" erase: Class template list
.\" Class template list: erase

.sp

.nf
iterator erase(const_iterator p) noexcept;
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Erases the element at p p\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" erase: Class template list
.\" Class template list: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last) noexcept;
.fi

.sp
\fBRequires\fR: first and last must be valid iterator to elements in *this\&.
.sp
\fBEffects\fR: Erases the elements pointed by [first, last)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the distance between first and last\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" swap: Class template list
.\" Class template list: swap

.sp

.nf
void swap(list & x) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" clear: Class template list
.\" Class template list: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: Erases all the elements of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the list\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list & x) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by the list\&. x != *this\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list && x) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by the list\&. x != *this\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list & x, const_iterator i) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. i must point to an element contained in list x\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers the value pointed by i, from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&. If p == i or p == ++i, this function is a null operation\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list && x, const_iterator i) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. i must point to an element contained in list x\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the value pointed by i, from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&. If p == i or p == ++i, this function is a null operation\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list & x, const_iterator first, 
            const_iterator last) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. first and last must point to elements contained in list x\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear to the number of elements transferred\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list && x, const_iterator first, 
            const_iterator last) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. first and last must point to elements contained in list x\&. this\' allocator and x\'s allocator shall compare equal\&.
.sp
\fBEffects\fR: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Linear to the number of elements transferred\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list & x, const_iterator first, 
            const_iterator last, size_type n) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. first and last must point to elements contained in list x\&. n == distance(first, last)\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}

.sp

.nf
void splice(const_iterator p, list && x, const_iterator first, 
            const_iterator last, size_type n) noexcept;
.fi

.sp
\fBRequires\fR: p must point to an element contained by this list\&. first and last must point to elements contained in list x\&. n == distance(first, last)\&. this\' allocator and x\'s allocator shall compare equal
.sp
\fBEffects\fR: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" remove: Class template list
.\" Class template list: remove

.sp

.nf
void remove(const T & value);
.fi

.sp
\fBEffects\fR: Removes all the elements that compare equal to value\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" remove_if: Class template list
.\" Class template list: remove_if

.sp

.nf
template<typename Pred> void remove_if(Pred pred);
.fi

.sp
\fBEffects\fR: Removes all the elements for which a specified predicate is satisfied\&.
.sp
\fBThrows\fR: If pred throws\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() calls to the predicate\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" unique: Class template list
.\" Class template list: unique

.sp

.nf
void unique();
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that are equal from the list\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBComplexity\fR: Linear time (size()\-1 comparisons equality comparisons)\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" unique: Class template list
.\" Class template list: unique

.sp

.nf
template<typename BinaryPredicate> void unique(BinaryPredicate binary_pred);
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list\&.
.sp
\fBThrows\fR: If pred throws\&.
.sp
\fBComplexity\fR: Linear time (size()\-1 comparisons calls to pred())\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" merge: Class template list
.\" Class template list: merge

.sp

.nf
void merge(list & x);
.fi

.sp
\fBRequires\fR: The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this according to std::less<value_type>\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" merge: Class template list
.\" Class template list: merge

.sp

.nf
void merge(list && x);
.fi

.sp
\fBRequires\fR: The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this according to std::less<value_type>\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" merge: Class template list
.\" Class template list: merge

.sp

.nf
template<typename StrictWeakOrdering> 
  void merge(list & x, const StrictWeakOrdering & comp);
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comp throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references to *this are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" merge: Class template list
.\" Class template list: merge

.sp

.nf
template<typename StrictWeakOrdering> 
  void merge(list && x, StrictWeakOrdering comp);
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If comp throws\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references to *this are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}
.\" sort: Class template list
.\" Class template list: sort

.sp

.nf
void sort();
.fi

.sp
\fBEffects\fR: This function sorts the list *this according to std::less<value_type>\&. The sort is stable, that is, the relative order of equivalent elements is preserved\&.
.sp
\fBThrows\fR: If comparison throws\&.
.sp
\fBNotes\fR: Iterators and references are not invalidated\&.
.sp
\fBComplexity\fR: The number of comparisons is approximately N log N, where N is the list\'s size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}
.\" sort: Class template list
.\" Class template list: sort

.sp

.nf
template<typename StrictWeakOrdering> void sort(StrictWeakOrdering comp);
.fi

.sp
\fBEffects\fR: This function sorts the list *this according to std::less<value_type>\&. The sort is stable, that is, the relative order of equivalent elements is preserved\&.
.sp
\fBThrows\fR: If comp throws\&.
.sp
\fBNotes\fR: Iterators and references are not invalidated\&.
.sp
\fBComplexity\fR: The number of comparisons is approximately N log N, where N is the list\'s size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}

.sp

.nf
void reverse() noexcept;
.fi

.sp
\fBEffects\fR: Reverses the order of elements in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: This function is linear time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated
.RE

.SS "list friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const list & x, const list & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const list & x, const list & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const list & x, const list & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const list & x, const list & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const list & x, const list & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const list & x, const list & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template list
.\" Class template list: swap

.sp

.nf
friend void swap(list & x, list & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


