.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS VA" 3 "" "" ""
.SH "NAME"
boost::program_options::value_semantic_codecvt_helper<char>
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/program_options/value_semantic\&.hpp>


class value_semantic_codecvt_helper<char> :
  public boost::program_options::value_semantic
{
public:

  // private member functions
  virtual void 
  parse(boost::any &, const std::vector< std::string > &, bool) const;

  // protected member functions
  virtual void 
  xparse(boost::any &, const std::vector< std::string > &) const = 0;
};
.fi
.SH "DESCRIPTION"
.PP
Helper conversion class for values that accept ascii strings as input\&. Overrides the \'parse\' method and defines new \'xparse\' method taking std::string\&. Depending on whether input to parse is ascii or UTF8, will pass it to xparse unmodified, or with UTF8\->ascii conversion\&.
.SS "value_semantic_codecvt_helper private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
virtual void 
parse(boost::any & value_store, const std::vector< std::string > & new_tokens, 
      bool utf8) const;
.fi

.sp
Parses a group of tokens that specify a value of option\&. Stores the result in \'value_store\', using whatever representation is desired\&. May be be called several times if value of the same option is specified more than once\&.
.RE

.SS "value_semantic_codecvt_helper protected member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
virtual void 
xparse(boost::any & value_store, 
       const std::vector< std::string > & new_tokens) const = 0;
.fi

.RE


