.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE U" 3 "" "" ""
.SH "NAME"
boost::movelib::unique_ptr
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/move/unique_ptr\&.hpp>

template<typename T, typename D = default_delete<T> > 
class unique_ptr {
public:
  // types
  typedef see_documentation pointer;     
  typedef see_documentation element_type;
  typedef D                 deleter_type;

  // construct/copy/destruct
  unique_ptr(const unique_ptr &) = delete;
  unique_ptr() noexcept;
  unique_ptr(std::nullptr_t) noexcept;
  template<typename Pointer> explicit unique_ptr(Pointer) noexcept;
  template<typename Pointer> unique_ptr(Pointer, see_documentation) noexcept;
  unique_ptr(std::nullptr_t, see_documentation) noexcept;
  template<typename Pointer> unique_ptr(Pointer, see_documentation) noexcept;
  unique_ptr(std::nullptr_t, see_documentation) noexcept;
  unique_ptr(unique_ptr &&) noexcept;
  template<typename U, typename E> 
    unique_ptr(BOOST_RV_REF_BEG_IF_CXX11 unique_ptr< U, E > BOOST_RV_REF_END_IF_CXX11) noexcept;
  unique_ptr & operator=(const unique_ptr &) = delete;
  unique_ptr & operator=(unique_ptr &&) noexcept;
  template<typename U, typename E> 
    unique_ptr & operator=(unique_ptr< U, E > &&) noexcept;
  unique_ptr & operator=(std::nullptr_t) noexcept;
  ~unique_ptr();

  // public member functions
  element_type & operator*() const noexcept;
  element_type & operator[](std::size_t) const noexcept;
  pointer operator\->() const noexcept;
  pointer get() const noexcept;
  D & get_deleter() noexcept;
  const D & get_deleter() const noexcept;
  explicit operator bool() const noexcept;
  pointer release() noexcept;
  template<typename Pointer> void reset(Pointer) noexcept;
  void reset() noexcept;
  void reset(std::nullptr_t) noexcept;
  void swap(unique_ptr &) noexcept;
};
.fi
.SH "DESCRIPTION"
.PP
A unique pointer is an object that owns another object and manages that other object through a pointer\&.
.PP
More precisely, a unique pointer is an object u that stores a pointer to a second object p and will dispose of p when u is itself destroyed (e\&.g\&., when leaving block scope)\&. In this context, u is said to own p\&.
.PP
The mechanism by which u disposes of p is known as p\'s associated deleter, a function object whose correct invocation results in p\'s appropriate disposition (typically its deletion)\&.
.PP
Let the notation u\&.p denote the pointer stored by u, and let u\&.d denote the associated deleter\&. Upon request, u can reset (replace) u\&.p and u\&.d with another pointer and deleter, but must properly dispose of its owned object via the associated deleter before such replacement is considered completed\&.
.PP
Additionally, u can, upon request, transfer ownership to another unique pointer u2\&. Upon completion of such a transfer, the following postconditions hold:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
u2\&.p is equal to the pre\-transfer u\&.p,
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
u\&.p is equal to nullptr, and
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
if the pre\-transfer u\&.d maintained state, such state has been transferred to u2\&.d\&.
.RE
.sp
.RE

.PP
As in the case of a reset, u2 must properly dispose of its pre\-transfer owned object via the pre\-transfer associated deleter before the ownership transfer is considered complete\&.
.PP
Each object of a type U instantiated from the
unique_ptr
template specified in this subclause has the strict ownership semantics, specified above, of a unique pointer\&. In partial satisfaction of these semantics, each such U is MoveConstructible and MoveAssignable, but is not CopyConstructible nor CopyAssignable\&. The template parameter T of
unique_ptr
may be an incomplete type\&.
.PP
The uses of
unique_ptr
include providing exception safety for dynamically allocated memory, passing ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from a function\&.
.PP
If T is an array type (e\&.g\&. unique_ptr<MyType[]>) the interface is slightly altered:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Pointers to types derived from T are rejected by the constructors, and by reset\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The observers
operator*
and
operator\->
are not provided\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The indexing observer
operator[]
is provided\&.
.RE
.sp
.RE

.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
Provides the type of the stored pointer\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename D = default_delete<T>
.fi

.sp
The deleter type: .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} The default type for the template parameter D is default_delete\&. A client\-supplied template argument D shall be a function object type, lvalue\-reference to function, or lvalue\-reference to function object type for which, given a value d of type D and a value ptr of type unique_ptr<T, D>::pointer, the expression d(ptr) is valid and has the effect of disposing of the pointer as appropriate for that deleter\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If the deleter\'s type D is not a reference type, D shall satisfy the requirements of Destructible\&. .RE .sp .RS 4 .ie n \{\ \h'-04'&#8226;\h'+03'\c .\} .el \{\ .sp -1 .IP \(bu 2.3 .\} If the type remove_reference<D>::type::pointer exists, it shall satisfy the requirements of NullablePointer\&. .RE .RS 4
.RE

.SS "unique_ptr public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

typedef
see_documentation
pointer;
.sp
If the type
remove_reference<D>::type::pointer
exists, then it shall be a synonym for
remove_reference<D>::type::pointer\&. Otherwise it shall be a synonym for T*\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

typedef
see_documentation
element_type;
.sp
If T is an array type, then element_type is equal to T\&. Otherwise, if T is a type in the form U[], element_type is equal to U\&.
.RE

.SS "unique_ptr public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
unique_ptr(const unique_ptr &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
unique_ptr() noexcept;
.fi

.sp
\fBRequires\fR: D shall satisfy the requirements of DefaultConstructible, and that construction shall not throw an exception\&.
.sp
\fBEffects\fR: Constructs a
unique_ptr
object that owns nothing, value\-initializing the stored pointer and the stored deleter\&.
.sp
\fBPostconditions\fR:
get() == nullptr\&.
get_deleter()
returns a reference to the stored deleter\&.
.sp
\fBRemarks\fR: If this constructor is instantiated with a pointer type or reference type for the template argument D, the program is ill\-formed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
unique_ptr(std::nullptr_t) noexcept;
.fi

.sp
\fBEffects\fR: Same as
unique_ptr()
(default constructor)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename Pointer> explicit unique_ptr(Pointer p) noexcept;
.fi

.sp
\fBRequires\fR: D shall satisfy the requirements of DefaultConstructible, and that construction shall not throw an exception\&.
.sp
\fBEffects\fR: Constructs a
unique_ptr
which owns p, initializing the stored pointer with p and value initializing the stored deleter\&.
.sp
\fBPostconditions\fR:
get() == p\&.
get_deleter()
returns a reference to the stored deleter\&.
.sp
\fBRemarks\fR: If this constructor is instantiated with a pointer type or reference type for the template argument D, the program is ill\-formed\&. This constructor shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is not an array type and Pointer is implicitly convertible to pointer\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is an array type and Pointer is a more CV qualified pointer to element_type\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename Pointer> 
  unique_ptr(Pointer p, see_documentation d1) noexcept;
.fi

.sp
The signature of this constructor depends upon whether D is a reference type\&.
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If D is non\-reference type A, then the signature is
unique_ptr(pointer p, const A& d)\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If D is an lvalue\-reference type A&, then the signature is
unique_ptr(pointer p, A& d)\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If D is an lvalue\-reference type const A&, then the signature is
unique_ptr(pointer p, const A& d)\&.
.RE
.RS 4

.sp
\fBRequires\fR: Either
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
D is not an lvalue\-reference type and d is an lvalue or const rvalue\&. D shall satisfy the requirements of CopyConstructible, and the copy constructor of D shall not throw an exception\&. This
unique_ptr
will hold a copy of d\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
D is an lvalue\-reference type and d is an lvalue\&. the type which D references need not be CopyConstructible nor MoveConstructible\&. This
unique_ptr
will hold a D which refers to the lvalue d\&.
.RE
.RS 4

.sp
\fBEffects\fR: Constructs a
unique_ptr
object which owns p, initializing the stored pointer with p and initializing the deleter as described above\&.
.sp
\fBPostconditions\fR:
get() == p\&.
get_deleter()
returns a reference to the stored deleter\&. If D is a reference type then
get_deleter()
returns a reference to the lvalue d\&.
.sp
\fBRemarks\fR: This constructor shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is not an array type and Pointer is implicitly convertible to pointer\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is an array type and Pointer is a more CV qualified pointer to element_type\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
unique_ptr(std::nullptr_t, see_documentation d1) noexcept;
.fi

.sp
\fBEffects\fR: Same effects as
template<class Pointer> unique_ptr(Pointer p, deleter_arg_type1 d1)
and additionally
get() == nullptr
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename Pointer> 
  unique_ptr(Pointer p, see_documentation d2) noexcept;
.fi

.sp
The signature of this constructor depends upon whether D is a reference type\&.
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If D is non\-reference type A, then the signature is
unique_ptr(pointer p, A&& d)\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If D is an lvalue\-reference type A&, then the signature is
unique_ptr(pointer p, A&& d)\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If D is an lvalue\-reference type const A&, then the signature is
unique_ptr(pointer p, const A&& d)\&.
.RE
.RS 4

.sp
\fBRequires\fR: Either
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
D is not an lvalue\-reference type and d is a non\-const rvalue\&. D shall satisfy the requirements of MoveConstructible, and the move constructor of D shall not throw an exception\&. This
unique_ptr
will hold a value move constructed from d\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
D is an lvalue\-reference type and d is an rvalue, the program is ill\-formed\&.
.RE
.RS 4

.sp
\fBEffects\fR: Constructs a
unique_ptr
object which owns p, initializing the stored pointer with p and initializing the deleter as described above\&.
.sp
\fBPostconditions\fR:
get() == p\&.
get_deleter()
returns a reference to the stored deleter\&. If D is a reference type then
get_deleter()
returns a reference to the lvalue d\&.
.sp
\fBRemarks\fR: This constructor shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is not an array type and Pointer is implicitly convertible to pointer\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is an array type and Pointer is a more CV qualified pointer to element_type\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
unique_ptr(std::nullptr_t, see_documentation d2) noexcept;
.fi

.sp
\fBEffects\fR: Same effects as
template<class Pointer> unique_ptr(Pointer p, deleter_arg_type2 d2)
and additionally
get() == nullptr
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
unique_ptr(unique_ptr && u) noexcept;
.fi

.sp
\fBRequires\fR: If D is not a reference type, D shall satisfy the requirements of MoveConstructible\&. Construction of the deleter from an rvalue of type D shall not throw an exception\&.
.sp
\fBEffects\fR: Constructs a
unique_ptr
by transferring ownership from u to *this\&. If D is a reference type, this deleter is copy constructed from u\'s deleter; otherwise, this deleter is move constructed from u\'s deleter\&.
.sp
\fBPostconditions\fR:
get()
yields the value u\&.get() yielded before the construction\&.
get_deleter()
returns a reference to the stored deleter that was constructed from u\&.get_deleter()\&. If D is a reference type then
get_deleter()
and
u\&.get_deleter()
both reference the same lvalue deleter\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename U, typename E> 
  unique_ptr(BOOST_RV_REF_BEG_IF_CXX11 unique_ptr< U, E > BOOST_RV_REF_END_IF_CXX11 u) noexcept;
.fi

.sp
\fBRequires\fR: If E is not a reference type, construction of the deleter from an rvalue of type E shall be well formed and shall not throw an exception\&. Otherwise, E is a reference type and construction of the deleter from an lvalue of type E shall be well formed and shall not throw an exception\&.
.sp
\fBRemarks\fR: This constructor shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
unique_ptr<U, E>::pointer
is implicitly convertible to pointer,
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
U is not an array type, and
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
either D is a reference type and E is the same type as D, or D is not a reference type and E is implicitly convertible to D\&.
.RE
.RS 4

.sp
\fBEffects\fR: Constructs a
unique_ptr
by transferring ownership from u to *this\&. If E is a reference type, this deleter is copy constructed from u\'s deleter; otherwise, this deleter is move constructed from u\'s deleter\&.
.sp
\fBPostconditions\fR:
get()
yields the value
u\&.get()
yielded before the construction\&.
get_deleter()
returns a reference to the stored deleter that was constructed from
u\&.get_deleter()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
unique_ptr & operator=(const unique_ptr &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
unique_ptr & operator=(unique_ptr && u) noexcept;
.fi

.sp
\fBRequires\fR: If D is not a reference type, D shall satisfy the requirements of MoveAssignable and assignment of the deleter from an rvalue of type D shall not throw an exception\&. Otherwise, D is a reference type;
remove_reference<D>::type
shall satisfy the CopyAssignable requirements and assignment of the deleter from an lvalue of type D shall not throw an exception\&.
.sp
\fBEffects\fR: Transfers ownership from u to *this as if by calling
reset(u\&.release())
followed by
get_deleter() = std::forward<D>(u\&.get_deleter())\&.
.sp
\fBReturns\fR: *this\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
template<typename U, typename E> 
  unique_ptr & operator=(unique_ptr< U, E > && u) noexcept;
.fi

.sp
\fBRequires\fR: If E is not a reference type, assignment of the deleter from an rvalue of type E shall be well\-formed and shall not throw an exception\&. Otherwise, E is a reference type and assignment of the deleter from an lvalue of type E shall be well\-formed and shall not throw an exception\&.
.sp
\fBRemarks\fR: This operator shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
unique_ptr<U, E>::pointer
is implicitly convertible to pointer and
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
U is not an array type\&.
.RE
.RS 4

.sp
\fBEffects\fR: Transfers ownership from u to *this as if by calling
reset(u\&.release())
followed by
get_deleter() = std::forward<E>(u\&.get_deleter())\&.
.sp
\fBReturns\fR: *this\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
unique_ptr & operator=(std::nullptr_t) noexcept;
.fi

.sp
\fBEffects\fR:
reset()\&.
.sp
\fBPostcondition\fR:
get() == nullptr
.sp
\fBReturns\fR: *this\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
~unique_ptr();
.fi

.sp
\fBRequires\fR: The expression
get_deleter()(get())
shall be well formed, shall have well\-defined behavior, and shall not throw exceptions\&.
.sp
\fBEffects\fR: If
get() == nullpt1r
there are no effects\&. Otherwise
get_deleter()(get())\&.
.sp
\fBNote\fR: The use of
default_delete
requires T to be a complete type
.RE

.SS "unique_ptr public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
element_type & operator*() const noexcept;
.fi

.sp
\fBRequires\fR:
get() != nullptr\&.
.sp
\fBReturns\fR:
*get()\&.
.sp
\fBRemarks</b: If T is an array type, the program is ill\-formed\&. \fR
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
element_type & operator[](std::size_t i) const noexcept;
.fi

.sp
\fBRequires\fR: i < the number of elements in the array to which the stored pointer points\&.
.sp
\fBReturns\fR:
get()[i]\&.
.sp
\fBRemarks</b: If T is not an array type, the program is ill\-formed\&. \fR
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
pointer operator\->() const noexcept;
.fi

.sp
\fBRequires\fR:
get() != nullptr\&.
.sp
\fBReturns\fR:
get()\&.
.sp
\fBNote\fR: use typically requires that T be a complete type\&.
.sp
\fBRemarks</b: If T is an array type, the program is ill\-formed\&. \fR
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
pointer get() const noexcept;
.fi

.sp
\fBReturns\fR: The stored pointer\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
D & get_deleter() noexcept;
.fi

.sp
\fBReturns\fR: A reference to the stored deleter\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const D & get_deleter() const noexcept;
.fi

.sp
\fBReturns\fR: A reference to the stored deleter\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
explicit operator bool() const noexcept;
.fi

.sp
\fBReturns\fR: Returns: get() != nullptr\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
pointer release() noexcept;
.fi

.sp
\fBPostcondition\fR:
get() == nullptr\&.
.sp
\fBReturns\fR: The value
get()
had at the start of the call to release\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename Pointer> void reset(Pointer p) noexcept;
.fi

.sp
\fBRequires\fR: The expression
get_deleter()(get())
shall be well formed, shall have well\-defined behavior, and shall not throw exceptions\&.
.sp
\fBEffects\fR: assigns p to the stored pointer, and then if the old value of the stored pointer, old_p, was not equal to nullptr, calls
get_deleter()(old_p)\&. Note: The order of these operations is significant because the call to
get_deleter()
may destroy *this\&.
.sp
\fBPostconditions\fR:
get() == p\&. Note: The postcondition does not hold if the call to
get_deleter()
destroys *this since
this\->get()
is no longer a valid expression\&.
.sp
\fBRemarks\fR: This constructor shall not participate in overload resolution unless:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is not an array type and Pointer is implicitly convertible to pointer\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If T is an array type and Pointer is a more CV qualified pointer to element_type\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
void reset() noexcept;
.fi

.sp
\fBRequires\fR: The expression
get_deleter()(get())
shall be well formed, shall have well\-defined behavior, and shall not throw exceptions\&.
.sp
\fBEffects\fR: assigns nullptr to the stored pointer, and then if the old value of the stored pointer, old_p, was not equal to nullptr, calls
get_deleter()(old_p)\&. Note: The order of these operations is significant because the call to
get_deleter()
may destroy *this\&.
.sp
\fBPostconditions\fR:
get() == p\&. Note: The postcondition does not hold if the call to
get_deleter()
destroys *this since
this\->get()
is no longer a valid expression\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
void reset(std::nullptr_t) noexcept;
.fi

.sp
\fBEffects\fR: Same as
reset()
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
void swap(unique_ptr & u) noexcept;
.fi

.sp
\fBRequires\fR:
get_deleter()
shall be swappable and shall not throw an exception under swap\&.
.sp
\fBEffects\fR: Invokes swap on the stored pointers and on the stored deleters of *this and u\&.
.RE


