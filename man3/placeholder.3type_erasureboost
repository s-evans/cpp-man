.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT PLACEHOLDER" 3 "" "" ""
.SH "NAME"
boost::type_erasure::placeholder
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/type_erasure/placeholder\&.hpp>


struct placeholder {
};
.fi
.SH "DESCRIPTION"
.PP
Placeholders are used heavily throughout the library\&. Every placeholder must derive from
placeholder\&. The library provides a number of placeholders, out of the box, but you are welcome to define your own, if you want more descriptive names\&. The placeholder
_self
is special in that it is used as the default wherever possible\&.
.PP
What exactly is a placeholder? Placeholders act as a substitute for template parameters in concepts\&. The library automatically replaces all the placeholders used in a concept with the actual types involved when it stores an object in an any\&.
.PP
For example, in the following,
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
any<copy_constructible<_a>, _a> x(1);

.fi
.if n \{\
.RE
.\}

.PP
The library sees that we\'re constructing an any that uses the
_a
placeholder with an
int\&. Thus it binds
_a
to int and instantiates
copy_constructible<int>\&.
.PP
When there are multiple placeholders involved, you will have to use
tuple, or pass the bindings explicitly, but the substitution still works the same way\&.

