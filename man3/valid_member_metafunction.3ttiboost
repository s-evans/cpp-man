.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT T" 3 "" "" ""
.SH "NAME"
boost::tti::valid_member_metafunction \- A metafunction which checks whether the invoked macro metafunction generated by BOOST_TTI_MEMBER_TYPE ( BOOST_TTI_TRAIT_MEMBER_TYPE ) hold a valid type\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/tti/member_type\&.hpp>

template<typename TTI_METAFUNCTION> 
struct valid_member_metafunction : public boost::mpl::not_< boost::is_same< TTI_METAFUNCTION::type, TTI_METAFUNCTION::boost_tti_marker_type > >
{
};
.fi
.SH "DESCRIPTION"
.PP
template<class TTI_METAFUNCTION> struct
valid_member_metafunction
{ static const value = unspecified; typedef mpl::bool_<true\-or\-false> type; };
.PP
The metafunction types and return:
.PP
TTI_METAFUNCTION = The invoked macro metafunction generated by BOOST_TTI_MEMBER_TYPE ( BOOST_TTI_TRAIT_MEMBER_TYPE )\&.
.PP
returns = \'value\' is true if the nested type of the invoked metafunction is valid, otherwise \'value\' is false\&. A valid type means that the invoked metafunction\'s inner \'type\' is not the marker type\&.

