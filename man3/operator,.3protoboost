.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTION OPERATOR," 3 "" "" ""
.SH "NAME"
boost::proto::operator, \- For composing a larger transform environment from two smaller ones\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/transform/env\&.hpp>


template<typename Env, typename Key, typename Value> 
  proto::env<Key, Value, \fIUNCVREF\fR(typename proto::result_of::as_env<Env &>::type)> 
  operator,(Env & other, proto::env<Key, Value> const & head);
template<typename Env, typename Key, typename Value> 
  proto::env<Key, Value, \fIUNCVREF\fR(typename proto::result_of::as_env<Env const &>::type)> 
  operator,(Env const & other, proto::env<Key, Value> const & head);
.fi
.SH "DESCRIPTION"
.PP
The effect of this function is to take two transform environments and compose them into a larger environment that contains the key/values pairs of the two\&. The first argument is allowed to not be a transform environment, in which case it is turned into one with the
proto::as_env()
function before composition with the second argument\&. The second argument is required to be a transform environment with exactly one key/value pair\&.
.PP

\fBExample:\fR
.PP
Given user\-defined keys
key0
and
key1
of types
key0_type
and
key1_type, the following code demonstrates how the chained use of
operator,
can build a composite transform environment containing a number of key/value pairs:

.sp
.if n \{\
.RS 4
.\}
.nf
proto::env<
    key1_type
  , int
  , proto::env<
        key0_type
      , char const (&)[6]
      , proto::env<proto::data_type, int>
    >
> myenv = (proto::data = 1, key0 = "hello", key1 = 42);
// NOTE: operator, here \-\-^    and here \-\-^

// Check the results:
assert(1 == myenv[proto::data]);
assert(0 == std::strcmp(myenv[key0], "hello"));
assert(42 == myenv[key1]);
.fi
.if n \{\
.RE
.\}
.sp

.PP

\fBNote:\fR
In the return type and the "Returns" clause,
\fIUNCVREF\fR(X)
is the type
X
stripped of top\-level reference and cv\-qualifiers\&.
.PP

\fBNote:\fR
In the "Returns" clause,
\fIcv\fR
is replaced with
const
for the second overload, and nothing for the first\&.
.PP

\fBSee also:\fR

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
proto::env::operator[].RE
.sp
.RE

.PP
Returns:
.RS 4
proto::env<Key, Value, \fIUNCVREF\fR(typename proto::result_of::as_env<Env \fIcv\fR &>::type)>(head[Key()], proto::as_env(other)).RE

