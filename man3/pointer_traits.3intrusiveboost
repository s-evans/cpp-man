.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLA" 3 "" "" ""
.SH "NAME"
boost::intrusive::pointer_traits
.SH "SYNOPSIS"
.\" static_cast_from: Struct template pointer_traits
.\" Struct template pointer_traits: static_cast_from
.\" reference: Struct template pointer_traits
.\" Struct template pointer_traits: reference
.\" pointer_traits: Struct template pointer_traits
.\" Struct template pointer_traits: pointer_traits
.\" pointer_to: Struct template pointer_traits
.\" Struct template pointer_traits: pointer_to
.\" pointer: Struct template pointer_traits
.\" Struct template pointer_traits: pointer
.\" element_type: Struct template pointer_traits
.\" Struct template pointer_traits: element_type
.\" dynamic_cast_from: Struct template pointer_traits
.\" Struct template pointer_traits: dynamic_cast_from
.\" difference_type: Struct template pointer_traits
.\" Struct template pointer_traits: difference_type
.\" const_cast_from: Struct template pointer_traits
.\" Struct template pointer_traits: const_cast_from

.sp
.nf
// In header: <boost/intrusive/pointer_traits\&.hpp>

template<typename Ptr> 
struct pointer_traits {
  // types
  typedef Ptr              pointer;        
  typedef unspecified_type element_type;   
  typedef unspecified_type difference_type;
  typedef unspecified      rebind;         
  typedef unspecified_type reference;      

  // public static functions
  static pointer pointer_to(reference);
  template<typename UPtr> static pointer static_cast_from(const UPtr &);
  template<typename UPtr> static pointer const_cast_from(const UPtr &);
  template<typename UPtr> static pointer dynamic_cast_from(const UPtr &);
};
.fi
.SH "DESCRIPTION"
.PP
pointer_traits
is the implementation of C++11 std::pointer_traits class with some extensions like castings\&.
.PP
pointer_traits
supplies a uniform interface to certain attributes of pointer\-like types\&.
.PP
\fBNote\fR: When defining a custom family of pointers or references to be used with BI library, make sure the public static conversion functions accessed through the
pointer_traits
interface (*_cast_from
and
pointer_to) can properly convert between const and nonconst referred member types
\fBwithout the use of implicit constructor calls\fR\&. It is suggested these conversions be implemented as function templates, where the template argument is the type of the object being converted from\&.
.SS "pointer_traits public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" pointer: Struct template pointer_traits
.\" Struct template pointer_traits: pointer

typedef
Ptr
pointer;
.sp
The pointer type queried by this
pointer_traits
instantiation
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" element_type: Struct template pointer_traits
.\" Struct template pointer_traits: element_type

typedef
unspecified_type
element_type;
.sp
Ptr::element_type if such a type exists; otherwise, T if Ptr is a class template instantiation of the form SomePointer<T, Args>, where Args is zero or more type arguments ; otherwise , the specialization is ill\-formed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" difference_type: Struct template pointer_traits
.\" Struct template pointer_traits: difference_type

typedef
unspecified_type
difference_type;
.sp
Ptr::difference_type if such a type exists; otherwise, std::ptrdiff_t\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

typedef
unspecified
rebind;
.sp
Ptr::rebind<U> if such a type exists; otherwise, SomePointer<U, Args> if Ptr is a class template instantiation of the form SomePointer<T, Args>, where Args is zero or more type arguments ; otherwise, the instantiation of rebind is ill\-formed\&.
.sp
For portable code for C++03 and C++11,
<preformatted>typename rebind_pointer<U>::type</preformatted>
shall be used instead of rebind<U> to obtain a pointer to U\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" exists: Struct template pointer_traits
.\" Struct template pointer_traits: exists
.\" reference: Struct template pointer_traits
.\" Struct template pointer_traits: reference

typedef
unspecified_type
reference;
.sp
Ptr::reference if such a type exists (non\-standard extension); otherwise, element_type &
.RE

.SS "pointer_traits public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" pointer: Struct template pointer_traits
.\" Struct template pointer_traits: pointer
.\" pointer_to: Struct template pointer_traits
.\" Struct template pointer_traits: pointer_to

.sp

.nf
static pointer pointer_to(reference r);
.fi

.sp
\fBRemark\fR: If element_type is (possibly cv\-qualified) void, r type is unspecified; otherwise, it is element_type &\&.
.sp
\fBReturns\fR: A dereferenceable pointer to r obtained by calling Ptr::pointer_to(reference)\&. Non\-standard extension: If such function does not exist, returns pointer(addressof(r));
.sp
\fBNote\fR: For non\-conforming compilers only the existence of a member function called
pointer_to
is checked\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" pointer_to: Struct template pointer_traits
.\" Struct template pointer_traits: pointer_to
.\" static_cast_from: Struct template pointer_traits
.\" Struct template pointer_traits: static_cast_from

.sp

.nf
template<typename UPtr> static pointer static_cast_from(const UPtr & uptr);
.fi

.sp
\fBRemark\fR: Non\-standard extension\&.
.sp
\fBReturns\fR: A dereferenceable pointer to r obtained by calling the static template function Ptr::static_cast_from(UPpr/const UPpr &)\&. If such function does not exist, returns pointer_to(static_cast<element_type&>(*uptr))
.sp
\fBNote\fR: For non\-conforming compilers only the existence of a member function called
static_cast_from
is checked\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" pointer_to: Struct template pointer_traits
.\" Struct template pointer_traits: pointer_to
.\" const_cast_from: Struct template pointer_traits
.\" Struct template pointer_traits: const_cast_from

.sp

.nf
template<typename UPtr> static pointer const_cast_from(const UPtr & uptr);
.fi

.sp
\fBRemark\fR: Non\-standard extension\&.
.sp
\fBReturns\fR: A dereferenceable pointer to r obtained by calling the static template function Ptr::const_cast_from<UPtr>(UPpr/const UPpr &)\&. If such function does not exist, returns pointer_to(const_cast<element_type&>(*uptr))
.sp
\fBNote\fR: For non\-conforming compilers only the existence of a member function called
const_cast_from
is checked\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" pointer_to: Struct template pointer_traits
.\" Struct template pointer_traits: pointer_to
.\" dynamic_cast_from: Struct template pointer_traits
.\" Struct template pointer_traits: dynamic_cast_from

.sp

.nf
template<typename UPtr> static pointer dynamic_cast_from(const UPtr & uptr);
.fi

.sp
\fBRemark\fR: Non\-standard extension\&.
.sp
\fBReturns\fR: A dereferenceable pointer to r obtained by calling the static template function Ptr::dynamic_cast_from<UPtr>(UPpr/const UPpr &)\&. If such function does not exist, returns pointer_to(\fIdynamic_cast<element_type\fR>(&*uptr))
.sp
\fBNote\fR: For non\-conforming compilers only the existence of a member function called
dynamic_cast_from
is checked\&.
.RE


