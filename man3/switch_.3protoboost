.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE S" 3 "" "" ""
.SH "NAME"
boost::proto::switch_ \- For matching one of a set of alternate grammars, which are looked up based on the result type of the transform passed in second template parameter\&. If no transform is passed, the default one is proto::tag_of<proto::_>() so the default matching is based on the expression\'s tag type\&. When used as a transform, proto::switch_<> applies the transform associated with the sub\-grammar that matches the expression\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/matches\&.hpp>

template<typename Cases, typename Transform> 
struct switch_ :  proto::transform<switch_<Cases, Transform> > {
  // types
  typedef switch_ proto_grammar;

  // member classes/structs/unions
  template<typename Expr, typename State, typename Data> 
  struct impl :  
    Cases::template case_<
      typename when<_, Transform>::template impl<Expr, State, Data>::result_type 
    >::template impl<Expr, State, Data>
  {
  };
};
.fi
.SH "DESCRIPTION"
.PP
An expression type
E
matches
proto::switch_<C,T>
if
E
matches
C::case_<boost::result_of<proto::when<proto::_,T>(E)>::type>\&.
.PP
When applying
proto::switch_<C,T>
as a transform with an expression
e
of type
E, state
s
of type
S
and data
d
of type
D, it is equivalent to
C::case_<boost::result_of<proto::when<proto::_,T>(E,S,D)>::type>()(e, s, d)\&.

