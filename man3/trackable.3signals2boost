.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TRACKABLE" 3 "" "" ""
.SH "NAME"
boost::signals2::trackable \- Provided to ease porting for code using the boost::signals::trackable class from the original Boost\&.Signals library\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/signals2/trackable\&.hpp>


class trackable {
public:
  // construct/copy/destruct
  trackable();
  trackable(const trackable&);
  trackable& operator=(const trackable&);
  ~trackable();
};
.fi
.SH "DESCRIPTION"
.PP
Use of the
trackable
class is not recommended for new code\&. The
trackable
class is not thread\-safe since
trackable
objects disconnect their associated connections in the
trackable
destructor\&. Since the
trackable
destructor is not run until after the destructors of any derived classes have completed, that leaves open a window where a partially destructed object can still have active connections\&.
.PP
The preferred method of automatic connection management with Boost\&.Signals2 is to manage the lifetime of tracked objects with
shared_ptrs and to use the
signals2::slot::track
method to track their lifetimes\&.
.PP
The
trackable
class provides automatic disconnection of signals and slots when objects bound in slots (via pointer or reference) are destroyed\&.
trackable
class may only be used as a public base class for some other class; when used as such, that class may be bound to function objects used as part of slots\&. The manner in which a
trackable
object tracks the set of signal\-slot connections it is a part of is unspecified\&.
.PP
The actual use of
trackable
is contingent on the presence of appropriate visit_each overloads for any type that may contain pointers or references to trackable objects\&.
.SS "trackable public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
trackable();
.fi

.PP
Effects:
.RS 4
Sets the list of connected slots to empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
trackable(const trackable& other);
.fi

.PP
Effects:
.RS 4
Sets the list of connected slots to empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.PP
Rationale:
.RS 4
Signal\-slot connections can only be created via calls to an explicit connect method, and therefore cannot be created here when trackable objects are copied\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
trackable& operator=(const trackable& other);
.fi

.PP
Effects:
.RS 4
Sets the list of connected slots to empty\&.
.RE
.PP
Returns:
.RS 4
*this
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.PP
Rationale:
.RS 4
Signal\-slot connections can only be created via calls to an explicit connect method, and therefore cannot be created here when trackable objects are copied\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
~trackable();
.fi

.PP
Effects:
.RS 4
Disconnects all signal/slot connections that contain a pointer or reference to this trackable object that can be found by visit_each\&.
.RE
.RE


