.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TE" 3 "" "" ""
.SH "NAME"
boost::intrusive::circular_slist_algorithms
.SH "SYNOPSIS"
.\" unlink_after: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: unlink_after
.\" unlink: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: unlink
.\" unique: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: unique
.\" swap_nodes: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: swap_nodes
.\" reverse: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: reverse
.\" node_traits: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: node_traits
.\" node_ptr: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: node_ptr
.\" node: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: node
.\" move_forward: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: move_forward
.\" move_backwards: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: move_backwards
.\" link_before: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: link_before
.\" link_after: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: link_after
.\" inited: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: inited
.\" init_header: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: init_header
.\" init: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: init
.\" get_previous_previous_node: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: get_previous_previous_node
.\" get_previous_node: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: get_previous_node
.\" count: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: count
.\" const_node_ptr: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: const_node_ptr

.sp
.nf
// In header: <boost/intrusive/circular_slist_algorithms\&.hpp>

template<typename NodeTraits> 
class circular_slist_algorithms {
public:
  // types
  typedef NodeTraits::node           node;          
  typedef NodeTraits::node_ptr       node_ptr;      
  typedef NodeTraits::const_node_ptr const_node_ptr;
  typedef NodeTraits                 node_traits;   

  // public static functions
  static void init(node_ptr);
  static bool unique(const_node_ptr);
  static bool inited(const_node_ptr);
  static void unlink_after(node_ptr);
  static void unlink_after(node_ptr, node_ptr);
  static void link_after(node_ptr, node_ptr);
  static void transfer_after(node_ptr, node_ptr, node_ptr);
  static void init_header(const node_ptr &);
  static node_ptr get_previous_node(const node_ptr &, const node_ptr &);
  static node_ptr get_previous_node(const node_ptr &);
  static node_ptr get_previous_previous_node(const node_ptr &);
  static node_ptr get_previous_previous_node(node_ptr, const node_ptr &);
  static std::size_t count(const const_node_ptr &);
  static void unlink(const node_ptr &);
  static void link_before(const node_ptr &, const node_ptr &);
  static void swap_nodes(const node_ptr &, const node_ptr &);
  static void reverse(const node_ptr &);
  static node_ptr move_backwards(const node_ptr &, std::size_t);
  static node_ptr move_forward(const node_ptr &, std::size_t);
};
.fi
.SH "DESCRIPTION"
.\" set_next: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: set_next
.\" get_next: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: get_next
.PP
circular_slist_algorithms
provides basic algorithms to manipulate nodes forming a circular singly linked list\&. An empty circular list is formed by a node whose pointer to the next node points to itself\&.
.PP
circular_slist_algorithms
is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated\&. NodeTraits must support the following interface:
.PP
\fBTypedefs\fR:
.PP
node: The type of the node that forms the circular list
.PP
node_ptr: A pointer to a node
.PP
const_node_ptr: A pointer to a const node
.PP
\fBStatic functions\fR:
.PP
static node_ptr get_next(const_node_ptr n);
.PP
static void set_next(node_ptr n, node_ptr next);
.SS "circular_slist_algorithms public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" init: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: init

.sp

.nf
static void init(node_ptr this_node);
.fi

.sp
\fBEffects\fR: Constructs an non\-used list element, putting the next pointer to null:
NodeTraits::get_next(this_node) == node_ptr()
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" node_ptr: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: node_ptr
.\" unique: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: unique

.sp

.nf
static bool unique(const_node_ptr this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Returns true is "this_node" is the only node of a circular list: or it\'s a not inserted node:
return node_ptr() == NodeTraits::get_next(this_node) || NodeTraits::get_next(this_node) == this_node
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" inited: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: inited

.sp

.nf
static bool inited(const_node_ptr this_node);
.fi

.sp
\fBEffects\fR: Returns true is "this_node" has the same state as if it was inited using "init(node_ptr)"
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlink_after: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: unlink_after

.sp

.nf
static void unlink_after(node_ptr prev_node);
.fi

.sp
\fBRequires\fR: prev_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Unlinks the next node of prev_node from the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" range: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: range
.\" unlink_after: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: unlink_after

.sp

.nf
static void unlink_after(node_ptr prev_node, node_ptr last_node);
.fi

.sp
\fBRequires\fR: prev_node and last_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Unlinks the range (prev_node, last_node) from the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" link_after: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: link_after

.sp

.nf
static void link_after(node_ptr prev_node, node_ptr this_node);
.fi

.sp
\fBRequires\fR: prev_node must be a node of a circular list\&.
.sp
\fBEffects\fR: Links this_node after prev_node in the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
static void transfer_after(node_ptr p, node_ptr b, node_ptr e);
.fi

.sp
\fBRequires\fR: b and e must be nodes of the same circular list or an empty range\&. and p must be a node of a different circular list\&.
.sp
\fBEffects\fR: Removes the nodes from (b, e] range from their circular list and inserts them after p in p\'s circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" init_header: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: init_header

.sp

.nf
static void init_header(const node_ptr & this_node);
.fi

.sp
\fBEffects\fR: Constructs an empty list, making this_node the only node of the circular list:
NodeTraits::get_next(this_node) == this_node\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" get_previous_node: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: get_previous_node

.sp

.nf
static node_ptr 
get_previous_node(const node_ptr & prev_init_node, const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node and prev_init_node must be in the same circular list\&.
.sp
\fBEffects\fR: Returns the previous node of this_node in the circular list starting\&. the search from prev_init_node\&. The first node checked for equality is NodeTraits::get_next(prev_init_node)\&.
.sp
\fBComplexity\fR: Linear to the number of elements between prev_init_node and this_node\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" get_previous_node: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: get_previous_node

.sp

.nf
static node_ptr get_previous_node(const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Returns the previous node of this_node in the circular list\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the circular list\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" get_previous_previous_node: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: get_previous_previous_node

.sp

.nf
static node_ptr get_previous_previous_node(const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Returns the previous node of the previous node of this_node in the circular list\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the circular list\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" get_previous_previous_node: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: get_previous_previous_node

.sp

.nf
static node_ptr 
get_previous_previous_node(node_ptr p, const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node and p must be in the same circular list\&.
.sp
\fBEffects\fR: Returns the previous node of the previous node of this_node in the circular list starting\&. the search from p\&. The first node checked for equality is NodeTraits::get_next((NodeTraits::get_next(p))\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the circular list\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" count: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: count

.sp

.nf
static std::size_t count(const const_node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Returns the number of nodes in a circular list\&. If the circular list is empty, returns 1\&.
.sp
\fBComplexity\fR: Linear
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" unlink: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: unlink

.sp

.nf
static void unlink(const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list, be an empty circular list or be inited\&.
.sp
\fBEffects\fR: Unlinks the node from the circular list\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the circular list
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" link_before: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: link_before

.sp

.nf
static void link_before(const node_ptr & nxt_node, const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: nxt_node must be a node of a circular list\&.
.sp
\fBEffects\fR: Links this_node before nxt_node in the circular list\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the circular list\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" swap_nodes: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: swap_nodes

.sp

.nf
static void swap_nodes(const node_ptr & this_node, 
                       const node_ptr & other_node);
.fi

.sp
\fBRequires\fR: this_node and other_node must be nodes inserted in circular lists or be empty circular lists\&.
.sp
\fBEffects\fR: Swaps the position of the nodes: this_node is inserted in other_nodes position in the second circular list and the other_node is inserted in this_node\'s position in the first circular list\&.
.sp
\fBComplexity\fR: Linear to number of elements of both lists
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" reverse: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: reverse

.sp

.nf
static void reverse(const node_ptr & p);
.fi

.sp
\fBEffects\fR: Reverses the order of elements in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: This function is linear to the contained elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" move_backwards: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: move_backwards

.sp

.nf
static node_ptr move_backwards(const node_ptr & p, std::size_t n);
.fi

.sp
\fBEffects\fR: Moves the node p n positions towards the end of the list\&.
.sp
\fBReturns\fR: The previous node of p after the function if there has been any movement, Null if n leads to no movement\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements plus the number moved positions\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" move_forward: Class template circular_slist_algorithms
.\" Class template circular_slist_algorithms: move_forward

.sp

.nf
static node_ptr move_forward(const node_ptr & p, std::size_t n);
.fi

.sp
\fBEffects\fR: Moves the node p n positions towards the beginning of the list\&.
.sp
\fBReturns\fR: The previous node of p after the function if there has been any movement, Null if n leads equals to no movement\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements plus the number moved positions\&.
.RE


