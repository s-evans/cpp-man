.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTION TE" 3 "" "" ""
.SH "NAME"
boost::mpi::get_mpi_datatype \- Returns an MPI data type for a C++ type\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/mpi/datatype\&.hpp>


template<typename T> MPI_Datatype get_mpi_datatype(const T & x);
.fi
.SH "DESCRIPTION"
.PP
The function creates an MPI data type for the given object
x\&. The first time it is called for a class
T, the MPI data type is created and cached\&. Subsequent calls for objects of the same type
T
return the cached MPI data type\&. The type
T
must allow creation of an MPI data type\&. That is, it must be Serializable and
is_mpi_datatype<T>
must derive
mpl::true_\&.
.PP
For fundamental MPI types, a copy of the MPI data type of the MPI library is returned\&.
.PP
Note that since the data types are cached, the caller should never call
MPI_Type_free()
for the MPI data type returned by this call\&.
.PP

.PP
Parameters:
.RS 4
.PP
x
.RS 4
for an optimized call, a constructed object of the type should be passed; otherwise, an object will be default\-constructed\&.
.RE
.RE
.PP
Returns:
.RS 4
The MPI data type corresponding to type
T\&.
.RE

