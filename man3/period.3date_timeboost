.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE PER" 3 "" "" ""
.SH "NAME"
boost::date_time::period \- Provides generalized period type useful in date\-time systems\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/period\&.hpp>

template<typename point_rep, typename duration_rep> 
class period : private boost::less_than_comparable< period< point_rep, duration_rep >, boost::equality_comparable< period< point_rep, duration_rep > > >
{
public:
  // types
  typedef point_rep    point_type;   
  typedef duration_rep duration_type;

  // construct/copy/destruct
  period(point_rep, point_rep);
  period(point_rep, duration_rep);

  // public member functions
  point_rep begin() const;
  point_rep end() const;
  point_rep last() const;
  duration_rep length() const;
  bool is_null() const;
  bool operator==(const period &) const;
  bool operator<(const period &) const;
  void shift(const duration_rep &);
  void expand(const duration_rep &);
  bool contains(const point_rep &) const;
  bool contains(const period &) const;
  bool intersects(const period &) const;
  bool is_adjacent(const period &) const;
  bool is_before(const point_rep &) const;
  bool is_after(const point_rep &) const;
  period intersection(const period &) const;
  period merge(const period &) const;
  period span(const period &) const;
};
.fi
.SH "DESCRIPTION"
.PP
This template uses a class to represent a time point within the period and another class to represent a duration\&. As a result, this class is not appropriate for use when the number and duration representation are the same (eg: in the regular number domain)\&.
.PP
A period can be specified by providing either the begining point and a duration or the begining point and the end point( end is NOT part of the period but 1 unit past it\&. A period will be "invalid" if either end_point <= begin_point or the given duration is <= 0\&. Any valid period will return false for is_null()\&.
.PP
Zero length periods are also considered invalid\&. Zero length periods are periods where the begining and end points are the same, or, the given duration is zero\&. For a zero length period, the last point will be one unit less than the begining point\&.
.PP
In the case that the begin and last are the same, the period has a length of one unit\&.
.PP
The best way to handle periods is usually to provide a begining point and a duration\&. So, day1 + 7 days is a week period which includes all of the first day and 6 more days (eg: Sun to Sat)\&.
.SS "period public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
period(point_rep first_point, point_rep end_point);
.fi

.sp
create a period from begin to last eg: [begin,end) If end <= begin then the period will be invalid
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
period(point_rep first_point, duration_rep len);
.fi

.sp
create a period as [begin, begin+len) If len is <= 0 then the period will be invalid
.RE

.SS "period public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
point_rep begin() const;
.fi

Return the first element in the period\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
point_rep end() const;
.fi

Return one past the last element\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
point_rep last() const;
.fi

Return the last item in the period\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
duration_rep length() const;
.fi

Return the length of the period\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool is_null() const;
.fi

True if period is ill formed (length is zero or less) .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
bool operator==(const period & rhs) const;
.fi

Equality operator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool operator<(const period & rhs) const;
.fi

Strict as defined by rhs\&.last <= lhs\&.last\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
void shift(const duration_rep & d);
.fi

Shift the start and end by the specified amount\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
void expand(const duration_rep & d);
.fi

.sp
Expands the size of the period by the duration on both ends\&.
.sp
So before expand

.sp
.if n \{\
.RS 4
.\}
.nf
        [\-\-\-\-\-\-\-]
^   ^   ^   ^   ^   ^  ^
1   2   3   4   5   6  7

.fi
.if n \{\
.RE
.\}
.sp
After expand(2)

.sp
.if n \{\
.RS 4
.\}
.nf
[\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-]
^   ^   ^   ^   ^   ^  ^
1   2   3   4   5   6  7

.fi
.if n \{\
.RE
.\}
.sp

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool contains(const point_rep & point) const;
.fi

True if the point is inside the period, zero length periods contain no points\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
bool contains(const period & other) const;
.fi

True if this period fully contains (or equals) the other period\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool intersects(const period & other) const;
.fi

True if the periods overlap in any way\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
bool is_adjacent(const period & other) const;
.fi

True if periods are next to each other without a gap\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
bool is_before(const point_rep & point) const;
.fi

True if all of the period is prior to the passed point or end <= t\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
bool is_after(const point_rep & point) const;
.fi

True if all of the period is prior or t < start\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
period intersection(const period & other) const;
.fi

Returns the period of intersection or invalid range no intersection\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
period merge(const period & other) const;
.fi

Returns the union of intersecting periods <ndash></ndash> or null period\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
period span(const period & other) const;
.fi

.sp
Combine two periods with earliest start and latest end\&. Combines two periods and any gap between them such that start = min(p1\&.start, p2\&.start) end = max(p1\&.end , p2\&.end)

.sp
.if n \{\
.RS 4
.\}
.nf
       [\-\-\-p1\-\-\-)
                      [\-\-\-p2\-\-\-)
result:
       [\-\-\-\-\-\-\-\-\-\-\-p3\-\-\-\-\-\-\-\-\-\-) 

.fi
.if n \{\
.RE
.\}
.sp

.RE


