.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_SCOPE" 3 "" "" ""
.SH "NAME"
BOOST_SCOPE_EXIT \- This macro declares a scope exit\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/scope_exit\&.hpp>

BOOST_SCOPE_EXIT(capture_list)
.fi
.SH "DESCRIPTION"
.PP
The scope exit declaration schedules the execution of the scope exit body at the exit of the enclosing scope:
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
{ // Some local scope\&.
    \&.\&.\&.
    BOOST_SCOPE_EXIT(capture_list) {
        \&.\&.\&. // Body code\&.
    } BOOST_SCOPE_EXIT_END
    \&.\&.\&.
}

.fi
.if n \{\
.RE
.\}

.PP
The enclosing scope must be local\&. If multiple scope exits are declared within the same enclosing scope, the scope exit bodies are executed in the reversed order of their declarations\&. Note how the end of the scope exit body must be marked by
BOOST_SCOPE_EXIT_END\&.
.PP
\fBParameters:\fR
.TS
allbox tab(:);
l l.
T{
\fBcapture_list\fR
T}:T{
On compilers that support variadic macros (see also Boost\&.Config BOOST_NO_CXX11_VARIADIC_MACROS), the capture list syntax is defined by the following grammar: .if n \{\
.RS 4
.\}
.nf
capture_list:
        void | capture_tuple | capture_sequence
capture_tuple:
        capture, capture, \&.\&.\&.
capture_sequence:
        (capture) (capture) \&.\&.\&.
capture:
        [&]variable | this_

.fi
.if n \{\
.RE
.\}
.sp
 On compilers that do not support variadic macros, capture_tuple cannot be used: .if n \{\
.RS 4
.\}
.nf
capture_list:
        void | capture_sequence

.fi
.if n \{\
.RE
.\}
.sp
 Furthermore, if BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS is defined on C++11 compilers that support lambda functions (i\&.e\&., Boost\&.Config\'s BOOST_NO_CXX11_LAMBDAS is not defined) then a semicolon ; can be used instead of  BOOST_SCOPE_EXIT_END and this can be used instead of this_: .if n \{\
.RS 4
.\}
.nf
capture:
        [&]variable | this_ | this

.fi
.if n \{\
.RE
.\}
.sp
(Lexical conventions: token1 | token2 means either token1 or token2; [token] means either token or nothing; {expression} means the tokens resulting from the expression\&.)
T}
.TE
.sp 1

.PP
Note that on compilers that support variadic macros (most of moder compliers and all C++11 compilers), the capture list can be specified as a comma\-separated list of tokens (this is the preferred syntax)\&. However, on all compilers the same macro
BOOST_SCOPE_EXIT
also allows to specify the capture list as a Boost\&.Preprocessor sequence of tokens (for supporting compilers without variadic macros and for backward compatibility with older versions of this library)\&.
.PP
The name
variable
of each captured variable must be a valid name in the enclosing scope and it must appear exactly once in the capture list\&. If a capture starts with the ampersand sign
&, the corresponding variable will be available by reference within the scope exit body; otherwise, a copy of the variable will be made at the point of the scope exit declaration and that copy will be available inside the scope exit body (in this case, the variable\'s type must be
CopyConstructible)\&.
.PP
From within a member function, the object
this
can be captured using the special name
this_
in both the capture list and the scope exit body (using
this
instead of
this_
in the scope exit body leads to undefined behaviour)\&.
.PP
It is possible to capture no variable by specifying the capture list as
void
(regardless of variadic macro support)\&.
.PP
Only variables listed in the capture list, static variables,
extern
variables, global variables, functions, and enumerations from the enclosing scope can be used inside the scope exit body\&.
.PP
On various GCC versions the special macro
BOOST_SCOPE_EXIT_TPL
must be used instead of
BOOST_SCOPE_EXIT
within templates (to maximize portability, it is recommended to always use
BOOST_SCOPE_EXIT_TPL
within templates)\&.
.PP
On C++11, it is possible capture all variables in scope without listing their names one\-by\-one using the macro
BOOST_SCOPE_EXIT_ALL\&.
.PP
In general, the special macro
BOOST_SCOPE_EXIT_ID
must be used instead of
BOOST_SCOPE_EXIT
when it is necessary to expand multiple scope exit declarations on the same line\&.
.PP
\fBWarning:\fR
The implementation executes the scope exit body within a destructor thus the scope exit body must never throw in order to comply with STL exception safety requirements\&.
.PP
\fBNote:\fR
The implementation uses Boost\&.Typeof to automatically deduce the types of the captured variables\&. In order to compile code in type\-of emulation mode, all types must be properly registered with Boost\&.Typeof (see the
Getting Started
section)\&.
.PP
\fBSee:\fR
Tutorial
section,
Getting Started
section,
No Variadic Macros
section,
BOOST_SCOPE_EXIT_TPL,
BOOST_SCOPE_EXIT_ALL,
BOOST_SCOPE_EXIT_END,
BOOST_SCOPE_EXIT_ID\&.

