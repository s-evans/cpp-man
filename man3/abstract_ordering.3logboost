.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::log::abstract_ordering \- Ordering predicate, based on opaque pointers to the record view implementation data\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/utility/record_ordering\&.hpp>

template<typename FunT = less> 
class abstract_ordering : private FunT {
public:
  // types
  typedef bool result_type;  // Result type\&. 

  // construct/copy/destruct
  abstract_ordering();
  explicit abstract_ordering(FunT const &);

  // public member functions
  result_type operator()(record_view const &, record_view const &) const;
};
.fi
.SH "DESCRIPTION"
.PP
Since record views only refer to a shared implementation data, this predicate is able to order the views by comparing the pointers to the data\&. Therefore two views are considered to be equivalent if they refer to the same implementation data\&. Otherwise it is not specified whether one record is ordered before the other until the predicate is applied\&. Note that the ordering may change every time the application runs\&.
.PP
This kind of ordering may be useful if log records are to be stored in an associative container with as least performance overhead as possible, when the particular order is not important\&.
.PP
The
FunT
template argument is the predicate that is used to actually compare pointers\&. It should be able to compare
const void*
pointers\&. The compared pointers may refer to distinct memory regions, the pointers must not be interpreted in any way\&.
.SS "abstract_ordering public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
abstract_ordering();
.fi

.sp
Default constructor\&. Requires
FunT
to be default constructible\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit abstract_ordering(FunT const & fun);
.fi

.sp
Initializing constructor\&. Constructs
FunT
instance as a copy of the
\fIfun\fR
argument\&.
.RE

.SS "abstract_ordering public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
result_type operator()(record_view const & left, record_view const & right) const;
.fi

.sp
Ordering operator
.RE


