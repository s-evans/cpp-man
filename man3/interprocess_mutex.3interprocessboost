.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS INTERPROCE" 3 "" "" ""
.SH "NAME"
boost::interprocess::interprocess_mutex
.SH "SYNOPSIS"
.\" unlock: Class interprocess_mutex
.\" Class interprocess_mutex: unlock
.\" try_lock: Class interprocess_mutex
.\" Class interprocess_mutex: try_lock
.\" timed_lock: Class interprocess_mutex
.\" Class interprocess_mutex: timed_lock
.\" lock: Class interprocess_mutex
.\" Class interprocess_mutex: lock
.\" interprocess_mutex: Class interprocess_mutex
.\" Class interprocess_mutex: interprocess_mutex
.\" interprocess_mutex: Class interprocess_mutex
.\" Class interprocess_mutex: interprocess_mutex

.sp
.nf
// In header: <boost/interprocess/sync/interprocess_mutex\&.hpp>


class interprocess_mutex {
public:
  // construct/copy/destruct
  interprocess_mutex();
  ~interprocess_mutex();

  // public member functions
  void lock();
  bool try_lock();
  bool timed_lock(const boost::posix_time::ptime &);
  void unlock();
};
.fi
.SH "DESCRIPTION"
.PP
Wraps a
interprocess_mutex
that can be placed in shared memory and can be shared between processes\&. Allows timed lock tries
.SS "interprocess_mutex public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
interprocess_mutex();
.fi

.sp
Constructor\&. Throws
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
~interprocess_mutex();
.fi

.sp
Destructor\&. If any process uses the mutex after the destructor is called the result is undefined\&. Does not throw\&.
.RE

.SS "interprocess_mutex public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" lock: Class interprocess_mutex
.\" Class interprocess_mutex: lock

.sp

.nf
void lock();
.fi

.sp
Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership\&. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" try_lock: Class interprocess_mutex
.\" Class interprocess_mutex: try_lock

.sp

.nf
bool try_lock();
.fi

.sp
Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex returns immediately\&. Returns: If the thread acquires ownership of the mutex, returns true, if the another thread has ownership of the mutex, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" timed_lock: Class interprocess_mutex
.\" Class interprocess_mutex: timed_lock

.sp

.nf
bool timed_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread will try to obtain exclusive ownership of the mutex if it can do so in until the specified time is reached\&. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked\&. Returns: If the thread acquires ownership of the mutex, returns true, if the timeout expires returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlock: Class interprocess_mutex
.\" Class interprocess_mutex: unlock

.sp

.nf
void unlock();
.fi

.sp
Effects: The calling thread releases the exclusive ownership of the mutex\&. Throws:
interprocess_exception
on error\&.
.RE


