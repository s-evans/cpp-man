.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STR" 3 "" "" ""
.SH "NAME"
boost::container::constructible_with_allocator_prefix
.SH "SYNOPSIS"
.\" constructible_with_allocator_prefix: Struct template constructible_with_allocator_prefix
.\" Struct template constructible_with_allocator_prefix: constructible_with_allocator_prefix

.sp
.nf
// In header: <boost/container/scoped_allocator\&.hpp>

template<typename T> 
struct constructible_with_allocator_prefix {

  // public data members
  static const bool value;
};
.fi
.SH "DESCRIPTION"
.\" constructible_with_allocator_prefix: Struct template constructible_with_allocator_prefix
.\" Struct template constructible_with_allocator_prefix: constructible_with_allocator_prefix
.\" allocator: Struct template constructible_with_allocator_prefix
.\" Struct template constructible_with_allocator_prefix: allocator
.\" allocator_type: Struct template constructible_with_allocator_prefix
.\" Struct template constructible_with_allocator_prefix: allocator_type
.\" allocator: Struct template constructible_with_allocator_prefix
.\" Struct template constructible_with_allocator_prefix: allocator
.PP
\fBRemark\fR: if a specialization constructible_with_allocator_prefix<X>::value is true, indicates that T may be constructed with allocator_arg and T::allocator_type as its first two constructor arguments\&. Ideally, all constructors of T (including the copy and move constructors) should have a variant that accepts these two initial arguments\&.
.PP
\fBRequires\fR: specialization constructible_with_allocator_prefix<X>::value is true, T must have a nested type, allocator_type and at least one constructor for which allocator_arg_t is the first parameter and allocator_type is the second parameter\&. If not all constructors of T can be called with these initial arguments, and if T is used in a context where a container must call such a constructor, then the program is ill\-formed\&.
.PP
template <class T, class Allocator = allocator<T> > class Y { public: typedef Allocator allocator_type;
.PP
// Default constructor with and allocator\-extended default constructor Y(); Y(allocator_arg_t, const allocator_type& a);
.PP
// Copy constructor and allocator\-extended copy constructor Y(const Y& yy); Y(allocator_arg_t, const allocator_type& a, const Y& yy);
.PP
// Variadic constructor and allocator\-extended variadic constructor template<class \&.\&.\&.Args> Y(Args&& args\&.\&.\&.); template<class \&.\&.\&.Args> Y(allocator_arg_t, const allocator_type& a, BOOST_FWD_REF(Args)\&.\&.\&. args); };
.PP
// Specialize trait for class template Y template <class T, class Allocator = allocator<T> > struct constructible_with_allocator_prefix<Y<T,Allocator> > { static const bool value = true; };
.PP

.PP
\fBNote\fR: This trait is a workaround inspired by "N2554: The Scoped Allocator Model (Rev 2)" (Pablo Halpern, 2008\-02\-29) to backport the scoped allocator model to C++03, as in C++03 there is no mechanism to detect if a type can be constructed from arbitrary arguments\&. Applications aiming portability with several compilers should always define this trait\&.
.PP
In conforming C++11 compilers or compilers supporting SFINAE expressions (when BOOST_NO_SFINAE_EXPR is NOT defined), this trait is ignored and C++11 rules will be used to detect if a type should be constructed with suffix or prefix allocator arguments\&.

