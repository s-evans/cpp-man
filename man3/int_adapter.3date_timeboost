.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::date_time::int_adapter \- Adapter to create integer types with +\-infinity, and not a value\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/int_adapter\&.hpp>

template<typename int_type_> 
class int_adapter {
public:
  // types
  typedef int_type_ int_type;

  // construct/copy/destruct
  int_adapter(int_type);

  // public member functions
  bool is_infinity() const;
  bool is_pos_infinity() const;
  bool is_neg_infinity() const;
  bool is_nan() const;
  bool is_special() const;
  bool operator==(const int_adapter &) const;
  bool operator==(const int &) const;
  bool operator!=(const int_adapter &) const;
  bool operator!=(const int &) const;
  bool operator<(const int_adapter &) const;
  bool operator<(const int &) const;
  bool operator>(const int_adapter &) const;
  int_type as_number() const;
  special_values as_special() const;
  template<typename rhs_type> 
    int_adapter operator+(const int_adapter< rhs_type > &) const;
  int_adapter operator+(const int_type) const;
  template<typename rhs_type> 
    int_adapter operator\-(const int_adapter< rhs_type > &) const;
  int_adapter operator\-(const int_type) const;
  int_adapter operator*(const int_adapter &) const;
  int_adapter operator*(const int) const;
  int_adapter operator/(const int_adapter &) const;
  int_adapter operator/(const int) const;
  int_adapter operator%(const int_adapter &) const;
  int_adapter operator%(const int) const;

  // public static functions
  static bool has_infinity();
  static const int_adapter pos_infinity();
  static const int_adapter neg_infinity();
  static const int_adapter not_a_number();
  static int_adapter max BOOST_PREVENT_MACRO_SUBSTITUTION();
  static int_adapter min BOOST_PREVENT_MACRO_SUBSTITUTION();
  static int_adapter from_special(special_values);
  static bool is_inf(int_type);
  static bool is_neg_inf(int_type);
  static bool is_pos_inf(int_type);
  static bool is_not_a_number(int_type);
  static special_values to_special(int_type);
  static int_type maxcount();

  // private member functions
  int compare(const int_adapter &) const;
  int_adapter mult_div_specials(const int_adapter &) const;
  int_adapter mult_div_specials(const int &) const;
};
.fi
.SH "DESCRIPTION"
.PP
This class is used internally in counted date/time representations\&. It adds the floating point like features of infinities and not a number\&. It also provides mathmatical operations with consideration to special values following these rules:

.sp
.if n \{\
.RS 4
.\}
.nf
+infinity  \-  infinity  == Not A Number (NAN)
 infinity  *  non\-zero  == infinity
 infinity  *  zero      == NAN
+infinity  * \-integer   == \-infinity
 infinity  /  infinity  == NAN
 infinity  *  infinity  == infinity 

.fi
.if n \{\
.RE
.\}
.sp

.SS "int_adapter public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
int_adapter(int_type v);
.fi

.RE

.SS "int_adapter public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool is_infinity() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool is_pos_infinity() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool is_neg_infinity() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
bool is_nan() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool is_special() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
bool operator==(const int_adapter & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool operator==(const int & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
bool operator!=(const int_adapter & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
bool operator!=(const int & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool operator<(const int_adapter & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
bool operator<(const int & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool operator>(const int_adapter & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
int_type as_number() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
special_values as_special() const;
.fi

Returns either special value type or is_not_special\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
template<typename rhs_type> 
  int_adapter operator+(const int_adapter< rhs_type > & rhs) const;
.fi

.sp
Operator allows for adding dissimilar
int_adapter
types\&. The return type will match that of the the calling object\'s type
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
int_adapter operator+(const int_type rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
template<typename rhs_type> 
  int_adapter operator\-(const int_adapter< rhs_type > & rhs) const;
.fi

.sp
Operator allows for subtracting dissimilar
int_adapter
types\&. The return type will match that of the the calling object\'s type
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
int_adapter operator\-(const int_type rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
int_adapter operator*(const int_adapter & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
int_adapter operator*(const int rhs) const;
.fi

.sp
Provided for cases when automatic conversion from \'int\' to \'int_adapter\' causes incorrect results\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
int_adapter operator/(const int_adapter & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
int_adapter operator/(const int rhs) const;
.fi

.sp
Provided for cases when automatic conversion from \'int\' to \'int_adapter\' causes incorrect results\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
int_adapter operator%(const int_adapter & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
int_adapter operator%(const int rhs) const;
.fi

.sp
Provided for cases when automatic conversion from \'int\' to \'int_adapter\' causes incorrect results\&.
.RE

.SS "int_adapter public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static bool has_infinity();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static const int_adapter pos_infinity();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
static const int_adapter neg_infinity();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
static const int_adapter not_a_number();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
static int_adapter max BOOST_PREVENT_MACRO_SUBSTITUTION();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
static int_adapter min BOOST_PREVENT_MACRO_SUBSTITUTION();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
static int_adapter from_special(special_values sv);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
static bool is_inf(int_type v);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
static bool is_neg_inf(int_type v);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
static bool is_pos_inf(int_type v);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
static bool is_not_a_number(int_type v);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
static special_values to_special(int_type v);
.fi

Returns either special value type or is_not_special\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
static int_type maxcount();
.fi

.RE

.SS "int_adapter private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
int compare(const int_adapter & rhs) const;
.fi

returns \-1, 0, 1, or 2 if \'this\' is <, ==, >, or \'nan comparison\' rhs .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
int_adapter mult_div_specials(const int_adapter & rhs) const;
.fi

Assumes at least \'this\' or \'rhs\' is a special value\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
int_adapter mult_div_specials(const int & rhs) const;
.fi

Assumes \'this\' is a special value\&. .RE


