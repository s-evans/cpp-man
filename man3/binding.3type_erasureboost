.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE BI" 3 "" "" ""
.SH "NAME"
boost::type_erasure::binding
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/type_erasure/param\&.hpp>

template<typename Concept> 
class binding {
public:
  // construct/copy/destruct
  binding();
  template<typename Map> explicit binding(const Map &);
  template<typename Map> binding(const static_binding< Map > &);
  template<typename Concept2, typename Map> 
    binding(const binding< Concept2 > &, const Map &);
  template<typename Concept2, typename Map> 
    binding(const binding< Concept2 > &, const static_binding< Map > &);

  // friend functions
  friend bool operator==(const binding &, const binding &);
  friend bool operator!=(const binding &, const binding &);
};
.fi
.SH "DESCRIPTION"
.PP
Stores the binding of a
Concept
to a set of actual types\&.
Concept
is interpreted in the same way as with any\&.
.SS "binding public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
binding();
.fi

.sp

.PP
Requires:
.RS 4
relaxed
must be in
Concept\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Map> explicit binding(const Map &);
.fi

.sp

.PP
Requires:
.RS 4
Map
must be an MPL map with an entry for each placeholder referred to by
Concept\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename Map> binding(const static_binding< Map > &);
.fi

.sp

.PP
Requires:
.RS 4
Map
must be an MPL map with an entry for each placeholder referred to by
Concept\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename Concept2, typename Map> 
  binding(const binding< Concept2 > & other, const Map &);
.fi

.sp
Converts from another set of bindings\&.
.sp

.PP
Requires:
.RS 4
Map must be an MPL map with an entry for each placeholder referred to by
Concept\&. The mapped type should be the corresponding placeholder in Concept2\&.
.RE
.PP
Throws:
.RS 4
std::bad_alloc
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename Concept2, typename Map> 
  binding(const binding< Concept2 > & other, const static_binding< Map > &);
.fi

.sp
Converts from another set of bindings\&.
.sp

.PP
Requires:
.RS 4
Map must be an MPL map with an entry for each placeholder referred to by
Concept\&. The mapped type should be the corresponding placeholder in Concept2\&.
.RE
.PP
Throws:
.RS 4
std::bad_alloc
.RE
.RE

.SS "binding friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const binding & lhs, const binding & rhs);
.fi

.sp

.PP
Returns:
.RS 4
true iff the sets of types that the placeholders bind to are the same for both arguments\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const binding & lhs, const binding & rhs);
.fi

.sp

.PP
Returns:
.RS 4
true iff the arguments do not map to identical sets of types\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


