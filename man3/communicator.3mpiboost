.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS COMMUNICATOR" 3 "" "" ""
.SH "NAME"
boost::mpi::communicator \- A communicator that permits communication and synchronization among a set of processes\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/mpi/communicator\&.hpp>


class communicator {
public:
  // construct/copy/destruct
  communicator();
  communicator(const MPI_Comm &, comm_create_kind);
  communicator(const communicator &, const boost::mpi::group &);

  // public member functions
  int rank() const;
  int size() const;
  boost::mpi::group group() const;
  template<typename T> void send(int, int, const T &) const;
  template<typename T> void send(int, int, const skeleton_proxy< T > &) const;
  template<typename T> void send(int, int, const T *, int) const;
  void send(int, int) const;
  template<typename T> status recv(int, int, T &) const;
  template<typename T> 
    status recv(int, int, const skeleton_proxy< T > &) const;
  template<typename T> status recv(int, int, skeleton_proxy< T > &) const;
  template<typename T> status recv(int, int, T *, int) const;
  status recv(int, int) const;
  template<typename T> 
    status sendrecv(int, int, const T &, int, int, T &) const;
  template<typename T> request isend(int, int, const T &) const;
  template<typename T> 
    request isend(int, int, const skeleton_proxy< T > &) const;
  template<typename T> request isend(int, int, const T *, int) const;
  request isend(int, int) const;
  template<typename T> request irecv(int, int, T &) const;
  template<typename T> request irecv(int, int, T *, int) const;
  request irecv(int, int) const;
  status probe(int = any_source, int = any_tag) const;
  optional< status > iprobe(int = any_source, int = any_tag) const;
  void barrier() const;
  operator bool() const;
  operator MPI_Comm() const;
  communicator split(int) const;
  communicator split(int, int) const;
  optional< intercommunicator > as_intercommunicator() const;
  optional< graph_communicator > as_graph_communicator() const;
  bool has_cartesian_topology() const;
  void abort(int) const;
};
.fi
.SH "DESCRIPTION"
.PP
The
communicator
class abstracts a set of communicating processes in MPI\&. All of the processes that belong to a certain communicator can determine the size of the communicator, their rank within the communicator, and communicate with any other processes in the communicator\&.
.SS "communicator public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
communicator();
.fi

.sp
Build a new Boost\&.MPI communicator for
MPI_COMM_WORLD\&.
.sp
Constructs a Boost\&.MPI communicator that attaches to
MPI_COMM_WORLD\&. This is the equivalent of constructing with
(MPI_COMM_WORLD, comm_attach)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
communicator(const MPI_Comm & comm, comm_create_kind kind);
.fi

.sp
Build a new Boost\&.MPI communicator based on the MPI communicator
comm\&.
.sp
comm
may be any valid MPI communicator\&. If
comm
is MPI_COMM_NULL, an empty communicator (that cannot be used for communication) is created and the
kind
parameter is ignored\&. Otherwise, the
kind
parameters determines how the Boost\&.MPI communicator will be related to
comm:
.sp

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If
kind
is
comm_duplicate, duplicate
comm
to create a new communicator\&. This new communicator will be freed when the Boost\&.MPI communicator (and all copies of it) is destroyed\&. This option is only permitted if
comm
is a valid MPI intracommunicator or if the underlying MPI implementation supports MPI 2\&.0 (which supports duplication of intercommunicators)\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If
kind
is
comm_take_ownership, take ownership of
comm\&. It will be freed automatically when all of the Boost\&.MPI communicators go out of scope\&. This option must not be used when
comm
is MPI_COMM_WORLD\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If
kind
is
comm_attach, this Boost\&.MPI communicator will reference the existing MPI communicator
comm
but will not free
comm
when the Boost\&.MPI communicator goes out of scope\&. This option should only be used when the communicator is managed by the user or MPI library (e\&.g\&., MPI_COMM_WORLD)\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
communicator(const communicator & comm, const boost::mpi::group & subgroup);
.fi

.sp
Build a new Boost\&.MPI communicator based on a subgroup of another MPI communicator\&.
.sp
This routine will construct a new communicator containing all of the processes from communicator
comm
that are listed within the group
subgroup\&. Equivalent to
MPI_Comm_create\&.
.sp

.PP
Parameters:
.RS 4
.PP
comm
.RS 4
An MPI communicator\&.
.RE
.PP
subgroup
.RS 4
A subgroup of the MPI communicator,
comm, for which we will construct a new communicator\&.
.RE
.RE
.RE

.SS "communicator public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
int rank() const;
.fi

.sp
Determine the rank of the executing process in a communicator\&. This routine is equivalent to
MPI_Comm_rank\&.
.sp

.PP
Returns:
.RS 4
The rank of the process in the communicator, which will be a value in [0, size())
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
int size() const;
.fi

.sp
Determine the number of processes in a communicator\&. This routine is equivalent to
MPI_Comm_size\&.
.sp

.PP
Returns:
.RS 4
The number of processes in the communicator\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
boost::mpi::group group() const;
.fi

.sp
This routine constructs a new group whose members are the processes within this communicator\&. Equivalent to calling
MPI_Comm_group\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename T> void send(int dest, int tag, const T & value) const;
.fi

.sp
Send data to another process\&. This routine executes a potentially blocking send with tag
tag
to the process with rank
dest\&. It can be received by the destination process with a matching
recv
call\&.
.sp
The given
value
must be suitable for transmission over MPI\&. There are several classes of types that meet these requirements:
.sp

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Types with mappings to MPI data types: If
is_mpi_datatype<T>
is convertible to
mpl::true_, then
value
will be transmitted using the MPI data type
get_mpi_datatype<T>()\&. All primitive C++ data types that have MPI equivalents, e\&.g\&.,
int,
float,
char,
double, etc\&., have built\-in mappings to MPI data types\&. You may turn a Serializable type with fixed structure into an MPI data type by specializing
is_mpi_datatype
for your type\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Serializable types: Any type that provides the
serialize()
functionality required by the Boost\&.Serialization library can be transmitted and received\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Packed archives and skeletons: Data that has been packed into an
mpi::packed_oarchive
or the skeletons of data that have been backed into an
mpi::packed_skeleton_oarchive
can be transmitted, but will be received as
mpi::packed_iarchive
and
mpi::packed_skeleton_iarchive, respectively, to allow the values (or skeletons) to be extracted by the destination process\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Content: Content associated with a previously\-transmitted skeleton can be transmitted by
send
and received by
recv\&. The receiving process may only receive content into the content of a value that has been constructed with the matching skeleton\&.
.RE
.RS 4

.sp
For types that have mappings to an MPI data type (including the concent of a type), an invocation of this routine will result in a single MPI_Send call\&. For variable\-length data, e\&.g\&., serialized types and packed archives, two messages will be sent via MPI_Send: one containing the length of the data and the second containing the data itself\&. Note that the transmission mode for variable\-length data is an implementation detail that is subject to change\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The rank of the remote process to which the data will be sent\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.PP
value
.RS 4
The value that will be transmitted to the receiver\&. The type
T
of this value must meet the aforementioned criteria for transmission\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename T> 
  void send(int dest, int tag, const skeleton_proxy< T > & proxy) const;
.fi

.sp
Send the skeleton of an object\&. This routine executes a potentially blocking send with tag
tag
to the process with rank
dest\&. It can be received by the destination process with a matching
recv
call\&. This variation on
send
will be used when a send of a skeleton is explicitly requested via code such as:
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
comm\&.send(dest, tag, skeleton(object));

.fi
.if n \{\
.RE
.\}

.sp
The semantics of this routine are equivalent to that of sending a
packed_skeleton_oarchive
storing the skeleton of the
object\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The rank of the remote process to which the skeleton will be sent\&.
.RE
.PP
proxy
.RS 4
The
skeleton_proxy
containing a reference to the object whose skeleton will be transmitted\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename T> 
  void send(int dest, int tag, const T * values, int n) const;
.fi

.sp
Send an array of values to another process\&. This routine executes a potentially blocking send of an array of data with tag
tag
to the process with rank
dest\&. It can be received by the destination process with a matching array
recv
call\&.
.sp
If
T
is an MPI datatype, an invocation of this routine will be mapped to a single call to MPI_Send, using the datatype
get_mpi_datatype<T>()\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The process rank of the remote process to which the data will be sent\&.
.RE
.PP
n
.RS 4
The number of values stored in the array\&. The destination process must call receive with at least this many elements to correctly receive the message\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.PP
values
.RS 4
The array of values that will be transmitted to the receiver\&. The type
T
of these values must be mapped to an MPI data type\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
void send(int dest, int tag) const;
.fi

.sp
Send a message to another process without any data\&. This routine executes a potentially blocking send of a message to another process\&. The message contains no extra data, and can therefore only be received by a matching call to
recv()\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The process rank of the remote process to which the message will be sent\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename T> status recv(int source, int tag, T & value) const;
.fi

.sp
Receive data from a remote process\&. This routine blocks until it receives a message from the process
source
with the given
tag\&. The type
T
of the
value
must be suitable for transmission over MPI, which includes serializable types, types that can be mapped to MPI data types (including most built\-in C++ types), packed MPI archives, skeletons, and content associated with skeletons; see the documentation of
send
for a complete description\&.
.sp

.PP
Parameters:
.RS 4
.PP
source
.RS 4
The process that will be sending data\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.PP
value
.RS 4
Will contain the value of the message after a successful receive\&. The type of this value must match the value transmitted by the sender, unless the sender transmitted a packed archive or skeleton: in these cases, the sender transmits a
packed_oarchive
or
packed_skeleton_oarchive
and the destination receives a
packed_iarchive
or
packed_skeleton_iarchive, respectively\&.
.RE
.RE
.PP
Returns:
.RS 4
Information about the received message\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename T> 
  status recv(int source, int tag, const skeleton_proxy< T > & proxy) const;
.fi

.sp
Receive a skeleton from a remote process\&. This routine blocks until it receives a message from the process
source
with the given
tag
containing a skeleton\&.
.sp

.PP
Parameters:
.RS 4
.PP
proxy
.RS 4
The
skeleton_proxy
containing a reference to the object that will be reshaped to match the received skeleton\&.
.RE
.PP
source
.RS 4
The process that will be sending data\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.RE
.PP
Returns:
.RS 4
Information about the received message\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename T> 
  status recv(int source, int tag, skeleton_proxy< T > & proxy) const;
.fi

.sp
Receive a skeleton from a remote process\&. This routine blocks until it receives a message from the process
source
with the given
tag
containing a skeleton\&.
.sp

.PP
Parameters:
.RS 4
.PP
proxy
.RS 4
The
skeleton_proxy
containing a reference to the object that will be reshaped to match the received skeleton\&.
.RE
.PP
source
.RS 4
The process that will be sending data\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.RE
.PP
Returns:
.RS 4
Information about the received message\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
template<typename T> status recv(int source, int tag, T * values, int n) const;
.fi

.sp
Receive an array of values from a remote process\&. This routine blocks until it receives an array of values from the process
source
with the given
tag\&. If the type
T
is
.sp

.PP
Parameters:
.RS 4
.PP
n
.RS 4
The number of values that can be stored into the
values
array\&. This shall not be smaller than the number of elements transmitted by the sender\&.
.RE
.PP
source
.RS 4
The process that will be sending data\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.PP
values
.RS 4
Will contain the values in the message after a successful receive\&. The type of these elements must match the type of the elements transmitted by the sender\&.
.RE
.RE
.PP
Returns:
.RS 4
Information about the received message\&.
.RE
.PP
Throws:
.RS 4
std::range_error if the message to be received contains more than
n
values\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
status recv(int source, int tag) const;
.fi

.sp
Receive a message from a remote process without any data\&. This routine blocks until it receives a message from the process
source
with the given
tag\&.
.sp

.PP
Parameters:
.RS 4
.PP
source
.RS 4
The process that will be sending the message\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.RE
.PP
Returns:
.RS 4
Information about the received message\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
template<typename T> 
  status sendrecv(int dest, int stag, const T & sval, int src, int rtag, 
                  T & rval) const;
.fi

Send a message to remote process nd receive another message from another process\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
template<typename T> request isend(int dest, int tag, const T & value) const;
.fi

.sp
Send a message to a remote process without blocking\&. The
isend
method is functionality identical to the
send
method and transmits data in the same way, except that
isend
will not block while waiting for the data to be transmitted\&. Instead, a request object will be immediately returned, allowing one to query the status of the communication or wait until it has completed\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The rank of the remote process to which the data will be sent\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.PP
value
.RS 4
The value that will be transmitted to the receiver\&. The type
T
of this value must meet the aforementioned criteria for transmission\&.
.RE
.RE
.PP
Returns:
.RS 4
a
request
object that describes this communication\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
template<typename T> 
  request isend(int dest, int tag, const skeleton_proxy< T > & proxy) const;
.fi

.sp
Send the skeleton of an object without blocking\&. This routine is functionally identical to the
send
method for
skeleton_proxy
objects except that
isend
will not block while waiting for the data to be transmitted\&. Instead, a request object will be immediately returned, allowing one to query the status of the communication or wait until it has completed\&.
.sp
The semantics of this routine are equivalent to a non\-blocking send of a
packed_skeleton_oarchive
storing the skeleton of the
object\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The rank of the remote process to which the skeleton will be sent\&.
.RE
.PP
proxy
.RS 4
The
skeleton_proxy
containing a reference to the object whose skeleton will be transmitted\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.RE
.PP
Returns:
.RS 4
a
request
object that describes this communication\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
template<typename T> 
  request isend(int dest, int tag, const T * values, int n) const;
.fi

.sp
Send an array of values to another process without blocking\&. This routine is functionally identical to the
send
method for arrays except that
isend
will not block while waiting for the data to be transmitted\&. Instead, a request object will be immediately returned, allowing one to query the status of the communication or wait until it has completed\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The process rank of the remote process to which the data will be sent\&.
.RE
.PP
n
.RS 4
The number of values stored in the array\&. The destination process must call receive with at least this many elements to correctly receive the message\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.PP
values
.RS 4
The array of values that will be transmitted to the receiver\&. The type
T
of these values must be mapped to an MPI data type\&.
.RE
.RE
.PP
Returns:
.RS 4
a
request
object that describes this communication\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
request isend(int dest, int tag) const;
.fi

.sp
Send a message to another process without any data without blocking\&. This routine is functionally identical to the
send
method for sends with no data, except that
isend
will not block while waiting for the message to be transmitted\&. Instead, a request object will be immediately returned, allowing one to query the status of the communication or wait until it has completed\&.
.sp

.PP
Parameters:
.RS 4
.PP
dest
.RS 4
The process rank of the remote process to which the message will be sent\&.
.RE
.PP
tag
.RS 4
The tag that will be associated with this message\&. Tags may be any integer between zero and an implementation\-defined upper limit\&. This limit is accessible via
environment::max_tag()\&.
.RE
.RE
.PP
Returns:
.RS 4
a
request
object that describes this communication\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
template<typename T> request irecv(int source, int tag, T & value) const;
.fi

.sp
Prepare to receive a message from a remote process\&. The
irecv
method is functionally identical to the
recv
method and receive data in the same way, except that
irecv
will not block while waiting for data to be transmitted\&. Instead, it immediately returns a request object that allows one to query the status of the receive or wait until it has completed\&.
.sp

.PP
Parameters:
.RS 4
.PP
source
.RS 4
The process that will be sending data\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.PP
value
.RS 4
Will contain the value of the message after a successful receive\&. The type of this value must match the value transmitted by the sender, unless the sender transmitted a packed archive or skeleton: in these cases, the sender transmits a
packed_oarchive
or
packed_skeleton_oarchive
and the destination receives a
packed_iarchive
or
packed_skeleton_iarchive, respectively\&.
.RE
.RE
.PP
Returns:
.RS 4
a
request
object that describes this communication\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
template<typename T> 
  request irecv(int source, int tag, T * values, int n) const;
.fi

.sp
Initiate receipt of an array of values from a remote process\&. This routine initiates a receive operation for an array of values transmitted by process
source
with the given
tag\&.
.sp

.PP
Parameters:
.RS 4
.PP
n
.RS 4
The number of values that can be stored into the
values
array\&. This shall not be smaller than the number of elements transmitted by the sender\&.
.RE
.PP
source
.RS 4
The process that will be sending data\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.PP
values
.RS 4
Will contain the values in the message after a successful receive\&. The type of these elements must match the type of the elements transmitted by the sender\&.
.RE
.RE
.PP
Returns:
.RS 4
a
request
object that describes this communication\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
request irecv(int source, int tag) const;
.fi

.sp
Initiate receipt of a message from a remote process that carries no data\&. This routine initiates a receive operation for a message from process
source
with the given
tag
that carries no data\&.
.sp

.PP
Parameters:
.RS 4
.PP
source
.RS 4
The process that will be sending the message\&. This will either be a process rank within the communicator or the constant
any_source, indicating that we can receive the message from any process\&.
.RE
.PP
tag
.RS 4
The tag that matches a particular kind of message sent by the source process\&. This may be any tag value permitted by
send\&. Alternatively, the argument may be the constant
any_tag, indicating that this receive matches a message with any tag\&.
.RE
.RE
.PP
Returns:
.RS 4
a
request
object that describes this communication\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
status probe(int source = any_source, int tag = any_tag) const;
.fi

.sp
Waits until a message is available to be received\&. This operation waits until a message matching (source,
tag) is available to be received\&. It then returns information about that message\&. The functionality is equivalent to
MPI_Probe\&. To check if a message is available without blocking, use
iprobe\&.
.sp

.PP
Parameters:
.RS 4
.PP
source
.RS 4
Determine if there is a message available from this rank\&. If
any_source, then the message returned may come from any source\&.
.RE
.PP
tag
.RS 4
Determine if there is a message available with the given tag\&. If
any_tag, then the message returned may have any tag\&.
.RE
.RE
.PP
Returns:
.RS 4
Returns information about the first message that matches the given criteria\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
optional< status > iprobe(int source = any_source, int tag = any_tag) const;
.fi

.sp
Determine if a message is available to be received\&. This operation determines if a message matching (source,
tag) is available to be received\&. If so, it returns information about that message; otherwise, it returns immediately with an empty optional\&. The functionality is equivalent to
MPI_Iprobe\&. To wait until a message is available, use
wait\&.
.sp

.PP
Parameters:
.RS 4
.PP
source
.RS 4
Determine if there is a message available from this rank\&. If
any_source, then the message returned may come from any source\&.
.RE
.PP
tag
.RS 4
Determine if there is a message available with the given tag\&. If
any_tag, then the message returned may have any tag\&.
.RE
.RE
.PP
Returns:
.RS 4
If a matching message is available, returns information about that message\&. Otherwise, returns an empty
boost::optional\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
void barrier() const;
.fi

.sp
Wait for all processes within a communicator to reach the barrier\&. This routine is a collective operation that blocks each process until all processes have entered it, then releases all of the processes "simultaneously"\&. It is equivalent to
MPI_Barrier\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
operator bool() const;
.fi

.sp
Determine if this communicator is valid for communication\&. Evaluates
true
in a boolean context if this communicator is valid for communication, i\&.e\&., does not represent MPI_COMM_NULL\&. Otherwise, evaluates
false\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
operator MPI_Comm() const;
.fi

.sp
Access the MPI communicator associated with a Boost\&.MPI communicator\&. This routine permits the implicit conversion from a Boost\&.MPI communicator to an MPI communicator\&.
.sp

.PP
Returns:
.RS 4
The associated MPI communicator\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
communicator split(int color) const;
.fi

.sp
Split the communicator into multiple, disjoint communicators each of which is based on a particular color\&. This is a collective operation that returns a new communicator that is a subgroup of
this\&. This routine is functionally equivalent to
MPI_Comm_split\&.
.sp

.PP
Parameters:
.RS 4
.PP
color
.RS 4
The color of this process\&. All processes with the same
color
value will be placed into the same group\&.
.RE
.RE
.PP
Returns:
.RS 4
A new communicator containing all of the processes in
this
that have the same
color\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}

.sp

.nf
communicator split(int color, int key) const;
.fi

.sp
Split the communicator into multiple, disjoint communicators each of which is based on a particular color\&. This is a collective operation that returns a new communicator that is a subgroup of
this\&. This routine is functionally equivalent to
MPI_Comm_split\&.
.sp

.PP
Parameters:
.RS 4
.PP
color
.RS 4
The color of this process\&. All processes with the same
color
value will be placed into the same group\&.
.RE
.PP
key
.RS 4
A key value that will be used to determine the ordering of processes with the same color in the resulting communicator\&. If omitted, the rank of the processes in
this
will determine the ordering of processes in the resulting group\&.
.RE
.RE
.PP
Returns:
.RS 4
A new communicator containing all of the processes in
this
that have the same
color\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}

.sp

.nf
optional< intercommunicator > as_intercommunicator() const;
.fi

.sp
Determine if the communicator is in fact an intercommunicator and, if so, return that intercommunicator\&.
.sp

.PP
Returns:
.RS 4
an
optional
containing the intercommunicator, if this communicator is in fact an intercommunicator\&. Otherwise, returns an empty
optional\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}

.sp

.nf
optional< graph_communicator > as_graph_communicator() const;
.fi

.sp
Determine if the communicator has a graph topology and, if so, return that
graph_communicator\&. Even though the communicators have different types, they refer to the same underlying communication space and can be used interchangeably for communication\&.
.sp

.PP
Returns:
.RS 4
an
optional
containing the graph communicator, if this communicator does in fact have a graph topology\&. Otherwise, returns an empty
optional\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}

.sp

.nf
bool has_cartesian_topology() const;
.fi

.sp
Determines whether this communicator has a Cartesian topology\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}

.sp

.nf
void abort(int errcode) const;
.fi

.sp
Abort all tasks in the group of this communicator\&.
.sp
Makes a "best attempt" to abort all of the tasks in the group of this communicator\&. Depending on the underlying MPI implementation, this may either abort the entire program (and possibly return
errcode
to the environment) or only abort some processes, allowing the others to continue\&. Consult the documentation for your MPI implementation\&. This is equivalent to a call to
MPI_Abort
.sp

.PP
Parameters:
.RS 4
.PP
errcode
.RS 4
The error code to return from aborted processes\&.
.RE
.RE
.PP
Returns:
.RS 4
Will not return\&.
.RE
.RE


