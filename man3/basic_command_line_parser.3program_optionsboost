.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TE" 3 "" "" ""
.SH "NAME"
boost::program_options::basic_command_line_parser
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/program_options/parsers\&.hpp>

template<typename charT> 
class basic_command_line_parser : private cmdline {
public:
  // construct/copy/destruct
  basic_command_line_parser(const std::vector< std::basic_string< charT > > &);
  basic_command_line_parser(int, const charT *const);

  // public member functions
  basic_command_line_parser & options(const options_description &);
  basic_command_line_parser & 
  positional(const positional_options_description &);
  basic_command_line_parser & style(int);
  basic_command_line_parser & extra_parser(ext_parser);
  basic_parsed_options< charT > run();
  basic_command_line_parser & allow_unregistered();
  basic_command_line_parser & extra_style_parser(style_parser);
};
.fi
.SH "DESCRIPTION"
.PP
Command line parser\&.
.PP
The class allows one to specify all the information needed for parsing and to parse the command line\&. It is primarily needed to emulate named function parameters \-\- a regular function with 5 parameters will be hard to use and creating overloads with a smaller number of parameters will be confusing\&.
.PP
For the most common case, the function parse_command_line is a better alternative\&.
.PP
There are two typedefs \-\- command_line_parser and wcommand_line_parser, for charT == char and charT == wchar_t cases\&.
.SS "basic_command_line_parser public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
basic_command_line_parser(const std::vector< std::basic_string< charT > > & args);
.fi

.sp
Creates a command line parser for the specified arguments list\&. The \'args\' parameter should not include program name\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
basic_command_line_parser(int argc, const charT *const argv);
.fi

.sp
Creates a command line parser for the specified arguments list\&. The parameters should be the same as passed to \'main\'\&.
.RE

.SS "basic_command_line_parser public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
basic_command_line_parser & options(const options_description & desc);
.fi

.sp
Sets options descriptions to use\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
basic_command_line_parser & 
positional(const positional_options_description & desc);
.fi

.sp
Sets positional options description to use\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
basic_command_line_parser & style(int);
.fi

.sp
Sets the command line style\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
basic_command_line_parser & extra_parser(ext_parser);
.fi

.sp
Sets the extra parsers\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
basic_parsed_options< charT > run();
.fi

.sp
Parses the options and returns the result of parsing\&. Throws on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
basic_command_line_parser & allow_unregistered();
.fi

.sp
Specifies that unregistered options are allowed and should be passed though\&. For each command like token that looks like an option but does not contain a recognized name, an instance of basic_option<charT> will be added to result, with \'unrecognized\' field set to \'true\'\&. It\'s possible to collect all unrecognized options with the \'collect_unrecognized\' funciton\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
basic_command_line_parser & extra_style_parser(style_parser s);
.fi

.RE


