.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE QUE" 3 "" "" ""
.SH "NAME"
boost::lockfree::queue
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/lockfree/queue\&.hpp>

template<typename T, typename A0 = boost::parameter::void_, 
         typename A1 = boost::parameter::void_, 
         typename A2 = boost::parameter::void_> 
class queue {
public:
  // member classes/structs/unions
  template<typename T, \&.\&.\&. Options> 
  struct implementation_defined {
    // types
    typedef node_allocator allocator;
    typedef std::size_t    size_type;
  };
  template<typename T, \&.\&.\&. Options> 
  struct node {
    // types
    typedef \fIunspecified\fR tagged_node_handle;
    typedef \fIunspecified\fR handle_type;       

    // construct/copy/destruct
    node(T const &, handle_type);
    node(handle_type);
    node(void);

    // public data members
    atomic< tagged_node_handle > next;
    T data;
  };
  // construct/copy/destruct
  queue(void);
  template<typename U> 
    explicit queue(typename node_allocator::template rebind< U >::other const &);
  explicit queue(allocator const &);
  explicit queue(size_type);
  template<typename U> 
    queue(size_type, 
          typename node_allocator::template rebind< U >::other const &);
  ~queue(void);

  // private member functions
   BOOST_STATIC_ASSERT((boost::has_trivial_destructor< T >::value));
   BOOST_STATIC_ASSERT((boost::has_trivial_assign< T >::value));
  void initialize(void);
   BOOST_DELETED_FUNCTION(queue(queue const &));
  bool is_lock_free(void) const;
  void reserve(size_type);
  void reserve_unsafe(size_type);
  bool empty(void) const;
  bool push(T const &);
  bool bounded_push(T const &);
  template<bool Bounded> bool do_push(T const &);

  // public member functions
  bool unsynchronized_push(T const &);
  bool pop(T &);
  template<typename U> bool pop(U &);
  bool unsynchronized_pop(T &);
  template<typename U> bool unsynchronized_pop(U &);
  template<typename Functor> bool consume_one(Functor &);
  template<typename Functor> bool consume_one(Functor const &);
  template<typename Functor> size_t consume_all(Functor &);
  template<typename Functor> size_t consume_all(Functor const &);
};
.fi
.SH "DESCRIPTION"
.PP
The queue class provides a multi\-writer/multi\-reader queue, pushing and popping is lock\-free, construction/destruction has to be synchronized\&. It uses a freelist for memory management, freed nodes are pushed to the freelist and not returned to the OS before the queue is destroyed\&.
.PP
\fBPolicies:\fR

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::fixed_sized, defaults to
boost::lockfree::fixed_sized<false>
&#9618;.br&#9618;
Can be used to completely disable dynamic memory allocations during push in order to ensure lockfree behavior\&.
&#9618;.br&#9618;
If the data structure is configured as fixed\-sized, the internal nodes are stored inside an array and they are addressed by array indexing\&. This limits the possible size of the queue to the number of elements that can be addressed by the index type (usually 2**16\-2), but on platforms that lack double\-width compare\-and\-exchange instructions, this is the best way to achieve lock\-freedom\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::capacity, optional
&#9618;.br&#9618;
If this template argument is passed to the options, the size of the queue is set at compile\-time\&.&#9618;.br&#9618;
It this option implies
fixed_sized<true>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::allocator, defaults to
boost::lockfree::allocator<std::allocator<void>>
&#9618;.br&#9618;
Specifies the allocator that is used for the internal freelist
.RE
.sp
.RE

.PP
\fBRequirements:\fR

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must have a copy constructor
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must have a trivial assignment operator
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must have a trivial destructor
.RE
.sp
.RE

.SS "queue public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
queue(void);
.fi

Construct queue\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename U> 
  explicit queue(typename node_allocator::template rebind< U >::other const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit queue(allocator const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
explicit queue(size_type n);
.fi

Construct queue, allocate n nodes for the freelist\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename U> 
  queue(size_type n, 
        typename node_allocator::template rebind< U >::other const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
~queue(void);
.fi

.sp
Destroys queue, free all nodes from freelist\&.
.RE

.SS "queue private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
 BOOST_STATIC_ASSERT((boost::has_trivial_destructor< T >::value));
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
 BOOST_STATIC_ASSERT((boost::has_trivial_assign< T >::value));
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void initialize(void);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
 BOOST_DELETED_FUNCTION(queue(queue const &));
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool is_lock_free(void) const;
.fi

.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
It only checks, if the queue head and tail nodes and the freelist can be modified in a lock\-free manner\&. On most platforms, the whole implementation is lock\-free, if this is true\&. Using c++0x\-style atomics, there is no possibility to provide a completely accurate implementation, because one would need to test every internal node, which is impossible if further nodes will be allocated from the operating system\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if implementation is lock\-free\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void reserve(size_type n);
.fi

.sp
Allocate n nodes for freelist
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
thread\-safe, may block if memory allocator blocks
.sp .5v
.RE

.PP
Requires:
.RS 4
only valid if no capacity<> argument given
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
void reserve_unsafe(size_type n);
.fi

.sp
Allocate n nodes for freelist
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
not thread\-safe, may block if memory allocator blocks
.sp .5v
.RE

.PP
Requires:
.RS 4
only valid if no capacity<> argument given
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
bool empty(void) const;
.fi

.sp
Check if the queue is empty
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The result is only accurate, if no other thread modifies the queue\&. Therefore it is rarely practical to use this value in program logic\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if the queue is empty, false otherwise
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
bool push(T const & t);
.fi

.sp
Pushes object t to the queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe\&. If internal memory pool is exhausted and the memory pool is not fixed\-sized, a new node will be allocated from the OS\&. This may not be lock\-free\&.
.sp .5v
.RE

.PP
Postconditions:
.RS 4
object will be pushed to the queue, if internal node can be allocated
.RE
.PP
Returns:
.RS 4
true, if the push operation is successful\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool bounded_push(T const & t);
.fi

.sp
Pushes object t to the queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking\&. If internal memory pool is exhausted, operation will fail
.sp .5v
.RE

.PP
Postconditions:
.RS 4
object will be pushed to the queue, if internal node can be allocated
.RE
.PP
Returns:
.RS 4
true, if the push operation is successful\&.
.RE
.PP
Throws:
.RS 4
if memory allocator throws
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
template<bool Bounded> bool do_push(T const & t);
.fi

.RE

.SS "queue public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool unsynchronized_push(T const & t);
.fi

.sp
Pushes object t to the queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not Thread\-safe\&. If internal memory pool is exhausted and the memory pool is not fixed\-sized, a new node will be allocated from the OS\&. This may not be lock\-free\&.
.sp .5v
.RE

.PP
Postconditions:
.RS 4
object will be pushed to the queue, if internal node can be allocated
.RE
.PP
Returns:
.RS 4
true, if the push operation is successful\&.
.RE
.PP
Throws:
.RS 4
if memory allocator throws
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool pop(T & ret);
.fi

.sp
Pops object from queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if queue was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename U> bool pop(U & ret);
.fi

.sp
Pops object from queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Requires:
.RS 4
type U must be constructible by T and copyable, or T must be convertible to U
.RE
.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if queue was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
bool unsynchronized_pop(T & ret);
.fi

.sp
Pops object from queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not thread\-safe, but non\-blocking
.sp .5v
.RE

.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if queue was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename U> bool unsynchronized_pop(U & ret);
.fi

.sp
Pops object from queue\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not thread\-safe, but non\-blocking
.sp .5v
.RE

.PP
Requires:
.RS 4
type U must be constructible by T and copyable, or T must be convertible to U
.RE
.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if queue was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename Functor> bool consume_one(Functor & f);
.fi

.sp
consumes one element via a functor
.sp
pops one element from the queue and applies the functor on this object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if one element was consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename Functor> bool consume_one(Functor const & f);
.fi

.sp
consumes one element via a functor
.sp
pops one element from the queue and applies the functor on this object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if one element was consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename Functor> size_t consume_all(Functor & f);
.fi

.sp
consumes all elements via a functor
.sp
sequentially pops all elements from the queue and applies the functor on each object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
number of elements that are consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename Functor> size_t consume_all(Functor const & f);
.fi

.sp
consumes all elements via a functor
.sp
sequentially pops all elements from the queue and applies the functor on each object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
number of elements that are consumed
.RE
.RE


