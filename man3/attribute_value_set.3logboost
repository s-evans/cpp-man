.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS ATTRIBUTE_" 3 "" "" ""
.SH "NAME"
boost::log::attribute_value_set \- A set of attribute values\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/attributes/attribute_value_set\&.hpp>


class attribute_value_set {
public:
  // types
  typedef attribute_name                           key_type;         // Key type\&. 
  typedef attribute_value                          mapped_type;      // Mapped attribute type\&. 
  typedef std::pair< const key_type, mapped_type > value_type;       // Value type\&. 
  typedef value_type &                             reference;        // Reference type\&. 
  typedef value_type const &                       const_reference;  // Const reference type\&. 
  typedef value_type *                             pointer;          // Pointer type\&. 
  typedef value_type const *                       const_pointer;    // Const pointer type\&. 
  typedef std::size_t                              size_type;        // Size type\&. 
  typedef std::ptrdiff_t                           difference_type;  // Pointer difference type\&. 
  typedef implementation_defined                   const_iterator; 

  // construct/copy/destruct
  explicit attribute_value_set(size_type = 8);
  attribute_value_set(attribute_value_set &&) noexcept;
  attribute_value_set(attribute_set const &, attribute_set const &, 
                      attribute_set const &, size_type = 8);
  attribute_value_set(attribute_value_set const &, attribute_set const &, 
                      attribute_set const &, size_type = 8);
  attribute_value_set(attribute_value_set &&, attribute_set const &, 
                      attribute_set const &, size_type = 8);
  attribute_value_set(attribute_value_set const &);
  attribute_value_set & operator=(attribute_value_set) noexcept;
  ~attribute_value_set();

  // public member functions
  void swap(attribute_value_set &) noexcept;
  const_iterator begin() const;
  const_iterator end() const;
  size_type size() const;
  bool empty() const;
  const_iterator find(key_type) const;
  mapped_type operator[](key_type) const;
  template<typename DescriptorT, template< typename > class ActorT> 
    result_of::extract< typename expressions::attribute_keyword< DescriptorT, ActorT >::value_type, DescriptorT >::type 
    operator[](expressions::attribute_keyword< DescriptorT, ActorT > const &) const;
  size_type count(key_type) const;
  void freeze();
  std::pair< const_iterator, bool > insert(key_type, mapped_type const &);
  std::pair< const_iterator, bool > insert(const_reference);
  template<typename FwdIteratorT> void insert(FwdIteratorT, FwdIteratorT);
  template<typename FwdIteratorT, typename OutputIteratorT> 
    void insert(FwdIteratorT, FwdIteratorT, OutputIteratorT);
};
.fi
.SH "DESCRIPTION"
.PP
The set of attribute values is an associative container with attribute name as a key and a pointer to attribute value object as a mapped type\&. This is a collection of elements with unique keys, that is, there can be only one attribute value with a given name in the set\&. With respect to read\-only capabilities, the set interface is close to
std::unordered_map\&.
.PP
The set is designed to be only capable of adding elements to it\&. Once added, the attribute value cannot be removed from the set\&.
.PP
An instance of attribute value set can be constructed from three attribute sets\&. The constructor attempts to accommodate values of all attributes from the sets\&. The situation when a same\-named attribute is found in more than one attribute set is possible\&. This problem is solved on construction of the value set: the three attribute sets have different priorities when it comes to solving conflicts\&.
.PP
From the library perspective the three source attribute sets are global, thread\-specific and source\-specific attributes, with the latter having the highest priority\&. This feature allows to override attributes of wider scopes with the more specific ones\&.
.PP
For sake of performance, the attribute values are not immediately acquired from attribute sets at construction\&. Instead, on\-demand acquisition is performed either on iterator dereferencing or on call to the
freeze
method\&. Once acquired, the attribute value stays within the set until its destruction\&. This nuance does not affect other set properties, such as size or lookup ability\&. The logging core automatically freezes the set at the right point, so users should not be bothered unless they manually create attribute value sets\&.
.PP
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
The attribute sets that were used for the value set construction must not be modified or destroyed until the value set is frozen\&. Otherwise the behavior is undefined\&.
.sp .5v
.RE

.SS "attribute_value_set public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

typedef
implementation_defined
const_iterator;
.sp
Constant iterator type with bidirectional capabilities\&.
.RE

.SS "attribute_value_set public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit attribute_value_set(size_type reserve_count = 8);
.fi

.sp
Default constructor
.sp
The constructor creates an empty set which can be filled later by subsequent calls of
insert
method\&. Optionally, the amount of storage reserved for elements to be inserted may be passed to the constructor\&. The constructed set is frozen\&.
.sp

.PP
Parameters:
.RS 4
.PP
reserve_count
.RS 4
Number of elements to reserve space for\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
attribute_value_set(attribute_value_set && that) noexcept;
.fi

.sp
Move constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
attribute_value_set(attribute_set const & source_attrs, 
                    attribute_set const & thread_attrs, 
                    attribute_set const & global_attrs, 
                    size_type reserve_count = 8);
.fi

.sp
The constructor adopts three attribute sets into the value set\&. The
\fIsource_attrs\fR
attributes have the greatest preference when a same\-named attribute is found in several sets,
\fIglobal_attrs\fR
has the least\&. The constructed set is not frozen\&.
.sp

.PP
Parameters:
.RS 4
.PP
global_attrs
.RS 4
A set of global attributes\&.
.RE
.PP
reserve_count
.RS 4
Amount of elements to reserve space for, in addition to the elements in the three attribute sets provided\&.
.RE
.PP
source_attrs
.RS 4
A set of source\-specific attributes\&.
.RE
.PP
thread_attrs
.RS 4
A set of thread\-specific attributes\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
attribute_value_set(attribute_value_set const & source_attrs, 
                    attribute_set const & thread_attrs, 
                    attribute_set const & global_attrs, 
                    size_type reserve_count = 8);
.fi

.sp
The constructor adopts three attribute sets into the value set\&. The
\fIsource_attrs\fR
attributes have the greatest preference when a same\-named attribute is found in several sets,
\fIglobal_attrs\fR
has the least\&. The constructed set is not frozen\&.
.sp

.PP
Parameters:
.RS 4
.PP
global_attrs
.RS 4
A set of global attributes\&.
.RE
.PP
reserve_count
.RS 4
Amount of elements to reserve space for, in addition to the elements in the three attribute sets provided\&.
.RE
.PP
source_attrs
.RS 4
A set of source\-specific attributes\&.
.RE
.PP
thread_attrs
.RS 4
A set of thread\-specific attributes\&.
.RE
.RE
.PP
Requires:
.RS 4
The
\fIsource_attrs\fR
set is frozen\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
attribute_value_set(attribute_value_set && source_attrs, 
                    attribute_set const & thread_attrs, 
                    attribute_set const & global_attrs, 
                    size_type reserve_count = 8);
.fi

.sp
The constructor adopts three attribute sets into the value set\&. The
\fIsource_attrs\fR
attributes have the greatest preference when a same\-named attribute is found in several sets,
\fIglobal_attrs\fR
has the least\&. The constructed set is not frozen\&.
.sp

.PP
Parameters:
.RS 4
.PP
global_attrs
.RS 4
A set of global attributes\&.
.RE
.PP
reserve_count
.RS 4
Amount of elements to reserve space for, in addition to the elements in the three attribute sets provided\&.
.RE
.PP
source_attrs
.RS 4
A set of source\-specific attributes\&.
.RE
.PP
thread_attrs
.RS 4
A set of thread\-specific attributes\&.
.RE
.RE
.PP
Requires:
.RS 4
The
\fIsource_attrs\fR
set is frozen\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
attribute_value_set(attribute_value_set const & that);
.fi

.sp
Copy constructor\&.
.sp

.PP
Requires:
.RS 4
The original set is frozen\&.
.RE
.PP
Postconditions:
.RS 4
The constructed set is frozen,
std::equal(begin(), end(), that\&.begin()) == true
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
attribute_value_set & operator=(attribute_value_set that) noexcept;
.fi

.sp
Assignment operator
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
~attribute_value_set();
.fi

.sp
Destructor\&. Releases all referenced attribute values\&.
.RE

.SS "attribute_value_set public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void swap(attribute_value_set & that) noexcept;
.fi

.sp
Swaps two sets
.sp
\fBThrows:\fR
Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
const_iterator begin() const;
.fi

.sp

.PP
Returns:
.RS 4
Iterator to the first element of the set\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
const_iterator end() const;
.fi

.sp

.PP
Returns:
.RS 4
Iterator to the after\-the\-last element of the set\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
size_type size() const;
.fi

.sp

.PP
Returns:
.RS 4
Number of elements in the set\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp

.PP
Returns:
.RS 4
true
if there are no elements in the container,
false
otherwise\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const_iterator find(key_type key) const;
.fi

.sp
The method finds the attribute value by name\&.
.sp

.PP
Parameters:
.RS 4
.PP
key
.RS 4
Attribute name\&.
.RE
.RE
.PP
Returns:
.RS 4
Iterator to the found element or
end()
if the attribute with such name is not found\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
mapped_type operator[](key_type key) const;
.fi

.sp
Alternative lookup syntax\&.
.sp

.PP
Parameters:
.RS 4
.PP
key
.RS 4
Attribute name\&.
.RE
.RE
.PP
Returns:
.RS 4
A pointer to the attribute value if it is found with
\fIkey\fR, default\-constructed mapped value otherwise\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename DescriptorT, template< typename > class ActorT> 
  result_of::extract< typename expressions::attribute_keyword< DescriptorT, ActorT >::value_type, DescriptorT >::type 
  operator[](expressions::attribute_keyword< DescriptorT, ActorT > const & keyword) const;
.fi

.sp
Alternative lookup syntax\&.
.sp

.PP
Parameters:
.RS 4
.PP
keyword
.RS 4
Attribute keyword\&.
.RE
.RE
.PP
Returns:
.RS 4
A
value_ref
with extracted attribute value if it is found, empty
value_ref
otherwise\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
size_type count(key_type key) const;
.fi

.sp
The method counts the number of the attribute value occurrences in the set\&. Since there can be only one attribute value with a particular key, the method always return 0 or 1\&.
.sp

.PP
Parameters:
.RS 4
.PP
key
.RS 4
Attribute name\&.
.RE
.RE
.PP
Returns:
.RS 4
The number of times the attribute value is found in the container\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
void freeze();
.fi

.sp
The method acquires values of all adopted attributes\&.
.sp

.PP
Postconditions:
.RS 4
The set is frozen\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
std::pair< const_iterator, bool > 
insert(key_type key, mapped_type const & mapped);
.fi

.sp
Inserts an element into the set\&. The complexity of the operation is amortized constant\&.
.sp

.PP
Parameters:
.RS 4
.PP
key
.RS 4
The attribute name\&.
.RE
.PP
mapped
.RS 4
The attribute value\&.
.RE
.RE
.PP
Requires:
.RS 4
The set is frozen\&.
.RE
.PP
Returns:
.RS 4
An iterator to the inserted element and
true
if insertion succeeded\&. Otherwise, if the set already contains a same\-named attribute value, iterator to the existing element and
false\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
std::pair< const_iterator, bool > insert(const_reference value);
.fi

.sp
Inserts an element into the set\&. The complexity of the operation is amortized constant\&.
.sp

.PP
Parameters:
.RS 4
.PP
value
.RS 4
The attribute name and value\&.
.RE
.RE
.PP
Requires:
.RS 4
The set is frozen\&.
.RE
.PP
Returns:
.RS 4
An iterator to the inserted element and
true
if insertion succeeded\&. Otherwise, if the set already contains a same\-named attribute value, iterator to the existing element and
false\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
template<typename FwdIteratorT> 
  void insert(FwdIteratorT begin, FwdIteratorT end);
.fi

.sp
Mass insertion method\&. The complexity of the operation is linear to the number of elements inserted\&.
.sp

.PP
Parameters:
.RS 4
.PP
begin
.RS 4
A forward iterator that points to the first element to be inserted\&.
.RE
.PP
end
.RS 4
A forward iterator that points to the after\-the\-last element to be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
The set is frozen\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
template<typename FwdIteratorT, typename OutputIteratorT> 
  void insert(FwdIteratorT begin, FwdIteratorT end, OutputIteratorT out);
.fi

.sp
Mass insertion method with ability to acquire iterators to the inserted elements\&. The complexity of the operation is linear to the number of elements inserted times the complexity of filling the
\fIout\fR
iterator\&.
.sp

.PP
Parameters:
.RS 4
.PP
begin
.RS 4
A forward iterator that points to the first element to be inserted\&.
.RE
.PP
end
.RS 4
A forward iterator that points to the after\-the\-last element to be inserted\&.
.RE
.PP
out
.RS 4
An output iterator that receives results of insertion of the elements\&.
.RE
.RE
.PP
Requires:
.RS 4
The set is frozen\&.
.RE
.RE


