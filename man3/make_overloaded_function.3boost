.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTIO" 3 "" "" ""
.SH "NAME"
boost::make_overloaded_function \- Make an overloaded function object without explicitly specifying the function types\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/functional/overloaded_function\&.hpp>


template<typename F1, typename F2, \&.\&.\&. > 
  overloaded_function< __function_type__< F1 >, __function_type__< F2 >,\&.\&.\&.> 
  make_overloaded_function(F1 f1, F2 f2, \&.\&.\&.);
.fi
.SH "DESCRIPTION"
.PP
This function template creates and returns an
overloaded_function
object that overloads all the specified functions
f1,
f2, etc\&.
.PP
The function types are internally determined from the template parameter types so they do not need to be explicitly specified\&. Therefore, this function template usually has a more concise syntax when compared with
overloaded_function\&. This is especially useful when the explicit type of the returned
overloaded_function
object does not need to be known (e\&.g\&., when used with Boost\&.Typeof\'s
BOOST_AUTO, C++11
auto, or when the overloaded function object is handled using a function template parameter, see the
Tutorial
section)\&.
.PP
The maximum number of functions to overload is given by the
BOOST_FUNCTIONAL_OVERLOADED_FUNCTION_CONFIG_OVERLOAD_MAX
configuration macro\&.
.PP
\fBNote:\fR
In this documentation,
__function_type__
is a placeholder for a symbol that is specific to the implementation of this library\&.
.PP
\fBSee:\fR
Tutorial
section,
overloaded_function,
BOOST_FUNCTIONAL_OVERLOADED_FUNCTION_CONFIG_OVERLOAD_MAX\&.

