.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE DEQ" 3 "" "" ""
.SH "NAME"
boost::container::deque
.SH "SYNOPSIS"
.\" value_type: Class template deque
.\" Class template deque: value_type
.\" swap: Class template deque
.\" Class template deque: swap
.\" stored_allocator_type: Class template deque
.\" Class template deque: stored_allocator_type
.\" size_type: Class template deque
.\" Class template deque: size_type
.\" shrink_to_fit: Class template deque
.\" Class template deque: shrink_to_fit
.\" reverse_iterator: Class template deque
.\" Class template deque: reverse_iterator
.\" resize: Class template deque
.\" Class template deque: resize
.\" rend: Class template deque
.\" Class template deque: rend
.\" reference: Class template deque
.\" Class template deque: reference
.\" rbegin: Class template deque
.\" Class template deque: rbegin
.\" push_front: Class template deque
.\" Class template deque: push_front
.\" push_back: Class template deque
.\" Class template deque: push_back
.\" pop_front: Class template deque
.\" Class template deque: pop_front
.\" pop_back: Class template deque
.\" Class template deque: pop_back
.\" pointer: Class template deque
.\" Class template deque: pointer
.\" nth: Class template deque
.\" Class template deque: nth
.\" iterator: Class template deque
.\" Class template deque: iterator
.\" insert: Class template deque
.\" Class template deque: insert
.\" index_of: Class template deque
.\" Class template deque: index_of
.\" get_stored_allocator: Class template deque
.\" Class template deque: get_stored_allocator
.\" front: Class template deque
.\" Class template deque: front
.\" erase: Class template deque
.\" Class template deque: erase
.\" end: Class template deque
.\" Class template deque: end
.\" emplace_back: Class template deque
.\" Class template deque: emplace_back
.\" emplace: Class template deque
.\" Class template deque: emplace
.\" difference_type: Class template deque
.\" Class template deque: difference_type
.\" deque_base: Class template deque
.\" Class template deque: deque_base
.\" deque: Class template deque
.\" Class template deque: deque
.\" const_reverse_iterator: Class template deque
.\" Class template deque: const_reverse_iterator
.\" const_reference: Class template deque
.\" Class template deque: const_reference
.\" const_pointer: Class template deque
.\" Class template deque: const_pointer
.\" const_iterator: Class template deque
.\" Class template deque: const_iterator
.\" clear: Class template deque
.\" Class template deque: clear
.\" begin: Class template deque
.\" Class template deque: begin
.\" back: Class template deque
.\" Class template deque: back
.\" at: Class template deque
.\" Class template deque: at
.\" assign: Class template deque
.\" Class template deque: assign
.\" allocator_type: Class template deque
.\" Class template deque: allocator_type

.sp
.nf
// In header: <boost/container/deque\&.hpp>

template<typename T, typename Allocator = new_allocator<T> > 
class deque : protected deque_base< Allocator > {
public:
  // types
  typedef T                                                                  value_type;            
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef implementation_defined                                             stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  deque();
  explicit deque(const allocator_type &) noexcept;
  explicit deque(size_type);
  deque(size_type, default_init_t);
  explicit deque(size_type, const allocator_type &);
  deque(size_type, default_init_t, const allocator_type &);
  deque(size_type, const value_type &, 
        const allocator_type & = allocator_type());
  template<typename InIt> 
    deque(InIt, InIt, const allocator_type & = allocator_type());
  deque(std::initializer_list< value_type >, 
        const allocator_type & = allocator_type());
  deque(const deque &);
  deque(deque &&);
  deque(const deque &, const allocator_type &);
  deque(deque &&, const allocator_type &);
  deque & operator=(const deque &);
  deque & operator=(deque &&) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
  deque & operator=(std::initializer_list< value_type >);
  ~deque();

  // public member functions
  void assign(size_type, const T &);
  template<typename InIt> void assign(InIt, InIt);
  void assign(std::initializer_list< value_type >);
  allocator_type get_allocator() const noexcept;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_iterator cbegin() const noexcept;
  const_iterator cend() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const noexcept;
  size_type size() const noexcept;
  size_type max_size() const noexcept;
  void resize(size_type);
  void resize(size_type, default_init_t);
  void resize(size_type, const value_type &);
  void shrink_to_fit();
  reference front() noexcept;
  const_reference front() const noexcept;
  reference back() noexcept;
  const_reference back() const noexcept;
  reference operator[](size_type) noexcept;
  const_reference operator[](size_type) const noexcept;
  iterator nth(size_type) noexcept;
  const_iterator nth(size_type) const noexcept;
  size_type index_of(iterator) noexcept;
  size_type index_of(const_iterator) const noexcept;
  reference at(size_type);
  const_reference at(size_type) const;
  template<class\&.\&.\&. Args> void emplace_front(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace(const_iterator, Args &&\&.\&.\&.);
  void push_front(const T &);
  void push_front(T &&);
  void push_back(const T &);
  void push_back(T &&);
  iterator insert(const_iterator, const T &);
  iterator insert(const_iterator, T &&);
  iterator insert(const_iterator, size_type, const value_type &);
  template<typename InIt> iterator insert(const_iterator, InIt, InIt);
  iterator insert(const_iterator, std::initializer_list< value_type >);
  void pop_front() noexcept;
  void pop_back() noexcept;
  iterator erase(const_iterator) noexcept;
  iterator erase(const_iterator, const_iterator) noexcept;
  void swap(deque &) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
  void clear() noexcept;

  // friend functions
  friend bool operator==(const deque &, const deque &);
  friend bool operator!=(const deque &, const deque &);
  friend bool operator<(const deque &, const deque &);
  friend bool operator>(const deque &, const deque &);
  friend bool operator<=(const deque &, const deque &);
  friend bool operator>=(const deque &, const deque &);
  friend void swap(deque &, deque &);
};
.fi
.SH "DESCRIPTION"
.PP
A double\-ended queue is a sequence that supports random access to elements, constant time insertion and removal of elements at the end of the sequence, and linear time insertion and removal of elements in the middle\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of object that is stored in the deque
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<T>
.fi

.sp
The allocator used for all internal memory management
.RE

.SS "deque public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
deque();
.fi

.sp
\fBEffects\fR: Default constructors a deque\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit deque(const allocator_type & a) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a deque taking the allocator as parameter\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit deque(size_type n);
.fi

.sp
\fBEffects\fR: Constructs a deque and inserts n value initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s value initialization throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
deque(size_type n, default_init_t);
.fi

.sp
\fBEffects\fR: Constructs a deque and inserts n default initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default initialization or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
explicit deque(size_type n, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a deque that will use a copy of allocator a and inserts n value initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s value initialization throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
deque(size_type n, default_init_t, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a deque that will use a copy of allocator a and inserts n default initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default initialization or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
deque(size_type n, const value_type & value, 
      const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a deque that will use a copy of allocator a and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename InIt> 
  deque(InIt first, InIt last, const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a deque that will use a copy of allocator a and inserts a copy of the range [first, last) in the deque\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced InIt throws\&.
.sp
\fBComplexity\fR: Linear to the range [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
deque(std::initializer_list< value_type > il, 
      const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a deque that will use a copy of allocator a and inserts a copy of the range [il\&.begin(), il\&.end()) in the deque\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
deque(const deque & x);
.fi

.sp
\fBEffects\fR: Copy constructs a deque\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
deque(deque && x);
.fi

.sp
\fBEffects\fR: Move constructor\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocator_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
deque(const deque & x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a vector using the specified allocator\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
deque(deque && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructor using the specified allocator\&. Moves x\'s resources to *this if a == allocator_type()\&. Otherwise copies values from x to *this\&.
.sp
\fBThrows\fR: If allocation or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant if a == x\&.get_allocator(), linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
deque & operator=(const deque & x);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as x\&.
.sp
\fBPostcondition\fR: this\->size() == x\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements in x\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
deque & operator=(deque && x) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Move assignment\&. All x\'s values are transferred to *this\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
deque & operator=(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as il\&.
.sp
\fBPostcondition\fR: this\->size() == il\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements in il\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
~deque();
.fi

.sp
\fBEffects\fR: Destroys the deque\&. All stored values are destroyed and used memory is deallocated\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements\&.
.RE

.SS "deque public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" assign: Class template deque
.\" Class template deque: assign

.sp

.nf
void assign(size_type n, const T & val);
.fi

.sp
\fBEffects\fR: Assigns the n copies of val to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" assign: Class template deque
.\" Class template deque: assign

.sp

.nf
template<typename InIt> void assign(InIt first, InIt last);
.fi

.sp
\fBEffects\fR: Assigns the the range [first, last) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing InIt throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" assign: Class template deque
.\" Class template deque: assign

.sp

.nf
void assign(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Assigns the the range [il\&.begin(), il\&.end()) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing std::initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to il\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a copy of the internal allocator\&.
.sp
\fBThrows\fR: If allocator\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" get_stored_allocator: Class template deque
.\" Class template deque: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" get_stored_allocator: Class template deque
.\" Class template deque: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" begin: Class template deque
.\" Class template deque: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" begin: Class template deque
.\" Class template deque: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rbegin: Class template deque
.\" Class template deque: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" rbegin: Class template deque
.\" Class template deque: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rend: Class template deque
.\" Class template deque: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template deque
.\" Class template deque: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
\fBEffects\fR: Returns true if the deque contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" resize: Class template deque
.\" Class template deque: resize

.sp

.nf
void resize(size_type new_size);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are value initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" resize: Class template deque
.\" Class template deque: resize

.sp

.nf
void resize(size_type new_size, default_init_t);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are default initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" resize: Class template deque
.\" Class template deque: resize

.sp

.nf
void resize(size_type new_size, const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are copy constructed from x\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" shrink_to_fit: Class template deque
.\" Class template deque: shrink_to_fit

.sp

.nf
void shrink_to_fit();
.fi

.sp
\fBEffects\fR: Tries to deallocate the excess of memory created with previous allocations\&. The size of the deque is unchanged
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" front: Class template deque
.\" Class template deque: front

.sp

.nf
reference front() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the first element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" front: Class template deque
.\" Class template deque: front

.sp

.nf
const_reference front() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the first element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" back: Class template deque
.\" Class template deque: back

.sp

.nf
reference back() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the last element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" back: Class template deque
.\" Class template deque: back

.sp

.nf
const_reference back() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the last element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}

.sp

.nf
reference operator[](size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}

.sp

.nf
const_reference operator[](size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end
.\" nth: Class template deque
.\" Class template deque: nth

.sp

.nf
iterator nth(size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end
.\" nth: Class template deque
.\" Class template deque: nth

.sp

.nf
const_iterator nth(size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns a const_iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end
.\" index_of: Class template deque
.\" Class template deque: index_of

.sp

.nf
size_type index_of(iterator p) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" index_of: Class template deque
.\" Class template deque: index_of

.sp

.nf
size_type index_of(const_iterator p) const noexcept;
.fi

.sp
\fBRequires\fR: begin() <= p <= end()\&.
.sp
\fBEffects\fR: Returns the index of the element pointed by p and size() if p == end()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" at: Class template deque
.\" Class template deque: at

.sp

.nf
reference at(size_type n);
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" at: Class template deque
.\" Class template deque: at

.sp

.nf
const_reference at(size_type n) const;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> void emplace_front(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the beginning of the deque\&.
.sp
\fBThrows\fR: If memory allocation throws or the in\-place constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" emplace_back: Class template deque
.\" Class template deque: emplace_back

.sp

.nf
template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the end of the deque\&.
.sp
\fBThrows\fR: If memory allocation throws or the in\-place constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end
.\" emplace: Class template deque
.\" Class template deque: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. before p
.sp
\fBThrows\fR: If memory allocation throws or the in\-place constructor throws\&.
.sp
\fBComplexity\fR: If p is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" push_front: Class template deque
.\" Class template deque: push_front

.sp

.nf
void push_front(const T & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x at the front of the deque\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" push_front: Class template deque
.\" Class template deque: push_front

.sp

.nf
void push_front(T && x);
.fi

.sp
\fBEffects\fR: Constructs a new element in the front of the deque and moves the resources of x to this new element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" push_back: Class template deque
.\" Class template deque: push_back

.sp

.nf
void push_back(const T & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x at the end of the deque\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" push_back: Class template deque
.\" Class template deque: push_back

.sp

.nf
void push_back(T && x);
.fi

.sp
\fBEffects\fR: Constructs a new element in the end of the deque and moves the resources of x to this new element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end
.\" insert: Class template deque
.\" Class template deque: insert

.sp

.nf
iterator insert(const_iterator p, const T & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of x before p\&.
.sp
\fBReturns\fR: an iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws or x\'s copy constructor throws\&.
.sp
\fBComplexity\fR: If p is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" end: Class template deque
.\" Class template deque: end
.\" insert: Class template deque
.\" Class template deque: insert

.sp

.nf
iterator insert(const_iterator p, T && x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a new element before p with x\'s resources\&.
.sp
\fBReturns\fR: an iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: If p is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" insert: Class template deque
.\" Class template deque: insert

.sp

.nf
iterator insert(const_iterator pos, size_type n, const value_type & x);
.fi

.sp
\fBRequires\fR: pos must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert n copies of x before pos\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or pos if n is 0\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" insert: Class template deque
.\" Class template deque: insert

.sp

.nf
template<typename InIt> 
  iterator insert(const_iterator pos, InIt first, InIt last);
.fi

.sp
\fBRequires\fR: pos must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [first, last) range before pos\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or pos if first == last\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced InIt throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to distance [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" insert: Class template deque
.\" Class template deque: insert

.sp

.nf
iterator insert(const_iterator pos, std::initializer_list< value_type > il);
.fi

.sp
\fBRequires\fR: pos must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [il\&.begin(), il\&.end()) range before pos\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or pos if il\&.begin() == il\&.end()\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced std::initializer_list throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to distance [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" pop_front: Class template deque
.\" Class template deque: pop_front

.sp

.nf
void pop_front() noexcept;
.fi

.sp
\fBEffects\fR: Removes the first element from the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" pop_back: Class template deque
.\" Class template deque: pop_back

.sp

.nf
void pop_back() noexcept;
.fi

.sp
\fBEffects\fR: Removes the last element from the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" if: Class template deque
.\" Class template deque: if
.\" erase: Class template deque
.\" Class template deque: erase

.sp

.nf
iterator erase(const_iterator pos) noexcept;
.fi

.sp
\fBEffects\fR: Erases the element at p\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements between pos and the last element (if pos is near the end) or the first element if(pos is near the beginning)\&. Constant if pos is the first or the last element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" if: Class template deque
.\" Class template deque: if
.\" erase: Class template deque
.\" Class template deque: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last) noexcept;
.fi

.sp
\fBEffects\fR: Erases the elements pointed by [first, last)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the distance between first and last plus the elements between pos and the last element (if pos is near the end) or the first element if(pos is near the beginning)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" swap: Class template deque
.\" Class template deque: swap

.sp

.nf
void swap(deque & x) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" clear: Class template deque
.\" Class template deque: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: Erases all the elements of the deque\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the deque\&.
.RE

.SS "deque friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const deque & x, const deque & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const deque & x, const deque & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const deque & x, const deque & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const deque & x, const deque & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const deque & x, const deque & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const deque & x, const deque & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template deque
.\" Class template deque: swap

.sp

.nf
friend void swap(deque & x, deque & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


