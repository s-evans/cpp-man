.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE BST" 3 "" "" ""
.SH "NAME"
boost::intrusive::bstree
.SH "SYNOPSIS"
.\" value_type: Class template bstree
.\" Class template bstree: value_type
.\" value_traits: Class template bstree
.\" Class template bstree: value_traits
.\" value_compare: Class template bstree
.\" Class template bstree: value_compare
.\" upper_bound: Class template bstree
.\" Class template bstree: upper_bound
.\" unlink_leftmost_without_rebalance: Class template bstree
.\" Class template bstree: unlink_leftmost_without_rebalance
.\" swap: Class template bstree
.\" Class template bstree: swap
.\" size_type: Class template bstree
.\" Class template bstree: size_type
.\" size: Class template bstree
.\" Class template bstree: size
.\" s_iterator_to: Class template bstree
.\" Class template bstree: s_iterator_to
.\" reverse_iterator: Class template bstree
.\" Class template bstree: reverse_iterator
.\" replace_node: Class template bstree
.\" Class template bstree: replace_node
.\" rend: Class template bstree
.\" Class template bstree: rend
.\" remove_node: Class template bstree
.\" Class template bstree: remove_node
.\" reference: Class template bstree
.\" Class template bstree: reference
.\" rebalance_subtree: Class template bstree
.\" Class template bstree: rebalance_subtree
.\" rebalance: Class template bstree
.\" Class template bstree: rebalance
.\" rbegin: Class template bstree
.\" Class template bstree: rbegin
.\" push_front: Class template bstree
.\" Class template bstree: push_front
.\" push_back: Class template bstree
.\" Class template bstree: push_back
.\" pointer: Class template bstree
.\" Class template bstree: pointer
.\" node_traits: Class template bstree
.\" Class template bstree: node_traits
.\" node_ptr: Class template bstree
.\" Class template bstree: node_ptr
.\" node_algorithms: Class template bstree
.\" Class template bstree: node_algorithms
.\" node: Class template bstree
.\" Class template bstree: node
.\" lower_bound: Class template bstree
.\" Class template bstree: lower_bound
.\" key_type: Class template bstree
.\" Class template bstree: key_type
.\" key_of_value: Class template bstree
.\" Class template bstree: key_of_value
.\" key_compare: Class template bstree
.\" Class template bstree: key_compare
.\" iterator_to: Class template bstree
.\" Class template bstree: iterator_to
.\" iterator: Class template bstree
.\" Class template bstree: iterator
.\" insert_unique_commit: Class template bstree
.\" Class template bstree: insert_unique_commit
.\" insert_unique_check: Class template bstree
.\" Class template bstree: insert_unique_check
.\" insert_unique: Class template bstree
.\" Class template bstree: insert_unique
.\" insert_equal: Class template bstree
.\" Class template bstree: insert_equal
.\" insert_commit_data: Class template bstree
.\" Class template bstree: insert_commit_data
.\" insert_before: Class template bstree
.\" Class template bstree: insert_before
.\" init_node: Class template bstree
.\" Class template bstree: init_node
.\" find: Class template bstree
.\" Class template bstree: find
.\" erase_and_dispose: Class template bstree
.\" Class template bstree: erase_and_dispose
.\" erase: Class template bstree
.\" Class template bstree: erase
.\" end: Class template bstree
.\" Class template bstree: end
.\" difference_type: Class template bstree
.\" Class template bstree: difference_type
.\" count: Class template bstree
.\" Class template bstree: count
.\" container_from_iterator: Class template bstree
.\" Class template bstree: container_from_iterator
.\" container_from_end_iterator: Class template bstree
.\" Class template bstree: container_from_end_iterator
.\" const_reverse_iterator: Class template bstree
.\" Class template bstree: const_reverse_iterator
.\" const_reference: Class template bstree
.\" Class template bstree: const_reference
.\" const_pointer: Class template bstree
.\" Class template bstree: const_pointer
.\" const_node_ptr: Class template bstree
.\" Class template bstree: const_node_ptr
.\" const_iterator: Class template bstree
.\" Class template bstree: const_iterator
.\" clone_from: Class template bstree
.\" Class template bstree: clone_from
.\" clear_and_dispose: Class template bstree
.\" Class template bstree: clear_and_dispose
.\" clear: Class template bstree
.\" Class template bstree: clear
.\" check: Class template bstree
.\" Class template bstree: check
.\" cend: Class template bstree
.\" Class template bstree: cend
.\" cbegin: Class template bstree
.\" Class template bstree: cbegin
.\" bstbase: Class template bstree
.\" Class template bstree: bstbase
.\" bounded_range: Class template bstree
.\" Class template bstree: bounded_range
.\" begin: Class template bstree
.\" Class template bstree: begin

.sp
.nf
// In header: <boost/intrusive/bstree\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class bstree : public bstbase< ValueTraits, VoidOrKeyOfValue, VoidOrKeyComp, ConstantTimeSize, SizeType, AlgoType, HeaderHolder >
{
public:
  // types
  typedef implementation_defined              value_traits;          
  typedef implementation_defined              pointer;               
  typedef implementation_defined              const_pointer;         
  typedef implementation_defined              value_type;            
  typedef implementation_defined              key_type;              
  typedef implementation_defined              key_of_value;          
  typedef implementation_defined              reference;             
  typedef implementation_defined              const_reference;       
  typedef implementation_defined              difference_type;       
  typedef implementation_defined              size_type;             
  typedef implementation_defined              value_compare;         
  typedef implementation_defined              key_compare;           
  typedef implementation_defined              iterator;              
  typedef implementation_defined              const_iterator;        
  typedef implementation_defined              reverse_iterator;      
  typedef implementation_defined              const_reverse_iterator;
  typedef implementation_defined              node_traits;           
  typedef implementation_defined              node;                  
  typedef implementation_defined              node_ptr;              
  typedef implementation_defined              const_node_ptr;        
  typedef implementation_defined              node_algorithms;       
  typedef node_algorithms::insert_commit_data insert_commit_data;    

  // construct/copy/destruct
  explicit bstree(const key_compare & = key_compare(), 
                  const value_traits & = value_traits());
  template<typename Iterator> 
    bstree(bool, Iterator, Iterator, const key_compare & = key_compare(), 
           const value_traits & = value_traits());
  bstree(bstree &&);
  bstree & operator=(bstree &&);
  ~bstree();

  // public member functions
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  reverse_iterator rbegin();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator crbegin() const;
  reverse_iterator rend();
  const_reverse_iterator rend() const;
  const_reverse_iterator crend() const;
  key_compare key_comp() const;
  value_compare value_comp() const;
  bool empty() const;
  size_type size() const;
  void swap(bstree &);
  template<typename Cloner, typename Disposer> 
    void clone_from(const bstree &, Cloner, Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(bstree &&, Cloner, Disposer);
  iterator insert_equal(reference);
  iterator insert_equal(const_iterator, reference);
  template<typename Iterator> void insert_equal(Iterator, Iterator);
  std::pair< iterator, bool > insert_unique(reference);
  iterator insert_unique(const_iterator, reference);
  template<typename Iterator> void insert_unique(Iterator, Iterator);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, bool > 
    insert_unique_check(const KeyType &, KeyTypeKeyCompare, 
                        insert_commit_data &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, bool > 
    insert_unique_check(const_iterator, const KeyType &, KeyTypeKeyCompare, 
                        insert_commit_data &);
  iterator insert_unique_commit(reference, const insert_commit_data &);
  iterator insert_before(const_iterator, reference);
  void push_back(reference);
  void push_front(reference);
  iterator erase(const_iterator);
  iterator erase(const_iterator, const_iterator);
  size_type erase(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    size_type erase(const KeyType &, KeyTypeKeyCompare);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    size_type erase_and_dispose(const key_type &, Disposer);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, const_iterator, Disposer);
  template<typename KeyType, typename KeyTypeKeyCompare, typename Disposer> 
    size_type erase_and_dispose(const KeyType &, KeyTypeKeyCompare, Disposer);
  void clear();
  template<typename Disposer> void clear_and_dispose(Disposer);
  size_type count(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    size_type count(const KeyType &, KeyTypeKeyCompare) const;
  iterator lower_bound(const key_type &);
  const_iterator lower_bound(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator lower_bound(const KeyType &, KeyTypeKeyCompare);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator lower_bound(const KeyType &, KeyTypeKeyCompare) const;
  iterator upper_bound(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator upper_bound(const KeyType &, KeyTypeKeyCompare);
  const_iterator upper_bound(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator upper_bound(const KeyType &, KeyTypeKeyCompare) const;
  iterator find(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator find(const KeyType &, KeyTypeKeyCompare);
  const_iterator find(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator find(const KeyType &, KeyTypeKeyCompare) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, iterator > 
    equal_range(const KeyType &, KeyTypeKeyCompare);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< const_iterator, const_iterator > 
    equal_range(const KeyType &, KeyTypeKeyCompare) const;
  std::pair< iterator, iterator > 
  bounded_range(const key_type &, const key_type &, bool, bool);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, iterator > 
    bounded_range(const KeyType &, const KeyType &, KeyTypeKeyCompare, bool, 
                  bool);
  std::pair< const_iterator, const_iterator > 
  bounded_range(const key_type &, const key_type &, bool, bool) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< const_iterator, const_iterator > 
    bounded_range(const KeyType &, const KeyType &, KeyTypeKeyCompare, bool, 
                  bool) const;
  iterator iterator_to(reference);
  const_iterator iterator_to(const_reference) const;
  pointer unlink_leftmost_without_rebalance();
  void replace_node(iterator, reference);
  void rebalance();
  iterator rebalance_subtree(iterator);
  template<typename ExtraChecker> void check(ExtraChecker) const;
  void check() const;

  // public static functions
  static bstree & container_from_end_iterator(iterator);
  static const bstree & container_from_end_iterator(const_iterator);
  static bstree & container_from_iterator(iterator);
  static const bstree & container_from_iterator(const_iterator);
  static iterator s_iterator_to(reference);
  static const_iterator s_iterator_to(const_reference);
  static void init_node(reference);
  static void remove_node(reference);

  // public data members
  static const bool constant_time_size;
  static const bool stateful_value_traits;
};
.fi
.SH "DESCRIPTION"
.PP
The class template bstree is an unbalanced intrusive binary search tree container\&. The no\-throw guarantee holds only, if the key_compare object doesn\'t throw\&.
.PP
The complexity guarantees only hold if the tree is balanced, logarithmic complexity would increase to linear if the tree is totally unbalanced\&.
.PP
The template parameter
T
is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
base_hook<>/member_hook<>/value_traits<>,
constant_time_size<>,
size_type<>
and
compare<>\&.
.SS "bstree public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit bstree(const key_compare & cmp = key_compare(), 
                const value_traits & v_traits = value_traits());
.fi

.sp
\fBEffects\fR: Constructs an empty container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor of the key_compare object throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Iterator> 
  bstree(bool unique, Iterator b, Iterator e, 
         const key_compare & cmp = key_compare(), 
         const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&. cmp must be a comparison function that induces a strict weak ordering\&.
.sp
\fBEffects\fR: Constructs an empty container and inserts elements from [b, e)\&.
.sp
\fBComplexity\fR: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bstree(bstree && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
bstree & operator=(bstree && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~bstree();
.fi

.sp
\fBEffects\fR: Detaches all elements from this\&. The objects in the set are not deleted (i\&.e\&. no destructors are called), but the nodes according to the
value_traits
template parameter are reinitialized and thus can be reused\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this\&.
.sp
\fBThrows\fR: Nothing\&.
.RE

.SS "bstree public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" begin: Class template bstree
.\" Class template bstree: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" begin: Class template bstree
.\" Class template bstree: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" cbegin: Class template bstree
.\" Class template bstree: cbegin

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" cend: Class template bstree
.\" Class template bstree: cend

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" rbegin: Class template bstree
.\" Class template bstree: rbegin

.sp

.nf
reverse_iterator rbegin();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" rbegin: Class template bstree
.\" Class template bstree: rbegin

.sp

.nf
const_reverse_iterator rbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rend: Class template bstree
.\" Class template bstree: rend

.sp

.nf
reverse_iterator rend();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rend: Class template bstree
.\" Class template bstree: rend

.sp

.nf
const_reverse_iterator rend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the key_compare object used by the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If key_compare copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns the value_compare object used by the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_compare copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container is empty\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" size: Class template bstree
.\" Class template bstree: size

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of elements stored in the container\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this if constant\-time size option is disabled\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" swap: Class template bstree
.\" Class template bstree: swap

.sp

.nf
void swap(bstree & other);
.fi

.sp
\fBEffects\fR: Swaps the contents of two containers\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the comparison functor\'s swap call throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" clone_from: Class template bstree
.\" Class template bstree: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(const bstree & src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this\&. Copies the predicate from the source container\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws or predicate copy assignment throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" clone_from: Class template bstree
.\" Class template bstree: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(bstree && src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this\&. Copies the predicate from the source container\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws or predicate copy assignment throws\&. Basic guarantee\&.
.sp
\fBNote\fR: This version can modify the source container, useful to implement move semantics\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" insert_equal: Class template bstree
.\" Class template bstree: insert_equal

.sp

.nf
iterator insert_equal(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue
.sp
\fBEffects\fR: Inserts value into the container before the upper bound\&.
.sp
\fBComplexity\fR: Average complexity for insert element is at most logarithmic\&.
.sp
\fBThrows\fR: If the internal key_compare ordering function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" insert_equal: Class template bstree
.\" Class template bstree: insert_equal

.sp

.nf
iterator insert_equal(const_iterator hint, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and "hint" must be a valid iterator\&.
.sp
\fBEffects\fR: Inserts x into the container, using "hint" as a hint to where it will be inserted\&. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)
.sp
\fBComplexity\fR: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint\&.
.sp
\fBThrows\fR: If the internal key_compare ordering function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" insert_equal: Class template bstree
.\" Class template bstree: insert_equal

.sp

.nf
template<typename Iterator> void insert_equal(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Inserts a each element of a range into the container before the upper bound of the key of each element\&.
.sp
\fBComplexity\fR: Insert range is in general O(N * log(N)), where N is the size of the range\&. However, it is linear in N if the range is already sorted by value_comp()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" insert_unique: Class template bstree
.\" Class template bstree: insert_unique

.sp

.nf
std::pair< iterator, bool > insert_unique(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue
.sp
\fBEffects\fR: Inserts value into the container if the value is not already present\&.
.sp
\fBComplexity\fR: Average complexity for insert element is at most logarithmic\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" insert_unique: Class template bstree
.\" Class template bstree: insert_unique

.sp

.nf
iterator insert_unique(const_iterator hint, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and "hint" must be a valid iterator
.sp
\fBEffects\fR: Tries to insert x into the container, using "hint" as a hint to where it will be inserted\&.
.sp
\fBComplexity\fR: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" insert_unique: Class template bstree
.\" Class template bstree: insert_unique

.sp

.nf
template<typename Iterator> void insert_unique(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Tries to insert each element of a range into the container\&.
.sp
\fBComplexity\fR: Insert range is in general O(N * log(N)), where N is the size of the range\&. However, it is linear in N if the range is already sorted by value_comp()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" insert_unique_check: Class template bstree
.\" Class template bstree: insert_unique_check

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, bool > 
  insert_unique_check(const KeyType & key, KeyTypeKeyCompare comp, 
                      insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: comp must be a comparison function that induces the same strict weak ordering as key_compare\&. The difference is that comp compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Checks if a value can be inserted in the container, using a user provided key instead of the value itself\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing an iterator to the already present value and false\&. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function\&.
.sp
\fBComplexity\fR: Average complexity is at most logarithmic\&.
.sp
\fBThrows\fR: If the comp ordering function throws\&. Strong guarantee\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant\-time\&. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1))\&.
.sp
"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" insert_unique_check: Class template bstree
.\" Class template bstree: insert_unique_check

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, bool > 
  insert_unique_check(const_iterator hint, const KeyType & key, 
                      KeyTypeKeyCompare comp, 
                      insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: comp must be a comparison function that induces the same strict weak ordering as key_compare\&. The difference is that comp compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing an iterator to the already present value and false\&. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function\&.
.sp
\fBComplexity\fR: Logarithmic in general, but it\'s amortized constant time if t is inserted immediately before hint\&.
.sp
\fBThrows\fR: If the comp ordering function throws\&. Strong guarantee\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant\-time\&. This can give a total constant\-time complexity to the insertion: check(O(1)) + commit(O(1))\&.
.sp
"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" insert_unique_commit: Class template bstree
.\" Class template bstree: insert_unique_commit

.sp

.nf
iterator insert_unique_commit(reference value, 
                              const insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: value must be an lvalue of type value_type\&. commit_data must have been obtained from a previous call to "insert_check"\&. No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit"\&.
.sp
\fBEffects\fR: Inserts the value in the container using the information obtained from the "commit_data" that a previous "insert_check" filled\&.
.sp
\fBReturns\fR: An iterator to the newly inserted object\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function has only sense if a "insert_check" has been previously executed to fill "commit_data"\&. No value should be inserted or erased between the "insert_check" and "insert_commit" calls\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" insert_before: Class template bstree
.\" Class template bstree: insert_before

.sp

.nf
iterator insert_before(const_iterator pos, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate
.sp
\fBEffects\fR: Inserts x into the container before "pos"\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" push_back: Class template bstree
.\" Class template bstree: push_back

.sp

.nf
void push_back(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and it must be no less than the greatest inserted key
.sp
\fBEffects\fR: Inserts x into the container in the last position\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken\&. This function is slightly more efficient than using "insert_before"\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" push_front: Class template bstree
.\" Class template bstree: push_front

.sp

.nf
void push_front(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and it must be no greater than the minimum inserted key
.sp
\fBEffects\fR: Inserts x into the container in the first position\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken\&. This function is slightly more efficient than using "insert_before"\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" erase: Class template bstree
.\" Class template bstree: erase

.sp

.nf
iterator erase(const_iterator i);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by i\&.
.sp
\fBComplexity\fR: Average complexity for erase element is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" erase: Class template bstree
.\" Class template bstree: erase

.sp

.nf
iterator erase(const_iterator b, const_iterator e);
.fi

.sp
\fBEffects\fR: Erases the range pointed to by b end e\&.
.sp
\fBComplexity\fR: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" erase: Class template bstree
.\" Class template bstree: erase

.sp

.nf
size_type erase(const key_type & key);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given value\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" erase: Class template bstree
.\" Class template bstree: erase

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  size_type erase(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "comp"\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" erase_and_dispose: Class template bstree
.\" Class template bstree: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator i, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element pointed to by i\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBComplexity\fR: Average complexity for erase element is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" erase_and_dispose: Class template bstree
.\" Class template bstree: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  size_type erase_and_dispose(const key_type & key, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given value\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" erase_and_dispose: Class template bstree
.\" Class template bstree: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator b, const_iterator e, 
                             Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the range pointed to by b end e\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBComplexity\fR: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" erase_and_dispose: Class template bstree
.\" Class template bstree: erase_and_dispose

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare, typename Disposer> 
  size_type erase_and_dispose(const KeyType & key, KeyTypeKeyCompare comp, 
                              Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "comp"\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" clear: Class template bstree
.\" Class template bstree: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all of the elements\&.
.sp
\fBComplexity\fR: Linear to the number of elements on the container\&. if it\'s a safe\-mode or auto\-unlink value_type\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" clear_and_dispose: Class template bstree
.\" Class template bstree: clear_and_dispose

.sp

.nf
template<typename Disposer> void clear_and_dispose(Disposer disposer);
.fi

.sp
\fBEffects\fR: Erases all of the elements calling disposer(p) for each node to be erased\&.
\fBComplexity\fR: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. Calls N times to disposer functor\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" count: Class template bstree
.\" Class template bstree: count

.sp

.nf
size_type count(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given value
.sp
\fBComplexity\fR: Logarithmic to the number of elements contained plus lineal to number of objects with the given value\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" count: Class template bstree
.\" Class template bstree: count

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  size_type count(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given key
.sp
\fBComplexity\fR: Logarithmic to the number of elements contained plus lineal to number of objects with the given key\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" lower_bound: Class template bstree
.\" Class template bstree: lower_bound

.sp

.nf
iterator lower_bound(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" lower_bound: Class template bstree
.\" Class template bstree: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" lower_bound: Class template bstree
.\" Class template bstree: lower_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator lower_bound(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" lower_bound: Class template bstree
.\" Class template bstree: lower_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator 
  lower_bound(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" upper_bound: Class template bstree
.\" Class template bstree: upper_bound

.sp

.nf
iterator upper_bound(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" upper_bound: Class template bstree
.\" Class template bstree: upper_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator upper_bound(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" upper_bound: Class template bstree
.\" Class template bstree: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" upper_bound: Class template bstree
.\" Class template bstree: upper_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator 
  upper_bound(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" find: Class template bstree
.\" Class template bstree: find

.sp

.nf
iterator find(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" find: Class template bstree
.\" Class template bstree: find

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator find(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" find: Class template bstree
.\" Class template bstree: find

.sp

.nf
const_iterator find(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Finds a const_iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" end: Class template bstree
.\" Class template bstree: end
.\" find: Class template bstree
.\" Class template bstree: find

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator find(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Finds a const_iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, iterator > 
  equal_range(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< const_iterator, const_iterator > 
  equal_range(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" bounded_range: Class template bstree
.\" Class template bstree: bounded_range

.sp

.nf
std::pair< iterator, iterator > 
bounded_range(const key_type & lower_key, const key_type & upper_value, 
              bool left_closed, bool right_closed);
.fi

.sp
\fBRequires\fR: \'lower_key\' must not be greater than \'upper_key\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise
.sp
second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" bounded_range: Class template bstree
.\" Class template bstree: bounded_range

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, iterator > 
  bounded_range(const KeyType & lower_key, const KeyType & upper_key, 
                KeyTypeKeyCompare comp, bool left_closed, bool right_closed);
.fi

.sp
\fBRequires\fR: KeyTypeKeyCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the container\&. \'lower_key\' must not be greater than \'upper_key\' according to \'comp\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise
.sp
second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}
.\" bounded_range: Class template bstree
.\" Class template bstree: bounded_range

.sp

.nf
std::pair< const_iterator, const_iterator > 
bounded_range(const key_type & lower_key, const key_type & upper_key, 
              bool left_closed, bool right_closed) const;
.fi

.sp
\fBRequires\fR: \'lower_key\' must not be greater than \'upper_key\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise
.sp
second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}
.\" bounded_range: Class template bstree
.\" Class template bstree: bounded_range

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< const_iterator, const_iterator > 
  bounded_range(const KeyType & lower_key, const KeyType & upper_key, 
                KeyTypeKeyCompare comp, bool left_closed, bool right_closed) const;
.fi

.sp
\fBRequires\fR: KeyTypeKeyCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the container\&. \'lower_key\' must not be greater than \'upper_key\' according to \'comp\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise
.sp
second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}
.\" iterator_to: Class template bstree
.\" Class template bstree: iterator_to

.sp

.nf
iterator iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'65.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "65." 4.2
.\}
.\" iterator_to: Class template bstree
.\" Class template bstree: iterator_to

.sp

.nf
const_iterator iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'66.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "66." 4.2
.\}
.\" unlink_leftmost_without_rebalance: Class template bstree
.\" Class template bstree: unlink_leftmost_without_rebalance

.sp

.nf
pointer unlink_leftmost_without_rebalance();
.fi

.sp
\fBEffects\fR: Unlinks the leftmost node from the container\&.
.sp
\fBComplexity\fR: Average complexity is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls\&. This function is normally used to achieve a step by step controlled destruction of the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'67.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "67." 4.2
.\}
.\" replace_node: Class template bstree
.\" Class template bstree: replace_node

.sp

.nf
void replace_node(iterator replace_this, reference with_this);
.fi

.sp
\fBRequires\fR: replace_this must be a valid iterator of *this and with_this must not be inserted in any container\&.
.sp
\fBEffects\fR: Replaces replace_this in its position in the container with with_this\&. The container does not need to be rebalanced\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules\&. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'68.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "68." 4.2
.\}
.\" rebalance: Class template bstree
.\" Class template bstree: rebalance

.sp

.nf
void rebalance();
.fi

.sp
\fBEffects\fR: Rebalances the tree\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'69.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "69." 4.2
.\}
.\" rebalance_subtree: Class template bstree
.\" Class template bstree: rebalance_subtree

.sp

.nf
iterator rebalance_subtree(iterator root);
.fi

.sp
\fBRequires\fR: old_root is a node of a tree\&.
.sp
\fBEffects\fR: Rebalances the subtree rooted at old_root\&.
.sp
\fBReturns\fR: The new root of the subtree\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements in the subtree\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'70.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "70." 4.2
.\}
.\" check: Class template bstree
.\" Class template bstree: check

.sp

.nf
template<typename ExtraChecker> void check(ExtraChecker extra_checker) const;
.fi

.sp
\fBEffects\fR: Asserts the integrity of the container with additional checks provided by the user\&.
.sp
\fBComplexity\fR: Linear time\&.
.sp
\fBNote\fR: The method might not have effect when asserts are turned off (e\&.g\&., with NDEBUG)\&. Experimental function, interface might change in future versions\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'71.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "71." 4.2
.\}
.\" check: Class template bstree
.\" Class template bstree: check

.sp

.nf
void check() const;
.fi

.sp
\fBEffects\fR: Asserts the integrity of the container\&.
.sp
\fBComplexity\fR: Linear time\&.
.sp
\fBNote\fR: The method has no effect when asserts are turned off (e\&.g\&., with NDEBUG)\&. Experimental function, interface might change in future versions\&.
.RE

.SS "bstree public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" container_from_end_iterator: Class template bstree
.\" Class template bstree: container_from_end_iterator

.sp

.nf
static bstree & container_from_end_iterator(iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" container_from_end_iterator: Class template bstree
.\" Class template bstree: container_from_end_iterator

.sp

.nf
static const bstree & container_from_end_iterator(const_iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end const_iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" container_from_iterator: Class template bstree
.\" Class template bstree: container_from_iterator

.sp

.nf
static bstree & container_from_iterator(iterator it);
.fi

.sp
\fBPrecondition\fR: it must be a valid iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" container_from_iterator: Class template bstree
.\" Class template bstree: container_from_iterator

.sp

.nf
static const bstree & container_from_iterator(const_iterator it);
.fi

.sp
\fBPrecondition\fR: it must be a valid end const_iterator of container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" s_iterator_to: Class template bstree
.\" Class template bstree: s_iterator_to

.sp

.nf
static iterator s_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" s_iterator_to: Class template bstree
.\" Class template bstree: s_iterator_to

.sp

.nf
static const_iterator s_iterator_to(const_reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" init_node: Class template bstree
.\" Class template bstree: init_node

.sp

.nf
static void init_node(reference value);
.fi

.sp
\fBRequires\fR: value shall not be in a container\&.
.sp
\fBEffects\fR: init_node puts the hook of a value in a well\-known default state\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: This function puts the hook in the well\-known default state used by auto_unlink and safe hooks\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" remove_node: Class template bstree
.\" Class template bstree: remove_node

.sp

.nf
static void remove_node(reference value);
.fi

.sp
\fBEffects\fR: removes "value" from the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic time\&.
.sp
\fBNote\fR: This static function is only usable with non\-constant time size containers that have stateless comparison functors\&.
.sp
If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued\&.
.RE


