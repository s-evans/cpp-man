.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTION TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::xpressive::let \- For binding local variables to placeholders in semantic actions when constructing a regex_iterator or a regex_token_iterator\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/xpressive/regex_actions\&.hpp>


template<typename\&.\&.\&. ArgBindings> \fIunspecified\fR let(ArgBindings const &\&.\&.\&. args);
.fi
.SH "DESCRIPTION"
.PP

xpressive::let()
serves the same purpose as
match_results::let(); that is, it binds a placeholder to a local value\&. The purpose is to allow a regex with semantic actions to be defined that refers to objects that do not yet exist\&. Rather than referring directly to an object, a semantic action can refer to a placeholder, and the value of the placeholder can be specified later with a
\fIlet expression\fR\&. The
\fIlet expression\fR
created with
let()
is passed to the constructor of either
regex_iterator
or
regex_token_iterator\&.
.PP
See the section
"Referring to Non\-Local Variables"
in the Users\' Guide for more discussion\&.
.PP
\fIExample:\fR

.sp
.if n \{\
.RS 4
.\}
.nf
// Define a placeholder for a map object:
placeholder<std::map<std::string, int> > _map;

// Match a word and an integer, separated by =>,
// and then stuff the result into a std::map<>
sregex pair = ( (s1= +_w) >> "=>" >> (s2= +_d) )
    [ _map[s1] = as<int>(s2) ];

// The string to parse
std::string str("aaa=>1 bbb=>23 ccc=>456");

// Here is the actual map to fill in:
std::map<std::string, int> result;

// Create a regex_iterator to find all the matches
sregex_iterator it(str\&.begin(), str\&.end(), pair, let(_map=result));
sregex_iterator end;

// step through all the matches, and fill in
// the result map
while(it != end)
    ++it;

std::cout << result["aaa"] << \'\en\';
std::cout << result["bbb"] << \'\en\';
std::cout << result["ccc"] << \'\en\';

.fi
.if n \{\
.RE
.\}
.sp
The above code displays:
.sp
.if n \{\
.RS 4
.\}
.nf
1
23
456

.fi
.if n \{\
.RE
.\}
.sp

.PP
Parameters:
.RS 4
.PP
args
.RS 4
A set of argument bindings, where each argument binding is an assignment expression, the left hand side of which must be an instance of
placeholder<X>
for some
X, and the right hand side is an lvalue of type
X\&.
.RE
.RE

