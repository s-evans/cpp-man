.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE S" 3 "" "" ""
.SH "NAME"
boost::interprocess::shared_ptr
.SH "SYNOPSIS"
.\" value_type: Class template shared_ptr
.\" Class template shared_ptr: value_type
.\" swap: Class template shared_ptr
.\" Class template shared_ptr: swap
.\" shared_ptr: Class template shared_ptr
.\" Class template shared_ptr: shared_ptr
.\" reset: Class template shared_ptr
.\" Class template shared_ptr: reset
.\" reference: Class template shared_ptr
.\" Class template shared_ptr: reference
.\" pointer: Class template shared_ptr
.\" Class template shared_ptr: pointer
.\" get: Class template shared_ptr
.\" Class template shared_ptr: get
.\" element_type: Class template shared_ptr
.\" Class template shared_ptr: element_type
.\" const_reference: Class template shared_ptr
.\" Class template shared_ptr: const_reference
.\" const_deleter_pointer: Class template shared_ptr
.\" Class template shared_ptr: const_deleter_pointer
.\" const_allocator_pointer: Class template shared_ptr
.\" Class template shared_ptr: const_allocator_pointer

.sp
.nf
// In header: <boost/interprocess/smart_ptr/shared_ptr\&.hpp>

template<typename T, typename VoidAllocator, typename Deleter> 
class shared_ptr {
public:
  // types
  typedef T                                                                                                                         element_type;           
  typedef T                                                                                                                         value_type;             
  typedef boost::intrusive::pointer_traits< typename VoidAllocator::pointer >::template rebind_pointer< T >::type                   pointer;                
  typedef \fIunspecified\fR                                                                                                               reference;              
  typedef \fIunspecified\fR                                                                                                               const_reference;        
  typedef boost::intrusive::pointer_traits< typename VoidAllocator::pointer >::template rebind_pointer< const Deleter >::type       const_deleter_pointer;  
  typedef boost::intrusive::pointer_traits< typename VoidAllocator::pointer >::template rebind_pointer< const VoidAllocator >::type const_allocator_pointer;

  // construct/copy/destruct
  shared_ptr();
  explicit shared_ptr(const pointer &, 
                      const VoidAllocator & = VoidAllocator(), 
                      const Deleter & = Deleter());
  shared_ptr(const shared_ptr &);
  shared_ptr(const shared_ptr &, const pointer &);
  template<typename Y> 
    shared_ptr(shared_ptr< Y, VoidAllocator, Deleter > const &);
  template<typename Y> 
    explicit shared_ptr(weak_ptr< Y, VoidAllocator, Deleter > const &);
  explicit shared_ptr(shared_ptr &&);
  template<typename Y> 
    shared_ptr & operator=(shared_ptr< Y, VoidAllocator, Deleter > const &);
  shared_ptr & operator=(BOOST_COPY_ASSIGN_REF(shared_ptr));
  shared_ptr & operator=(shared_ptr &&);

  // public member functions
  void reset();
  template<typename Pointer> 
    void reset(const Pointer &, const VoidAllocator & = VoidAllocator(), 
               const Deleter & = Deleter());
  template<typename Y> 
    void reset(shared_ptr< Y, VoidAllocator, Deleter > const &, 
               const pointer &);
  reference operator*() const;
  pointer operator\->() const;
  pointer get() const;
  bool operator!() const;
  bool unique() const;
  long use_count() const;
  void swap(shared_ptr< T, VoidAllocator, Deleter > &);
};
.fi
.SH "DESCRIPTION"
.PP
shared_ptr
stores a pointer to a dynamically allocated object\&. The object pointed to is guaranteed to be deleted when the last
shared_ptr
pointing to it is destroyed or reset\&.
.PP
shared_ptr
is parameterized on T (the type of the object pointed to), VoidAllocator (the void allocator to be used to allocate the auxiliary data) and Deleter (the deleter whose operator() will be used to delete the object\&.
.PP
The internal pointer will be of the same pointer type as typename VoidAllocator::pointer type (that is, if typename VoidAllocator::pointer is offset_ptr<void>, the internal pointer will be offset_ptr<T>)\&.
.PP
Because the implementation uses reference counting, cycles of
shared_ptr
instances will not be reclaimed\&. For example, if main() holds a
shared_ptr
to A, which directly or indirectly holds a
shared_ptr
back to A, A\'s use count will be 2\&. Destruction of the original
shared_ptr
will leave A dangling with a use count of 1\&. Use
weak_ptr
to "break cycles\&."
.SS "shared_ptr public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" get: Class template shared_ptr
.\" Class template shared_ptr: get

.sp

.nf
shared_ptr();
.fi

.sp
Constructs an empty
shared_ptr\&. Use_count() == 0 && get()== 0\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit shared_ptr(const pointer & p, 
                    const VoidAllocator & a = VoidAllocator(), 
                    const Deleter & d = Deleter());
.fi

.sp
Constructs a
shared_ptr
that owns the pointer p\&. Auxiliary data will be allocated with a copy of a and the object will be deleted with a copy of d\&. Requirements: Deleter and A\'s copy constructor must not throw\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
shared_ptr(const shared_ptr & r);
.fi

.sp
Copy constructs a
shared_ptr\&. If r is empty, constructs an empty
shared_ptr\&. Otherwise, constructs a
shared_ptr
that shares ownership with r\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
shared_ptr(const shared_ptr & other, const pointer & p);
.fi

.sp
Constructs a
shared_ptr
that shares ownership with other and stores p\&. Postconditions: get() == p && use_count() == r\&.use_count()\&. Throws: nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename Y> 
  shared_ptr(shared_ptr< Y, VoidAllocator, Deleter > const & r);
.fi

.sp
If r is empty, constructs an empty
shared_ptr\&. Otherwise, constructs a
shared_ptr
that shares ownership with r\&. Never throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename Y> 
  explicit shared_ptr(weak_ptr< Y, VoidAllocator, Deleter > const & r);
.fi

.sp
Constructs a
shared_ptr
that shares ownership with r and stores a copy of the pointer stored in r\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
explicit shared_ptr(shared_ptr && other);
.fi

.sp
Move\-Constructs a
shared_ptr
that takes ownership of other resource and other is put in default\-constructed state\&. Throws: nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename Y> 
  shared_ptr & operator=(shared_ptr< Y, VoidAllocator, Deleter > const & r);
.fi

.sp
Equivalent to shared_ptr(r)\&.swap(*this)\&. Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
shared_ptr & operator=(BOOST_COPY_ASSIGN_REF(shared_ptr) r);
.fi

.sp
Equivalent to shared_ptr(r)\&.swap(*this)\&. Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
shared_ptr & operator=(shared_ptr && other);
.fi

.sp
Move\-assignment\&. Equivalent to shared_ptr(other)\&.swap(*this)\&. Never throws
.RE

.SS "shared_ptr public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" reset: Class template shared_ptr
.\" Class template shared_ptr: reset

.sp

.nf
void reset();
.fi

.sp
This is equivalent to: this_type()\&.swap(*this);
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" reset: Class template shared_ptr
.\" Class template shared_ptr: reset

.sp

.nf
template<typename Pointer> 
  void reset(const Pointer & p, const VoidAllocator & a = VoidAllocator(), 
             const Deleter & d = Deleter());
.fi

.sp
This is equivalent to: this_type(p, a, d)\&.swap(*this);
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" reset: Class template shared_ptr
.\" Class template shared_ptr: reset

.sp

.nf
template<typename Y> 
  void reset(shared_ptr< Y, VoidAllocator, Deleter > const & r, 
             const pointer & p);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
reference operator*() const;
.fi

.sp
Returns a reference to the pointed type
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
pointer operator\->() const;
.fi

.sp
Returns the pointer pointing to the owned object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" get: Class template shared_ptr
.\" Class template shared_ptr: get

.sp

.nf
pointer get() const;
.fi

.sp
Returns the pointer pointing to the owned object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool operator!() const;
.fi

.sp
Not operator\&. Returns true if this\->get() != 0, false otherwise
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
bool unique() const;
.fi

.sp
Returns use_count() == 1\&. unique() might be faster than use_count()
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
long use_count() const;
.fi

.sp
Returns the number of
shared_ptr
objects, *this included, that share ownership with *this, or an unspecified nonnegative value when *this is empty\&. use_count() is not necessarily efficient\&. Use only for debugging and testing purposes, not for production code\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" swap: Class template shared_ptr
.\" Class template shared_ptr: swap

.sp

.nf
void swap(shared_ptr< T, VoidAllocator, Deleter > & other);
.fi

.sp
Exchanges the contents of the two smart pointers\&.
.RE


