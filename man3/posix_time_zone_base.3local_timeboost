.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPL" 3 "" "" ""
.SH "NAME"
boost::local_time::posix_time_zone_base \- A time zone class constructed from a POSIX time zone string\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/local_time/posix_time_zone\&.hpp>

template<typename CharT> 
class posix_time_zone_base :
  public date_time::time_zone_base< posix_time::ptime, CharT >
{
public:
  // types
  typedef boost::posix_time::time_duration                                                           time_duration_type;     
  typedef date_time::time_zone_names_base< CharT >                                                   time_zone_names;        
  typedef date_time::time_zone_base< posix_time::ptime, CharT >                                      base_type;              
  typedef base_type::string_type                                                                     string_type;            
  typedef CharT                                                                                      char_type;              
  typedef base_type::stringstream_type                                                               stringstream_type;      
  typedef boost::char_separator< char_type, std::char_traits< char_type > >                          char_separator_type;    
  typedef boost::tokenizer< char_separator_type, typename string_type::const_iterator, string_type > tokenizer_type;         
  typedef tokenizer_type::iterator                                                                   tokenizer_iterator_type;

  // construct/copy/destruct
  posix_time_zone_base(const string_type &);
  ~posix_time_zone_base();

  // public member functions
  virtual string_type std_zone_abbrev() const;
  virtual string_type dst_zone_abbrev() const;
  virtual string_type std_zone_name() const;
  virtual string_type dst_zone_name() const;
  virtual bool has_dst() const;
  virtual posix_time::ptime dst_local_start_time(gregorian::greg_year) const;
  virtual posix_time::ptime dst_local_end_time(gregorian::greg_year) const;
  virtual time_duration_type base_utc_offset() const;
  virtual time_duration_type dst_offset() const;
  virtual string_type to_posix_string() const;

  // private member functions
  void calc_zone(const string_type &);
  void calc_rules(const string_type &, const string_type &);
  void M_func(const string_type &, const string_type &);
  void julian_no_leap(const string_type &, const string_type &);
  void julian_day(const string_type &, const string_type &);

  // private static functions
  static std::string td_as_string(const time_duration_type &);
};
.fi
.SH "DESCRIPTION"
.PP
A POSIX time zone string takes the form of:&#9618;.br&#9618;
"std offset dst [offset],start[/time],end[/time]" (w/no spaces) \'std\' specifies the abbrev of the time zone\&.&#9618;.br&#9618;
\'offset\' is the offset from UTC\&.&#9618;.br&#9618;
\'dst\' specifies the abbrev of the time zone during daylight savings time\&.&#9618;.br&#9618;
The second offset is how many hours changed during DST\&. Default=1&#9618;.br&#9618;
\'start\' and\'end\' are the dates when DST goes into (and out of) effect\&.&#9618;.br&#9618;
\'offset\' takes the form of: [+|\-]hh[:mm[:ss]] {h=0\-23, m/s=0\-59}&#9618;.br&#9618;
\'time\' and \'offset\' take the same form\&. Time defaults=02:00:00&#9618;.br&#9618;
\'start\' and \'end\' can be one of three forms:&#9618;.br&#9618;
Mm\&.w\&.d {month=1\-12, week=1\-5 (5 is always last), day=0\-6}&#9618;.br&#9618;
Jn {n=1\-365 Feb29 is never counted}&#9618;.br&#9618;
n {n=0\-365 Feb29 is counted in leap years}&#9618;.br&#9618;
Example "PST\-5PDT01:00:00,M4\&.1\&.0/02:00:00,M10\&.1\&.0/02:00:00"
&#9618;.br&#9618;
Exceptions will be thrown under these conditions:&#9618;.br&#9618;
An invalid date spec (see date class)&#9618;.br&#9618;
A
boost::local_time::bad_offset
exception will be thrown for:&#9618;.br&#9618;
A DST start or end offset that is negative or more than 24 hours&#9618;.br&#9618;
A UTC zone that is greater than +14 or less than \-12 hours&#9618;.br&#9618;
A
boost::local_time::bad_adjustment
exception will be thrown for:&#9618;.br&#9618;
A DST adjustment that is 24 hours or more (positive or negative)&#9618;.br&#9618;
.PP
Note that UTC zone offsets can be greater than +12:
\m[blue]\fBhttp://www\&.worldtimezone\&.com/utc/utc+1200\&.html\fR\m[]
.SS "posix_time_zone_base public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
posix_time_zone_base(const string_type & s);
.fi

Construct from a POSIX time zone string\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
~posix_time_zone_base();
.fi

.RE

.SS "posix_time_zone_base public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
virtual string_type std_zone_abbrev() const;
.fi

String for the zone when not in daylight savings (eg: EST) .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
virtual string_type dst_zone_abbrev() const;
.fi

.sp
String for the timezone when in daylight savings (eg: EDT) For those time zones that have no DST, an empty string is used
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
virtual string_type std_zone_name() const;
.fi

.sp
String for the zone when not in daylight savings (eg: Eastern Standard Time) The full STD name is not extracted from the posix time zone string\&. Therefore, the STD abbreviation is used in it\'s place
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
virtual string_type dst_zone_name() const;
.fi

.sp
String for the timezone when in daylight savings (eg: Eastern Daylight Time) The full DST name is not extracted from the posix time zone string\&. Therefore, the STD abbreviation is used in it\'s place\&. For time zones that have no DST, an empty string is used
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
virtual bool has_dst() const;
.fi

True if zone uses daylight savings adjustments otherwise false\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
virtual posix_time::ptime dst_local_start_time(gregorian::greg_year y) const;
.fi

Local time that DST starts <ndash></ndash> NADT if has_dst is false\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
virtual posix_time::ptime dst_local_end_time(gregorian::greg_year y) const;
.fi

Local time that DST ends <ndash></ndash> NADT if has_dst is false\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
virtual time_duration_type base_utc_offset() const;
.fi

Base offset from UTC for zone (eg: \-07:30:00) .RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
virtual time_duration_type dst_offset() const;
.fi

Adjustment forward or back made while DST is in effect\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
virtual string_type to_posix_string() const;
.fi

Returns a POSIX time_zone string for this object\&. .RE

.SS "posix_time_zone_base private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void calc_zone(const string_type & obj);
.fi

.sp
Extract time zone abbreviations for STD & DST as well as the offsets for the time shift that occurs and how much of a shift\&. At this time full time zone names are NOT extracted so the abbreviations are used in their place
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void calc_rules(const string_type & start, const string_type & end);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void M_func(const string_type & s, const string_type & e);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void julian_no_leap(const string_type & s, const string_type & e);
.fi

Julian day\&. Feb29 is never counted, even in leap years\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void julian_day(const string_type & s, const string_type & e);
.fi

Julian day\&. Feb29 is always counted, but exception thrown in non\-leap years\&. .RE

.SS "posix_time_zone_base private static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static std::string td_as_string(const time_duration_type & td);
.fi

helper function used when throwing exceptions .RE


