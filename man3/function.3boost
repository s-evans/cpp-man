.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE FU" 3 "" "" ""
.SH "NAME"
boost::function \- A generalized function pointer that can be used for callbacks or wrapping function objects\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/function\&.hpp>

template<typename Signature> 
class function : public functionN<R, T1, T2, \&.\&.\&., TN> {
public:
  // types
  typedef R  result_type;         
  typedef T1 argument_type;         // If N == 1
  typedef T1 first_argument_type;   // If N == 2
  typedef T2 second_argument_type;  // If N == 2
  typedef T1 arg1_type;           
  typedef T2 arg2_type;           
     \&.
     \&.
     \&.
  typedef TN argN_type;           

  // static constants
  static const int arity = N;

  // member classes/structs/unions

  // Lambda library support
  template<typename Args> 
  struct sig {
    // types
    typedef result_type type;
  };

  // construct/copy/destruct
  function();
  function(const functionN&);
  function(functionN&&);
  function(const function&);
  function(function&&);
  template<typename F> function(F);
  template<typename F, typename Allocator> function(F, Allocator);
  function& operator=(const functionN&);
  function& operator=(functionN&&);
  function& operator=(const function&);
  function& operator=(function&&);
  ~function();

  // modifiers
  void swap(const function&);
  void clear();

  // capacity
  bool empty() const;
  operator safe_bool() const;
  bool operator!() const;

  // target access
  template<typename Functor> Functor* target();
  template<typename Functor> const Functor* target() const;
  template<typename Functor> bool contains(const Functor&) const;
  const std::type_info& target_type() const;

  // invocation
  result_type operator()(arg1_type, arg2_type, \&.\&.\&., argN_type) const;
};

// specialized algorithms
template<typename Signature> 
  void swap(function<Signature>&, function<Signature>&);

// comparison operators
template<typename Signature, typename Functor> 
  bool operator==(const function<Signature>&, Functor);
template<typename Signature, typename Functor> 
  bool operator==(Functor, const function<Signature>&);
template<typename Signature, typename Functor> 
  bool operator==(const function<Signature>&, reference_wrapper<Functor>);
template<typename Signature, typename Functor> 
  bool operator==(reference_wrapper<Functor>, const function<Signature>&);
template<typename Signature1, typename Signature2> 
  void operator==(const function<Signature1>&, const function<Signature2>&);
template<typename Signature, typename Functor> 
  bool operator!=(const function<Signature>&, Functor);
template<typename Signature, typename Functor> 
  bool operator!=(Functor, const function<Signature>&);
template<typename Signature, typename Functor> 
  bool operator!=(const function<Signature>&, reference_wrapper<Functor>);
template<typename Signature, typename Functor> 
  bool operator!=(reference_wrapper<Functor>, const function<Signature>&);
template<typename Signature1, typename Signature2> 
  void operator!=(const function<Signature1>&, const function<Signature2>&);
.fi
.SH "DESCRIPTION"
.PP
Class template
function
is a thin wrapper around the numbered class templates
function0,
function1, etc\&. It accepts a function type with N arguments and will will derive from
functionN
instantiated with the arguments it receives\&.
.PP
The semantics of all operations in class template
function
are equivalent to that of the underlying
functionN
object, although additional member functions are required to allow proper copy construction and copy assignment of function objects\&.
.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Signature
.fi

.sp

.RE

.SS "function public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
function();
.fi

.PP
Postconditions:
.RS 4
this\->empty()
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
function(const functionN& f);
.fi

.PP
Postconditions:
.RS 4
Contains a copy of the
f\'s target, if it has one, or is empty if
f\&.empty()\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
function(functionN&& f);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Postconditions:
.RS 4
Moves the value from
f
to
*this\&. If the argument has its function object allocated on the heap, its buffer will be assigned to
*this
leaving argument empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless argument has its function object allocated not on the heap and copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
function(const function& f);
.fi

.PP
Postconditions:
.RS 4
Contains a copy of the
f\'s target, if it has one, or is empty if
f\&.empty()\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
function(function&& f);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Postconditions:
.RS 4
Moves the value from
f
to
*this\&. If the argument has its function object allocated on the heap, its buffer will be assigned to
*this
leaving argument empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless argument has its function object allocated not on the heap and copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename F> function(F f);
.fi

.PP
Requires:
.RS 4
F is a function object Callable from
this\&.
.RE
.PP
Postconditions:
.RS 4
*this
targets a copy of
f
if
f
is nonempty, or
this\->empty()
if
f
is empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename F, typename Allocator> function(F f, Allocator alloc);
.fi

.PP
Requires:
.RS 4
F is a function object Callable from
this, Allocator is an allocator\&. The copy constructor and destructor of Allocator shall not throw\&.
.RE
.PP
Postconditions:
.RS 4
*this
targets a copy of
f
if
f
is nonempty, or
this\->empty()
if
f
is empty\&.
.RE
.PP
Effects:
.RS 4
If memory allocation is required, the given allocator (or a copy of it) will be used to allocate that memory\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
function& operator=(const functionN& f);
.fi

.PP
Postconditions:
.RS 4
If copy construction does not throw,
*this
targets a copy of
f\'s target, if it has one, or is empty if
f\&.empty()\&. If copy construction does throw,
this\->empty()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
function& operator=(functionN&& f);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Postconditions:
.RS 4
Moves the value from
f
to
*this\&. If the argument has its function object allocated on the heap, its buffer will be assigned to
*this
leaving argument empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless argument has its function object allocated not on the heap and copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
function& operator=(const function& f);
.fi

.PP
Postconditions:
.RS 4
If copy construction of the target of
f
does not throw,
*this
targets a copy of
f\'s target, if it has one, or is empty if
f\&.empty()\&.
.RE
.PP
Throws:
.RS 4
Will not throw when the target of
f
is a stateless function object or a reference to the function object\&. If copy construction does throw,
this\->empty()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
function& operator=(function&& f);
.fi

.PP
Requires:
.RS 4
C++11 compatible compiler\&.
.RE
.PP
Postconditions:
.RS 4
Moves the value from
f
to
*this\&. If the argument has its function object allocated on the heap, its buffer will be assigned to
*this
leaving argument empty\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless argument has its function object allocated not on the heap and copying the target of
f
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
~function();
.fi

.PP
Effects:
.RS 4
If
!this\->empty(), destroys the target of
this\&.
.RE
.RE

.SS "function modifiers"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void swap(const function& f);
.fi

.PP
Effects:
.RS 4
Interchanges the targets of
*this
and
f\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void clear();
.fi

.PP
Postconditions:
.RS 4
this\->empty()
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "function capacity"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.PP
Returns:
.RS 4
false
if
this
has a target, and
true
otherwise\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
operator safe_bool() const;
.fi

.PP
Returns:
.RS 4
A
safe_bool
that evaluates
false
in a boolean context when
this\->empty(), and
true
otherwise\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool operator!() const;
.fi

.PP
Returns:
.RS 4
this\->empty()
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "function target access"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Functor> Functor* target();
template<typename Functor> const Functor* target() const;
.fi

.PP
Returns:
.RS 4
If
this
stores a target of type
Functor, returns the address of the target\&. Otherwise, returns the NULL pointer\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Functor> bool contains(const Functor& f) const;
.fi

.PP
Returns:
.RS 4
true
if
this\->target<Functor>()
is non\-NULL and
function_equal(*(this\->target<Functor>()), f)
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
const std::type_info& target_type() const;
.fi

.PP
Returns:
.RS 4
typeid
of the target function object, or
typeid(void)
if
this\->empty()\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "function invocation"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
result_type operator()(arg1_type a1, arg2_type a2, \&.\&.\&., argN_type aN) const;
.fi

.PP
Effects:
.RS 4
f(a1, a2, \&.\&.\&., aN), where
f
is the target of
*this\&.
.RE
.PP
Returns:
.RS 4
if
R
is
void, nothing is returned; otherwise, the return value of the call to
f
is returned\&.
.RE
.PP
Throws:
.RS 4
bad_function_call
if
this\->empty()\&. Otherwise, may through any exception thrown by the target function
f\&.
.RE
.RE

.SS "function specialized algorithms"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Signature> 
  void swap(function<Signature>& f1, function<Signature>& f2);
.fi

.PP
Effects:
.RS 4
f1\&.swap(f2)
.RE
.RE

.SS "function comparison operators"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Signature, typename Functor> 
  bool operator==(const function<Signature>& f, Functor g);
template<typename Signature, typename Functor> 
  bool operator==(Functor g, const function<Signature>& f);
template<typename Signature, typename Functor> 
  bool operator==(const function<Signature>& f, reference_wrapper<Functor> g);
template<typename Signature, typename Functor> 
  bool operator==(reference_wrapper<Functor> g, const function<Signature>& f);
template<typename Signature1, typename Signature2> 
  void operator==(const function<Signature1>& f1, 
                  const function<Signature2>& f2);
.fi

.PP
Returns:
.RS 4
True when
f
stores an object of type
Functor
and one of the following conditions applies:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is of type
reference_wrapper<Functor>
and
f\&.target<Functor>() == g\&.get_pointer()\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is not of type
reference_wrapper<Functor>
and
function_equals(*(f\&.target<Functor>()), g)\&.
.RE
.RS 4

.RE
.PP
Notes:
.RS 4
function
objects are not EqualityComparable\&.
.RE
.PP
Rationale:
.RS 4
The
safe_bool
conversion opens a loophole whereby two
function
instances can be compared via
==, although this is not feasible to implement\&. The undefined
void operator==
closes the loophole and ensures a compile\-time or link\-time error\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Signature, typename Functor> 
  bool operator!=(const function<Signature>& f, Functor g);
template<typename Signature, typename Functor> 
  bool operator!=(Functor g, const function<Signature>& f);
template<typename Signature, typename Functor> 
  bool operator!=(const function<Signature>& f, reference_wrapper<Functor> g);
template<typename Signature, typename Functor> 
  bool operator!=(reference_wrapper<Functor> g, const function<Signature>& f);
template<typename Signature1, typename Signature2> 
  void operator!=(const function<Signature1>& f1, 
                  const function<Signature2>& f2);
.fi

.PP
Returns:
.RS 4
True when
f
does not store an object of type
Functor
or it stores an object of type
Functor
and one of the following conditions applies:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is of type
reference_wrapper<Functor>
and
f\&.target<Functor>() != g\&.get_pointer()\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
g
is not of type
reference_wrapper<Functor>
and
!function_equals(*(f\&.target<Functor>()), g)\&.
.RE
.RS 4

.RE
.PP
Notes:
.RS 4
function
objects are not EqualityComparable\&.
.RE
.PP
Rationale:
.RS 4
The
safe_bool
conversion opens a loophole whereby two
function
instances can be compared via
!=, although this is not feasible to implement\&. The undefined
void operator!=
closes the loophole and ensures a compile\-time or link\-time error\&.
.RE
.RE


