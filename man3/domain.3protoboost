.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE D" 3 "" "" ""
.SH "NAME"
boost::proto::domain \- For use in defining domain tags to be used with proto::extends<>, BOOST_PROTO_EXTENDS() and BOOST_PROTO_DEFINE_OPERATORS()\&. A \fIdomain\fR associates an expression type with a \fIgenerator\fR, and optionally a \fIgrammar\fR\&. It may also have a super\-domain\&. Expressions in a sub\-domain are interoperable (i\&.e\&. can be combined freely with) expressions in a super\-domain\&. Finally, domains control how non\-Proto objects are turned into Proto expressions and how they are combined to form larger Proto expressions\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/domain\&.hpp>

template<typename Generator = proto::default_generator, 
         typename Grammar = proto::_, typename Super = \fIunspecified\fR> 
struct domain :  Generator {
  // types
  typedef Grammar   proto_grammar;     
  typedef Generator proto_generator;   
  typedef Super     proto_super_domain;

  // member classes/structs/unions

  // A callable unary MonomorphicFunctionObject that specifies how objects are
  // turned into Proto expressions in this domain\&. The resulting expression
  // object is suitable for storage in a local variable\&.
  template<typename T> 
  struct as_expr :  proto::callable {
    // types
    typedef \fIsee\fR\fI\-\fR\fIbelow\fR result_type;

    // public member functions
    result_type operator()(T &) const;
  };

  // A callable unary MonomorphicFunctionObject that specifies how objects are
  // turned into Proto expressions in this domain, for use in scenarios where
  // the resulting expression is intended to be made a child of another
  // expression\&.
  template<typename T> 
  struct as_child :  proto::callable {
    // types
    typedef \fIsee\fR\fI\-\fR\fIbelow\fR result_type;

    // public member functions
    result_type operator()(T &) const;
  };
};
.fi
.SH "DESCRIPTION"
.PP
The Generator parameter determines how new expressions in the domain are post\-processed\&. Typically, a generator wraps all new expressions in a wrapper that imparts domain\-specific behaviors to expressions within its domain\&. (See
proto::extends<>\&.)
.PP
The Grammar parameter determines whether a given expression is valid within the domain, and automatically disables any operator overloads which would cause an invalid expression to be created\&. By default, the Grammar parameter defaults to the wildcard,
proto::_, which makes all expressions valid within the domain\&.
.PP
The Super parameter declares the domain currently being defined to be a sub\-domain of Super\&. An expression in a sub\-domain can be freely combined with expressions in its super\-domain (and
\fIits\fR
super\-domain, etc\&.)\&.
.PP
Example:

.sp
.if n \{\
.RS 4
.\}
.nf
 template<typename Expr>
 struct MyExpr;

 struct MyGrammar
   : proto::or_< proto::terminal<_>, proto::plus<MyGrammar, MyGrammar> >
 {};

 // Define MyDomain, in which all expressions are
 // wrapped in MyExpr<> and only expressions that
 // conform to MyGrammar are allowed\&.
 struct MyDomain
   : proto::domain<proto::generator<MyExpr>, MyGrammar>
 {};

 // Use MyDomain to define MyExpr
 template<typename Expr>
 struct MyExpr
   : proto::extends<Expr, MyExpr<Expr>, MyDomain>
 {
     // \&.\&.\&.
 };
            
.fi
.if n \{\
.RE
.\}
.sp

.PP
The
domain::as_expr<>
and
domain::as_child<>
member templates define how non\-Proto objects are turned into Proto terminals and how Proto expressions should be processed before they are combined to form larger expressions\&. They can be overridden in a derived domain for customization\&. See their descriptions to understand how Proto uses these two templates and what their default behavior is\&.

