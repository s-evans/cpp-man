.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS INTERP" 3 "" "" ""
.SH "NAME"
boost::interprocess::interprocess_sharable_mutex
.SH "SYNOPSIS"
.\" unlock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: unlock_sharable
.\" unlock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: unlock
.\" try_lock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: try_lock_sharable
.\" try_lock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: try_lock
.\" timed_lock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: timed_lock_sharable
.\" timed_lock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: timed_lock
.\" lock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: lock_sharable
.\" lock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: lock
.\" interprocess_sharable_mutex: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: interprocess_sharable_mutex
.\" interprocess_sharable_mutex: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: interprocess_sharable_mutex

.sp
.nf
// In header: <boost/interprocess/sync/interprocess_sharable_mutex\&.hpp>


class interprocess_sharable_mutex {
public:
  // construct/copy/destruct
  interprocess_sharable_mutex(const interprocess_sharable_mutex &);
  interprocess_sharable_mutex();
  interprocess_sharable_mutex & operator=(const interprocess_sharable_mutex &);
  ~interprocess_sharable_mutex();

  // public member functions
  void lock();
  bool try_lock();
  bool timed_lock(const boost::posix_time::ptime &);
  void unlock();
  void lock_sharable();
  bool try_lock_sharable();
  bool timed_lock_sharable(const boost::posix_time::ptime &);
  void unlock_sharable();
};
.fi
.SH "DESCRIPTION"
.PP
Wraps a
interprocess_sharable_mutex
that can be placed in shared memory and can be shared between processes\&. Allows timed lock tries
.SS "interprocess_sharable_mutex public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
interprocess_sharable_mutex(const interprocess_sharable_mutex &);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
interprocess_sharable_mutex();
.fi

.sp
Constructs the sharable lock\&. Throws
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
interprocess_sharable_mutex & operator=(const interprocess_sharable_mutex &);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
~interprocess_sharable_mutex();
.fi

.sp
Destroys the sharable lock\&. Does not throw\&.
.RE

.SS "interprocess_sharable_mutex public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" lock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: lock

.sp

.nf
void lock();
.fi

.sp
Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive or sharable ownership of the mutex, it waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" try_lock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: try_lock

.sp

.nf
bool try_lock();
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting\&. If no other thread has exclusive or sharable ownership of the mutex this succeeds\&. Returns: If it can acquire exclusive ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" timed_lock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: timed_lock

.sp

.nf
bool timed_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive or sharable ownership of the mutex or abs_time is reached\&. Returns: If acquires exclusive ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlock: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: unlock

.sp

.nf
void unlock();
.fi

.sp
Precondition: The thread must have exclusive ownership of the mutex\&. Effects: The calling thread releases the exclusive ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" lock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: lock_sharable

.sp

.nf
void lock_sharable();
.fi

.sp
Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" try_lock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: try_lock_sharable

.sp

.nf
bool try_lock_sharable();
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting\&. If no other thread has exclusive ownership of the mutex this succeeds\&. Returns: If it can acquire sharable ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" timed_lock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: timed_lock_sharable

.sp

.nf
bool timed_lock_sharable(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached\&. Returns: If acquires sharable ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" unlock_sharable: Class interprocess_sharable_mutex
.\" Class interprocess_sharable_mutex: unlock_sharable

.sp

.nf
void unlock_sharable();
.fi

.sp
Precondition: The thread must have sharable ownership of the mutex\&. Effects: The calling thread releases the sharable ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


