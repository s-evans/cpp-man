.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE T" 3 "" "" ""
.SH "NAME"
boost::intrusive::treap_set
.SH "SYNOPSIS"
.\" value_type: Class template treap_set
.\" Class template treap_set: value_type
.\" value_traits: Class template treap_set
.\" Class template treap_set: value_traits
.\" value_compare: Class template treap_set
.\" Class template treap_set: value_compare
.\" upper_bound: Class template treap_set
.\" Class template treap_set: upper_bound
.\" unlink_leftmost_without_rebalance: Class template treap_set
.\" Class template treap_set: unlink_leftmost_without_rebalance
.\" top: Class template treap_set
.\" Class template treap_set: top
.\" swap: Class template treap_set
.\" Class template treap_set: swap
.\" size_type: Class template treap_set
.\" Class template treap_set: size_type
.\" size: Class template treap_set
.\" Class template treap_set: size
.\" s_iterator_to: Class template treap_set
.\" Class template treap_set: s_iterator_to
.\" rtop: Class template treap_set
.\" Class template treap_set: rtop
.\" reverse_iterator: Class template treap_set
.\" Class template treap_set: reverse_iterator
.\" replace_node: Class template treap_set
.\" Class template treap_set: replace_node
.\" rend: Class template treap_set
.\" Class template treap_set: rend
.\" remove_node: Class template treap_set
.\" Class template treap_set: remove_node
.\" reference: Class template treap_set
.\" Class template treap_set: reference
.\" rbegin: Class template treap_set
.\" Class template treap_set: rbegin
.\" push_front: Class template treap_set
.\" Class template treap_set: push_front
.\" push_back: Class template treap_set
.\" Class template treap_set: push_back
.\" priority_compare: Class template treap_set
.\" Class template treap_set: priority_compare
.\" pointer: Class template treap_set
.\" Class template treap_set: pointer
.\" node_traits: Class template treap_set
.\" Class template treap_set: node_traits
.\" node_ptr: Class template treap_set
.\" Class template treap_set: node_ptr
.\" node_algorithms: Class template treap_set
.\" Class template treap_set: node_algorithms
.\" node: Class template treap_set
.\" Class template treap_set: node
.\" lower_bound: Class template treap_set
.\" Class template treap_set: lower_bound
.\" key_type: Class template treap_set
.\" Class template treap_set: key_type
.\" key_of_value: Class template treap_set
.\" Class template treap_set: key_of_value
.\" key_compare: Class template treap_set
.\" Class template treap_set: key_compare
.\" iterator_to: Class template treap_set
.\" Class template treap_set: iterator_to
.\" iterator: Class template treap_set
.\" Class template treap_set: iterator
.\" insert_commit_data: Class template treap_set
.\" Class template treap_set: insert_commit_data
.\" insert_commit: Class template treap_set
.\" Class template treap_set: insert_commit
.\" insert_before: Class template treap_set
.\" Class template treap_set: insert_before
.\" insert: Class template treap_set
.\" Class template treap_set: insert
.\" init_node: Class template treap_set
.\" Class template treap_set: init_node
.\" find: Class template treap_set
.\" Class template treap_set: find
.\" erase_and_dispose: Class template treap_set
.\" Class template treap_set: erase_and_dispose
.\" erase: Class template treap_set
.\" Class template treap_set: erase
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" difference_type: Class template treap_set
.\" Class template treap_set: difference_type
.\" count: Class template treap_set
.\" Class template treap_set: count
.\" container_from_iterator: Class template treap_set
.\" Class template treap_set: container_from_iterator
.\" container_from_end_iterator: Class template treap_set
.\" Class template treap_set: container_from_end_iterator
.\" const_reverse_iterator: Class template treap_set
.\" Class template treap_set: const_reverse_iterator
.\" const_reference: Class template treap_set
.\" Class template treap_set: const_reference
.\" const_pointer: Class template treap_set
.\" Class template treap_set: const_pointer
.\" const_node_ptr: Class template treap_set
.\" Class template treap_set: const_node_ptr
.\" const_iterator: Class template treap_set
.\" Class template treap_set: const_iterator
.\" clone_from: Class template treap_set
.\" Class template treap_set: clone_from
.\" clear_and_dispose: Class template treap_set
.\" Class template treap_set: clear_and_dispose
.\" clear: Class template treap_set
.\" Class template treap_set: clear
.\" cend: Class template treap_set
.\" Class template treap_set: cend
.\" cbegin: Class template treap_set
.\" Class template treap_set: cbegin
.\" bounded_range: Class template treap_set
.\" Class template treap_set: bounded_range
.\" begin: Class template treap_set
.\" Class template treap_set: begin

.sp
.nf
// In header: <boost/intrusive/treap_set\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class treap_set {
public:
  // types
  typedef implementation_defined::value_type             value_type;            
  typedef implementation_defined::value_traits           value_traits;          
  typedef implementation_defined::key_type               key_type;              
  typedef implementation_defined::key_of_value           key_of_value;          
  typedef implementation_defined::pointer                pointer;               
  typedef implementation_defined::const_pointer          const_pointer;         
  typedef implementation_defined::reference              reference;             
  typedef implementation_defined::const_reference        const_reference;       
  typedef implementation_defined::difference_type        difference_type;       
  typedef implementation_defined::size_type              size_type;             
  typedef implementation_defined::value_compare          value_compare;         
  typedef implementation_defined::key_compare            key_compare;           
  typedef implementation_defined::priority_compare       priority_compare;      
  typedef implementation_defined::iterator               iterator;              
  typedef implementation_defined::const_iterator         const_iterator;        
  typedef implementation_defined::reverse_iterator       reverse_iterator;      
  typedef implementation_defined::const_reverse_iterator const_reverse_iterator;
  typedef implementation_defined::insert_commit_data     insert_commit_data;    
  typedef implementation_defined::node_traits            node_traits;           
  typedef implementation_defined::node                   node;                  
  typedef implementation_defined::node_ptr               node_ptr;              
  typedef implementation_defined::const_node_ptr         const_node_ptr;        
  typedef implementation_defined::node_algorithms        node_algorithms;       

  // construct/copy/destruct
  explicit treap_set(const key_compare & = key_compare(), 
                     const priority_compare & = priority_compare(), 
                     const value_traits & = value_traits());
  template<typename Iterator> 
    treap_set(Iterator, Iterator, const key_compare & = key_compare(), 
              const priority_compare & = priority_compare(), 
              const value_traits & = value_traits());
  treap_set(treap_set &&);
  treap_set & operator=(treap_set &&);
  ~treap_set();

  // public member functions
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  reverse_iterator rbegin();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator crbegin() const;
  reverse_iterator rend();
  const_reverse_iterator rend() const;
  const_reverse_iterator crend() const;
  key_compare key_comp() const;
  value_compare value_comp() const;
  bool empty() const;
  size_type size() const;
  void swap(treap_set &);
  template<typename Cloner, typename Disposer> 
    void clone_from(const treap_set &, Cloner, Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(treap_set &&, Cloner, Disposer);
  iterator top();
  const_iterator top() const;
  const_iterator ctop() const;
  reverse_iterator rtop();
  const_reverse_iterator rtop() const;
  const_reverse_iterator crtop() const;
  priority_compare priority_comp() const;
  std::pair< iterator, bool > insert(reference);
  iterator insert(const_iterator, reference);
  template<typename KeyType, typename KeyTypeKeyCompare, 
           typename KeyValuePrioCompare> 
    std::pair< iterator, bool > 
    insert_check(const KeyType &, KeyTypeKeyCompare, KeyValuePrioCompare, 
                 insert_commit_data &);
  template<typename KeyType, typename KeyTypeKeyCompare, 
           typename KeyValuePrioCompare> 
    std::pair< iterator, bool > 
    insert_check(const_iterator, const KeyType &, KeyTypeKeyCompare, 
                 KeyValuePrioCompare, insert_commit_data &);
  template<typename Iterator> void insert(Iterator, Iterator);
  iterator insert_commit(reference, const insert_commit_data &);
  iterator insert_before(const_iterator, reference);
  void push_back(reference);
  void push_front(reference);
  iterator erase(const_iterator);
  iterator erase(const_iterator, const_iterator);
  size_type erase(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    size_type erase(const KeyType &, KeyTypeKeyCompare);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, const_iterator, Disposer);
  template<typename Disposer> 
    size_type erase_and_dispose(const key_type &, Disposer);
  template<typename KeyType, typename KeyTypeKeyCompare, typename Disposer> 
    size_type erase_and_dispose(const KeyType &, KeyTypeKeyCompare, Disposer);
  void clear();
  template<typename Disposer> void clear_and_dispose(Disposer);
  size_type count(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    size_type count(const KeyType &, KeyTypeKeyCompare) const;
  iterator lower_bound(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator lower_bound(const KeyType &, KeyTypeKeyCompare);
  const_iterator lower_bound(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator lower_bound(const KeyType &, KeyTypeKeyCompare) const;
  iterator upper_bound(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator upper_bound(const KeyType &, KeyTypeKeyCompare);
  const_iterator upper_bound(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator upper_bound(const KeyType &, KeyTypeKeyCompare) const;
  iterator find(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator find(const KeyType &, KeyTypeKeyCompare);
  const_iterator find(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator find(const KeyType &, KeyTypeKeyCompare) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, iterator > 
    equal_range(const KeyType &, KeyTypeKeyCompare);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< const_iterator, const_iterator > 
    equal_range(const KeyType &, KeyTypeKeyCompare) const;
  std::pair< iterator, iterator > 
  bounded_range(const key_type &, const key_type &, bool, bool);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, iterator > 
    bounded_range(const KeyType &, const KeyType &, KeyTypeKeyCompare, bool, 
                  bool);
  std::pair< const_iterator, const_iterator > 
  bounded_range(const key_type &, const key_type &, bool, bool) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< const_iterator, const_iterator > 
    bounded_range(const KeyType &, const KeyType &, KeyTypeKeyCompare, bool, 
                  bool) const;
  iterator iterator_to(reference);
  const_iterator iterator_to(const_reference) const;
  pointer unlink_leftmost_without_rebalance();
  void replace_node(iterator, reference);
  void remove_node(reference);

  // public static functions
  static treap_set & container_from_end_iterator(iterator);
  static const treap_set & container_from_end_iterator(const_iterator);
  static treap_set & container_from_iterator(iterator);
  static const treap_set & container_from_iterator(const_iterator);
  static iterator s_iterator_to(reference);
  static const_iterator s_iterator_to(const_reference);
  static void init_node(reference);

  // public data members
  static const bool constant_time_size;
};
.fi
.SH "DESCRIPTION"
.PP
The class template
treap_set
is an intrusive container, that mimics most of the interface of std::set as described in the C++ standard\&.
.PP
The template parameter
T
is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
base_hook<>/member_hook<>/value_traits<>,
constant_time_size<>,
size_type<>,
compare<>
and
priority_compare<>
.SS "treap_set public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit treap_set(const key_compare & cmp = key_compare(), 
                   const priority_compare & pcmp = priority_compare(), 
                   const value_traits & v_traits = value_traits());
.fi

.sp
\fBEffects\fR: Constructs an empty
treap_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor of the key_compare object throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" distance: Class template treap_set
.\" Class template treap_set: distance

.sp

.nf
template<typename Iterator> 
  treap_set(Iterator b, Iterator e, const key_compare & cmp = key_compare(), 
            const priority_compare & pcmp = priority_compare(), 
            const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&. cmp must be a comparison function that induces a strict weak ordering\&.
.sp
\fBEffects\fR: Constructs an empty
treap_set
and inserts elements from [b, e)\&.
.sp
\fBComplexity\fR: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is distance(last, first)\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
treap_set(treap_set && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
treap_set & operator=(treap_set && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~treap_set();
.fi

.sp
\fBEffects\fR: Detaches all elements from this\&. The objects in the set are not deleted (i\&.e\&. no destructors are called), but the nodes according to the
value_traits
template parameter are reinitialized and thus can be reused\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this\&.
.sp
\fBThrows\fR: Nothing\&.
.RE

.SS "treap_set public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" begin: Class template treap_set
.\" Class template treap_set: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" begin: Class template treap_set
.\" Class template treap_set: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" cbegin: Class template treap_set
.\" Class template treap_set: cbegin

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" cend: Class template treap_set
.\" Class template treap_set: cend

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" rbegin: Class template treap_set
.\" Class template treap_set: rbegin

.sp

.nf
reverse_iterator rbegin();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" rbegin: Class template treap_set
.\" Class template treap_set: rbegin

.sp

.nf
const_reverse_iterator rbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rend: Class template treap_set
.\" Class template treap_set: rend

.sp

.nf
reverse_iterator rend();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rend: Class template treap_set
.\" Class template treap_set: rend

.sp

.nf
const_reverse_iterator rend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the key_compare object used by the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If key_compare copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns the value_compare object used by the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_compare copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container is empty\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" size: Class template treap_set
.\" Class template treap_set: size

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of elements stored in the container\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this if constant\-time size option is disabled\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" swap: Class template treap_set
.\" Class template treap_set: swap

.sp

.nf
void swap(treap_set & other);
.fi

.sp
\fBEffects\fR: Swaps the contents of two treaps\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the comparison functor\'s swap call throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" clone_from: Class template treap_set
.\" Class template treap_set: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(const treap_set & src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this\&. Copies the predicate from the source container\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws or predicate copy assignment throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" clone_from: Class template treap_set
.\" Class template treap_set: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(treap_set && src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this\&. Copies the predicate from the source container\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws or predicate copy assignment throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" top: Class template treap_set
.\" Class template treap_set: top

.sp

.nf
iterator top();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the highest priority object of the treap\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" top: Class template treap_set
.\" Class template treap_set: top

.sp

.nf
const_iterator top() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the highest priority object of the treap\&.\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
const_iterator ctop() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the highest priority object of the treap\&.\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" rtop: Class template treap_set
.\" Class template treap_set: rtop

.sp

.nf
reverse_iterator rtop();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the highest priority object of the reversed treap\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" rtop: Class template treap_set
.\" Class template treap_set: rtop

.sp

.nf
const_reverse_iterator rtop() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the highest priority objec of the reversed treap\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
const_reverse_iterator crtop() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the highest priority object of the reversed treap\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
priority_compare priority_comp() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the highest priority object of the reversed treap\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" insert: Class template treap_set
.\" Class template treap_set: insert

.sp

.nf
std::pair< iterator, bool > insert(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue
.sp
\fBEffects\fR: Inserts value into the container if the value is not already present\&.
.sp
\fBComplexity\fR: Average complexity for insert element is at most logarithmic\&.
.sp
\fBThrows\fR: If the internal key_compare or priority_compare functions throw\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" insert: Class template treap_set
.\" Class template treap_set: insert

.sp

.nf
iterator insert(const_iterator hint, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and "hint" must be a valid iterator
.sp
\fBEffects\fR: Tries to insert x into the container, using "hint" as a hint to where it will be inserted\&.
.sp
\fBComplexity\fR: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint\&.
.sp
\fBThrows\fR: If the internal key_compare or priority_compare functions throw\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare, 
         typename KeyValuePrioCompare> 
  std::pair< iterator, bool > 
  insert_check(const KeyType & key, KeyTypeKeyCompare comp, 
               KeyValuePrioCompare key_value_pcomp, 
               insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: comp must be a comparison function that induces the same strict weak ordering as key_compare\&. key_value_pcomp must be a comparison function that induces the same strict weak ordering as priority_compare\&. The difference is that key_value_pcomp and comp compare an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Checks if a value can be inserted in the container, using a user provided key instead of the value itself\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing an iterator to the already present value and false\&. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function\&.
.sp
\fBComplexity\fR: Average complexity is at most logarithmic\&.
.sp
\fBThrows\fR: If the comp or key_value_pcomp ordering functions throw\&. Strong guarantee\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant\-time\&. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1))\&.
.sp
"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare, 
         typename KeyValuePrioCompare> 
  std::pair< iterator, bool > 
  insert_check(const_iterator hint, const KeyType & key, 
               KeyTypeKeyCompare comp, KeyValuePrioCompare key_value_pcomp, 
               insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: comp must be a comparison function that induces the same strict weak ordering as key_compare\&. key_value_pcomp must be a comparison function that induces the same strict weak ordering as priority_compare\&. The difference is that key_value_pcomp and comp compare an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing an iterator to the already present value and false\&. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function\&.
.sp
\fBComplexity\fR: Logarithmic in general, but it\'s amortized constant time if t is inserted immediately before hint\&.
.sp
\fBThrows\fR: If the comp or key_value_pcomp ordering functions throw\&. Strong guarantee\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant\-time\&. This can give a total constant\-time complexity to the insertion: check(O(1)) + commit(O(1))\&.
.sp
"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" insert: Class template treap_set
.\" Class template treap_set: insert

.sp

.nf
template<typename Iterator> void insert(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Tries to insert each element of a range into the container\&.
.sp
\fBComplexity\fR: Insert range is in general O(N * log(N)), where N is the size of the range\&. However, it is linear in N if the range is already sorted by key_comp()\&.
.sp
\fBThrows\fR: If the internal key_compare or priority_compare functions throw\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" insert_commit: Class template treap_set
.\" Class template treap_set: insert_commit

.sp

.nf
iterator insert_commit(reference value, 
                       const insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: value must be an lvalue of type value_type\&. commit_data must have been obtained from a previous call to "insert_check"\&. No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit"\&.
.sp
\fBEffects\fR: Inserts the value in the
avl_set
using the information obtained from the "commit_data" that a previous "insert_check" filled\&.
.sp
\fBReturns\fR: An iterator to the newly inserted object\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBNotes\fR: This function has only sense if a "insert_check" has been previously executed to fill "commit_data"\&. No value should be inserted or erased between the "insert_check" and "insert_commit" calls\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" insert_before: Class template treap_set
.\" Class template treap_set: insert_before

.sp

.nf
iterator insert_before(const_iterator pos, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate
.sp
\fBEffects\fR: Inserts x into the container before "pos"\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: If the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" push_back: Class template treap_set
.\" Class template treap_set: push_back

.sp

.nf
void push_back(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and it must be no less than the greatest inserted key
.sp
\fBEffects\fR: Inserts x into the container in the last position\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: If the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken\&. This function is slightly more efficient than using "insert_before"\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" push_front: Class template treap_set
.\" Class template treap_set: push_front

.sp

.nf
void push_front(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and it must be no greater than the minimum inserted key
.sp
\fBEffects\fR: Inserts x into the container in the first position\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: If the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken\&. This function is slightly more efficient than using "insert_before"\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" erase: Class template treap_set
.\" Class template treap_set: erase

.sp

.nf
iterator erase(const_iterator i);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by i\&.
.sp
\fBComplexity\fR: Average complexity for erase element is constant time\&.
.sp
\fBThrows\fR: if the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" erase: Class template treap_set
.\" Class template treap_set: erase

.sp

.nf
iterator erase(const_iterator b, const_iterator e);
.fi

.sp
\fBEffects\fR: Erases the range pointed to by b end e\&.
.sp
\fBComplexity\fR: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range\&.
.sp
\fBThrows\fR: if the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" erase: Class template treap_set
.\" Class template treap_set: erase

.sp

.nf
size_type erase(const key_type & key);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given value\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: if the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" while: Class template treap_set
.\" Class template treap_set: while
.\" erase: Class template treap_set
.\" Class template treap_set: erase

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  size_type erase(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "comp"\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: if the internal priority_compare function throws\&. Equivalent guarantee to
\fIwhile(beg != end) erase(beg++);\fR
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" erase_and_dispose: Class template treap_set
.\" Class template treap_set: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator i, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element pointed to by i\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBComplexity\fR: Average complexity for erase element is constant time\&.
.sp
\fBThrows\fR: if the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" erase_and_dispose: Class template treap_set
.\" Class template treap_set: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator b, const_iterator e, 
                             Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the range pointed to by b end e\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBComplexity\fR: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range\&.
.sp
\fBThrows\fR: if the internal priority_compare function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" erase_and_dispose: Class template treap_set
.\" Class template treap_set: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  size_type erase_and_dispose(const key_type & key, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given value\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: if the priority_compare function throws then weak guarantee and heap invariants are broken\&. The safest thing would be to clear or destroy the container\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" erase_and_dispose: Class template treap_set
.\" Class template treap_set: erase_and_dispose

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare, typename Disposer> 
  size_type erase_and_dispose(const KeyType & key, KeyTypeKeyCompare comp, 
                              Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "comp"\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: if the priority_compare function throws then weak guarantee and heap invariants are broken\&. The safest thing would be to clear or destroy the container\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" clear: Class template treap_set
.\" Class template treap_set: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all of the elements\&.
.sp
\fBComplexity\fR: Linear to the number of elements on the container\&. if it\'s a safe\-mode or auto\-unlink value_type\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" clear_and_dispose: Class template treap_set
.\" Class template treap_set: clear_and_dispose

.sp

.nf
template<typename Disposer> void clear_and_dispose(Disposer disposer);
.fi

.sp
\fBEffects\fR: Erases all of the elements calling disposer(p) for each node to be erased\&.
\fBComplexity\fR: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. Calls N times to disposer functor\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" count: Class template treap_set
.\" Class template treap_set: count

.sp

.nf
size_type count(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given value
.sp
\fBComplexity\fR: Logarithmic to the number of elements contained plus lineal to number of objects with the given value\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" count: Class template treap_set
.\" Class template treap_set: count

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  size_type count(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given key
.sp
\fBComplexity\fR: Logarithmic to the number of elements contained plus lineal to number of objects with the given key\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" lower_bound: Class template treap_set
.\" Class template treap_set: lower_bound

.sp

.nf
iterator lower_bound(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" lower_bound: Class template treap_set
.\" Class template treap_set: lower_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator lower_bound(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" lower_bound: Class template treap_set
.\" Class template treap_set: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" lower_bound: Class template treap_set
.\" Class template treap_set: lower_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator 
  lower_bound(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" upper_bound: Class template treap_set
.\" Class template treap_set: upper_bound

.sp

.nf
iterator upper_bound(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" upper_bound: Class template treap_set
.\" Class template treap_set: upper_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator upper_bound(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" upper_bound: Class template treap_set
.\" Class template treap_set: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" upper_bound: Class template treap_set
.\" Class template treap_set: upper_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator 
  upper_bound(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" find: Class template treap_set
.\" Class template treap_set: find

.sp

.nf
iterator find(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" find: Class template treap_set
.\" Class template treap_set: find

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator find(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" find: Class template treap_set
.\" Class template treap_set: find

.sp

.nf
const_iterator find(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Finds a const_iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" end: Class template treap_set
.\" Class template treap_set: end
.\" find: Class template treap_set
.\" Class template treap_set: find

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator find(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Finds a const_iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, iterator > 
  equal_range(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< const_iterator, const_iterator > 
  equal_range(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}
.\" bounded_range: Class template treap_set
.\" Class template treap_set: bounded_range

.sp

.nf
std::pair< iterator, iterator > 
bounded_range(const key_type & lower_key, const key_type & upper_key, 
              bool left_closed, bool right_closed);
.fi

.sp
\fBRequires\fR: \'lower_key\' must not be greater than \'upper_key\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise
.sp
second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'65.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "65." 4.2
.\}
.\" bounded_range: Class template treap_set
.\" Class template treap_set: bounded_range

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, iterator > 
  bounded_range(const KeyType & lower_key, const KeyType & upper_key, 
                KeyTypeKeyCompare comp, bool left_closed, bool right_closed);
.fi

.sp
\fBRequires\fR: KeyTypeKeyCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the container\&. \'lower_key\' must not be greater than \'upper_key\' according to \'comp\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise
.sp
second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'66.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "66." 4.2
.\}
.\" bounded_range: Class template treap_set
.\" Class template treap_set: bounded_range

.sp

.nf
std::pair< const_iterator, const_iterator > 
bounded_range(const key_type & lower_key, const key_type & upper_key, 
              bool left_closed, bool right_closed) const;
.fi

.sp
\fBRequires\fR: \'lower_key\' must not be greater than \'upper_key\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise
.sp
second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'67.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "67." 4.2
.\}
.\" bounded_range: Class template treap_set
.\" Class template treap_set: bounded_range

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< const_iterator, const_iterator > 
  bounded_range(const KeyType & lower_key, const KeyType & upper_key, 
                KeyTypeKeyCompare comp, bool left_closed, bool right_closed) const;
.fi

.sp
\fBRequires\fR: KeyTypeKeyCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the container\&. \'lower_key\' must not be greater than \'upper_key\' according to \'comp\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise
.sp
second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'68.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "68." 4.2
.\}
.\" iterator_to: Class template treap_set
.\" Class template treap_set: iterator_to

.sp

.nf
iterator iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'69.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "69." 4.2
.\}
.\" iterator_to: Class template treap_set
.\" Class template treap_set: iterator_to

.sp

.nf
const_iterator iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'70.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "70." 4.2
.\}
.\" unlink_leftmost_without_rebalance: Class template treap_set
.\" Class template treap_set: unlink_leftmost_without_rebalance

.sp

.nf
pointer unlink_leftmost_without_rebalance();
.fi

.sp
\fBEffects\fR: Unlinks the leftmost node from the container\&.
.sp
\fBComplexity\fR: Average complexity is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls\&. This function is normally used to achieve a step by step controlled destruction of the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'71.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "71." 4.2
.\}
.\" replace_node: Class template treap_set
.\" Class template treap_set: replace_node

.sp

.nf
void replace_node(iterator replace_this, reference with_this);
.fi

.sp
\fBRequires\fR: replace_this must be a valid iterator of *this and with_this must not be inserted in any container\&.
.sp
\fBEffects\fR: Replaces replace_this in its position in the container with with_this\&. The container does not need to be rebalanced\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules\&. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'72.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "72." 4.2
.\}
.\" remove_node: Class template treap_set
.\" Class template treap_set: remove_node

.sp

.nf
void remove_node(reference value);
.fi

.sp
\fBEffects\fR: removes "value" from the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic time\&.
.sp
\fBNote\fR: This static function is only usable with non\-constant time size containers that have stateless comparison functors\&.
.sp
If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued\&.
.RE

.SS "treap_set public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" container_from_end_iterator: Class template treap_set
.\" Class template treap_set: container_from_end_iterator

.sp

.nf
static treap_set & container_from_end_iterator(iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" container_from_end_iterator: Class template treap_set
.\" Class template treap_set: container_from_end_iterator

.sp

.nf
static const treap_set & 
container_from_end_iterator(const_iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" container_from_iterator: Class template treap_set
.\" Class template treap_set: container_from_iterator

.sp

.nf
static treap_set & container_from_iterator(iterator it);
.fi

.sp
\fBPrecondition\fR: it must be a valid iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" container_from_iterator: Class template treap_set
.\" Class template treap_set: container_from_iterator

.sp

.nf
static const treap_set & container_from_iterator(const_iterator it);
.fi

.sp
\fBPrecondition\fR: it must be a valid iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" s_iterator_to: Class template treap_set
.\" Class template treap_set: s_iterator_to

.sp

.nf
static iterator s_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" s_iterator_to: Class template treap_set
.\" Class template treap_set: s_iterator_to

.sp

.nf
static const_iterator s_iterator_to(const_reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" init_node: Class template treap_set
.\" Class template treap_set: init_node

.sp

.nf
static void init_node(reference value);
.fi

.sp
\fBRequires\fR: value shall not be in a container\&.
.sp
\fBEffects\fR: init_node puts the hook of a value in a well\-known default state\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: This function puts the hook in the well\-known default state used by auto_unlink and safe hooks\&.
.RE


