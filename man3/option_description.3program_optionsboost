.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS OPTION_DES" 3 "" "" ""
.SH "NAME"
boost::program_options::option_description
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/program_options/options_description\&.hpp>


class option_description {
public:

  enum match_result { no_match, full_match, approximate_match };
  // construct/copy/destruct
  option_description();
  option_description(const char *, const value_semantic *);
  option_description(const char *, const value_semantic *, const char *);
  ~option_description();

  // public member functions
  match_result match(const std::string &, bool, bool, bool) const;
  const std::string & key(const std::string &) const;
  std::string canonical_display_name(int = 0) const;
  const std::string & long_name() const;
  const std::string & description() const;
  shared_ptr< const value_semantic > semantic() const;
  std::string format_name() const;
  std::string format_parameter() const;

  // private member functions
  option_description & set_name(const char *);
};
.fi
.SH "DESCRIPTION"
.PP
Describes one possible command line/config file option\&. There are two kinds of properties of an option\&. First describe it syntactically and are used only to validate input\&. Second affect interpretation of the option, for example default value for it or function that should be called when the value is finally known\&. Routines which perform parsing never use second kind of properties \-\- they are side effect free\&.
.PP \fBSee Also:\fR.PP options_description
.SS "option_description public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
option_description();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
option_description(const char * name, const value_semantic * s);
.fi

.sp
Initializes the object with the passed data\&.
.sp
Note: it would be nice to make the second parameter auto_ptr, to explicitly pass ownership\&. Unfortunately, it\'s often needed to create objects of types derived from \'value_semantic\':
options_description
d; d\&.add_options()("a", parameter<int>("n")\->default_value(1)); Here, the static type returned by \'parameter\' should be derived from
value_semantic\&.
.sp
Alas, derived\->base conversion for auto_ptr does not really work, see
\m[blue]\fBhttp://www\&.open\-std\&.org/jtc1/sc22/wg21/docs/papers/2000/n1232\&.pdf\fR\m[]
\m[blue]\fBhttp://www\&.open\-std\&.org/jtc1/sc22/wg21/docs/cwg_defects\&.html#84\fR\m[]
.sp
So, we have to use plain old pointers\&. Besides, users are not expected to use the constructor directly\&.
.sp
The \'name\' parameter is interpreted by the following rules:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
if there\'s no "," character in \'name\', it specifies long name
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
otherwise, the part before "," specifies long name and the part after \-\- short name\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
option_description(const char * name, const value_semantic * s, 
                   const char * description);
.fi

.sp
Initializes the class with the passed data\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
~option_description();
.fi

.RE

.SS "option_description public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
match_result 
match(const std::string & option, bool approx, bool long_ignore_case, 
      bool short_ignore_case) const;
.fi

.sp
Given \'option\', specified in the input source, returns \'true\' if \'option\' specifies *this\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
const std::string & key(const std::string & option) const;
.fi

.sp
Returns the key that should identify the option, in particular in the
variables_map
class\&. The \'option\' parameter is the option spelling from the input source\&. If option name contains \'*\', returns \'option\'\&. If long name was specified, it\'s the long name, otherwise it\'s a short name with prepended \'\-\'\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
std::string canonical_display_name(int canonical_option_style = 0) const;
.fi

.sp
Returns the canonical name for the option description to enable the user to recognised a matching option\&. 1) For short options (\'\-\', \'/\'), returns the short name prefixed\&. 2) For long options (\'<ndash></ndash>\' / \'\-\') returns the long name prefixed 3) All other cases, returns the long name (if present) or the short name, unprefixed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
const std::string & long_name() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
const std::string & description() const;
.fi

Explanation of this option\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
shared_ptr< const value_semantic > semantic() const;
.fi

Semantic of option\'s value\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
std::string format_name() const;
.fi

Returns the option name, formatted suitably for usage message\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
std::string format_parameter() const;
.fi

.sp
Returns the parameter name and properties, formatted suitably for usage message\&.
.RE

.SS "option_description private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
option_description & set_name(const char * name);
.fi

.RE


