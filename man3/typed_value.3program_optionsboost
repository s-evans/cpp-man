.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::program_options::typed_value
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/program_options/value_semantic\&.hpp>

template<typename T, typename charT = char> 
class typed_value : public boost::program_options::value_semantic_codecvt_helper< charT >,
                    public boost::program_options::typed_value_base
{
public:
  // construct/copy/destruct
  typed_value(T *);

  // public member functions
  typed_value * default_value(const T &);
  typed_value * default_value(const T &, const std::string &);
  typed_value * implicit_value(const T &);
  typed_value * value_name(const std::string &);
  typed_value * implicit_value(const T &, const std::string &);
  typed_value * notifier(function1< void, const T & >);
  typed_value * composing();
  typed_value * multitoken();
  typed_value * zero_tokens();
  typed_value * required();
  std::string name() const;
  bool is_composing() const;
  unsigned min_tokens() const;
  unsigned max_tokens() const;
  bool adjacent_tokens_only() const;
  bool is_required() const;
  void xparse(boost::any &, const std::vector< std::basic_string< charT > > &) const;
  virtual bool apply_default(boost::any &) const;
  void notify(const boost::any &) const;
  virtual const std::type_info & value_type() const;
};
.fi
.SH "DESCRIPTION"
.PP
Class which handles value of a specific type\&.
.SS "typed_value public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typed_value(T * store_to);
.fi

.sp
Ctor\&. The \'store_to\' parameter tells where to store the value when it\'s known\&. The parameter can be NULL\&.
.RE

.SS "typed_value public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typed_value * default_value(const T & v);
.fi

.sp
Specifies default value, which will be used if none is explicitly specified\&. The type \'T\' should provide operator<< for ostream\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typed_value * default_value(const T & v, const std::string & textual);
.fi

.sp
Specifies default value, which will be used if none is explicitly specified\&. Unlike the above overload, the type \'T\' need not provide operator<< for ostream, but textual representation of default value must be provided by the user\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typed_value * implicit_value(const T & v);
.fi

.sp
Specifies an implicit value, which will be used if the option is given, but without an adjacent value\&. Using this implies that an explicit value is optional, but if given, must be strictly adjacent to the option, i\&.e\&.: \'\-ovalue\' or \'<ndash></ndash>option=value\'\&. Giving \'\-o\' or \'<ndash></ndash>option\' will cause the implicit value to be applied\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
typed_value * value_name(const std::string & name);
.fi

.sp
Specifies the name used to to the value in help message\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
typed_value * implicit_value(const T & v, const std::string & textual);
.fi

.sp
Specifies an implicit value, which will be used if the option is given, but without an adjacent value\&. Using this implies that an explicit value is optional, but if given, must be strictly adjacent to the option, i\&.e\&.: \'\-ovalue\' or \'<ndash></ndash>option=value\'\&. Giving \'\-o\' or \'<ndash></ndash>option\' will cause the implicit value to be applied\&. Unlike the above overload, the type \'T\' need not provide operator<< for ostream, but textual representation of default value must be provided by the user\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
typed_value * notifier(function1< void, const T & > f);
.fi

.sp
Specifies a function to be called when the final value is determined\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
typed_value * composing();
.fi

.sp
Specifies that the value is composing\&. See the \'is_composing\' method for explanation\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
typed_value * multitoken();
.fi

.sp
Specifies that the value can span multiple tokens\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
typed_value * zero_tokens();
.fi

.sp
Specifies that no tokens may be provided as the value of this option, which means that only presense of the option is significant\&. For such option to be useful, either the \'validate\' function should be specialized, or the \'implicit_value\' method should be also used\&. In most cases, you can use the \'bool_switch\' function instead of using this method\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
typed_value * required();
.fi

.sp
Specifies that the value must occur\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
std::string name() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool is_composing() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
unsigned min_tokens() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
unsigned max_tokens() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
bool adjacent_tokens_only() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
bool is_required() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
void xparse(boost::any & value_store, 
            const std::vector< std::basic_string< charT > > & new_tokens) const;
.fi

.sp
Creates an instance of the \'validator\' class and calls its operator() to perform the actual conversion\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
virtual bool apply_default(boost::any & value_store) const;
.fi

.sp
If default value was specified via previous call to \'default_value\', stores that value into \'value_store\'\&. Returns true if default value was stored\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
void notify(const boost::any & value_store) const;
.fi

.sp
If an address of variable to store value was specified when creating *this, stores the value there\&. Otherwise, does nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
virtual const std::type_info & value_type() const;
.fi

.RE


