.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_P" 3 "" "" ""
.SH "NAME"
BOOST_PROTO_BASIC_EXTENDS \- For creating expression wrappers that add members to a Proto expression template, like proto::extends<>, but while retaining POD\-ness of the expression wrapper\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/extends\&.hpp>

BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, Domain)
.fi
.SH "DESCRIPTION"
.PP

BOOST_PROTO_BASIC_EXTENDS()
adds the basic typedefs, member functions, and data members necessary to make a struct a valid Proto expression extension\&. It does
\fInot\fR
add any constructors, virtual functions or access control blocks that would render the containing struct non\-POD\&.
.PP

Expr
is the Proto expression that the enclosing struct extends\&.
Derived
is the type of the enclosing struct\&.
Domain
is the Proto domain to which this expression extension belongs\&. (See
proto::domain<>\&.) Can be preceeded with "typename" if the specified domain is a dependent type\&.
.PP
BOOST_PROTO_BASIC_EXTENDS()
adds to its enclosing struct exactly one data member of type
Expr\&.
.PP
If the
Domain
parameter is dependent, you can specify it as
typename Domain, as in
BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, typename Domain)
.PP

\fBExample:\fR
.sp
.if n \{\
.RS 4
.\}
.nf
template< class Expr >
struct my_expr;

struct my_domain
  : proto::domain< proto::pod_generator< my_expr > >
{};

template< class Expr >
struct my_expr
{
    // OK, this makes my_expr<> a valid Proto expression extension\&.
    // my_expr<> does /not/ have overloaded assignment, subscript,
    // and function call operators that build expression templates, however\&.
    BOOST_PROTO_BASIC_EXTENDS(Expr, my_expr, my_domain)
};

// OK, my_expr<> is POD, so this is statically initialized:
my_expr< proto::terminal<int>::type > const _1 = {{1}};
.fi
.if n \{\
.RE
.\}
.sp

.PP
See also:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_EXTENDS_ASSIGN().RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_EXTENDS_SUBSCRIPT().RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_EXTENDS_FUNCTION().RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_EXTENDS().RE
.sp
.RE


