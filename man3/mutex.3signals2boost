.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS MUTEX" 3 "" "" ""
.SH "NAME"
boost::signals2::mutex \- A header\-only mutex which implements the Lockable concept of Boost\&.Thread\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/signals2/mutex\&.hpp>


class mutex {
public:
  void lock();
  bool try_lock();
  void unlock();
};
.fi
.SH "DESCRIPTION"
.PP
The
mutex
class implements the
Lockable
concept of Boost\&.Thread, and is the default
Mutex
template parameter type for signals\&. If boost has detected thread support in your compiler, the
mutex
class will map to a CRITICAL_SECTION on Windows or a pthread_mutex on POSIX\&. If thread support is not detected,
mutex
will behave similarly to a
dummy_mutex\&. The header file
boost/config\&.hpp
defines the macro
BOOST_HAS_THREADS
when boost detects threading support\&. The user may globally disable thread support in boost by defining BOOST_DISABLE_THREADS before any boost header files are included\&.
.PP
If you are already using the Boost\&.Thread library, you may prefer to use its boost::mutex class instead as the mutex type for your signals\&.
.PP
You may wish to use a thread\-unsafe signal, if the signal is only used by a single thread\&. In that case, you may prefer to use the
signals2::dummy_mutex
class as the
Mutex
template type for your signal\&.
.PP

.sp

.nf
void lock();
.fi

.PP
Locks the mutex\&.
.PP

.sp

.nf
bool try_lock();
.fi

.PP
Makes a non\-blocking attempt to lock the mutex\&.
.PP
Returns:
.RS 4
true
on success\&.
.RE
.PP

.sp

.nf
void unlock();
.fi

.PP
Unlocks the mutex\&.

