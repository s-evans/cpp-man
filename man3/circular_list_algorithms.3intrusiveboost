.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEM" 3 "" "" ""
.SH "NAME"
boost::intrusive::circular_list_algorithms
.SH "SYNOPSIS"
.\" unlink: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: unlink
.\" unique: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: unique
.\" transfer: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: transfer
.\" swap_prev: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: swap_prev
.\" swap_nodes: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: swap_nodes
.\" swap_next: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: swap_next
.\" stable_partition_info: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: stable_partition_info
.\" stable_partition: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: stable_partition
.\" reverse: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: reverse
.\" node_traits: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: node_traits
.\" node_ptr: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: node_ptr
.\" node: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: node
.\" move_forward: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: move_forward
.\" move_backwards: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: move_backwards
.\" link_before: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: link_before
.\" link_after: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: link_after
.\" inited: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: inited
.\" init_header: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: init_header
.\" init: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: init
.\" distance: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: distance
.\" count: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: count
.\" const_node_ptr: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: const_node_ptr
.\" circular_list_algorithms: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: circular_list_algorithms

.sp
.nf
// In header: <boost/intrusive/circular_list_algorithms\&.hpp>

template<typename NodeTraits> 
class circular_list_algorithms {
public:
  // types
  typedef NodeTraits::node           node;          
  typedef NodeTraits::node_ptr       node_ptr;      
  typedef NodeTraits::const_node_ptr const_node_ptr;
  typedef NodeTraits                 node_traits;   

  // member classes/structs/unions

  struct stable_partition_info {

    // public data members
    std::size_t num_1st_partition;
    std::size_t num_2nd_partition;
    node_ptr beg_2st_partition;
  };

  // public static functions
  static void init(const node_ptr &);
  static bool inited(const const_node_ptr &);
  static void init_header(const node_ptr &);
  static bool unique(const const_node_ptr &);
  static std::size_t count(const const_node_ptr &);
  static node_ptr unlink(const node_ptr &);
  static void unlink(const node_ptr &, const node_ptr &);
  static void link_before(const node_ptr &, const node_ptr &);
  static void link_after(const node_ptr &, const node_ptr &);
  static void swap_nodes(const node_ptr &, const node_ptr &);
  static void transfer(const node_ptr &, const node_ptr &, const node_ptr &);
  static void transfer(const node_ptr &, const node_ptr &);
  static void reverse(const node_ptr &);
  static void move_backwards(const node_ptr &, std::size_t);
  static void move_forward(const node_ptr &, std::size_t);
  static std::size_t distance(const const_node_ptr &, const const_node_ptr &);
  template<typename Pred> 
    static void stable_partition(node_ptr, const node_ptr &, Pred, 
                                 stable_partition_info &);

  // private static functions
  static void swap_prev(const node_ptr &, const node_ptr &);
  static void swap_next(const node_ptr &, const node_ptr &);
};
.fi
.SH "DESCRIPTION"
.\" set_next: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: set_next
.\" get_next: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: get_next
.\" set_previous: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: set_previous
.\" get_previous: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: get_previous
.PP
circular_list_algorithms
provides basic algorithms to manipulate nodes forming a circular doubly linked list\&. An empty circular list is formed by a node whose pointers point to itself\&.
.PP
circular_list_algorithms
is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated\&. NodeTraits must support the following interface:
.PP
\fBTypedefs\fR:
.PP
node: The type of the node that forms the circular list
.PP
node_ptr: A pointer to a node
.PP
const_node_ptr: A pointer to a const node
.PP
\fBStatic functions\fR:
.PP
static node_ptr get_previous(const_node_ptr n);
.PP
static void set_previous(node_ptr n, node_ptr prev);
.PP
static node_ptr get_next(const_node_ptr n);
.PP
static void set_next(node_ptr n, node_ptr next);
.SS "circular_list_algorithms public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" inited: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: inited
.\" init: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: init

.sp

.nf
static void init(const node_ptr & this_node);
.fi

.sp
\fBEffects\fR: Constructs an non\-used list element, so that inited(this_node) == true
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" inited: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: inited

.sp

.nf
static bool inited(const const_node_ptr & this_node);
.fi

.sp
\fBEffects\fR: Returns true is "this_node" is in a non\-used state as if it was initialized by the "init" function\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" init_header: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: init_header

.sp

.nf
static void init_header(const node_ptr & this_node);
.fi

.sp
\fBEffects\fR: Constructs an empty list, making this_node the only node of the circular list:
NodeTraits::get_next(this_node) == NodeTraits::get_previous(this_node) == this_node\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unique: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: unique

.sp

.nf
static bool unique(const const_node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Returns true is "this_node" is the only node of a circular list:
return NodeTraits::get_next(this_node) == this_node
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" count: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: count

.sp

.nf
static std::size_t count(const const_node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Returns the number of nodes in a circular list\&. If the circular list is empty, returns 1\&.
.sp
\fBComplexity\fR: Linear
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" unlink: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: unlink

.sp

.nf
static node_ptr unlink(const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Unlinks the node from the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" unlink: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: unlink

.sp

.nf
static void unlink(const node_ptr & b, const node_ptr & e);
.fi

.sp
\fBRequires\fR: b and e must be nodes of the same circular list or an empty range\&.
.sp
\fBEffects\fR: Unlinks the node [b, e) from the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" link_before: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: link_before

.sp

.nf
static void link_before(const node_ptr & nxt_node, const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: nxt_node must be a node of a circular list\&.
.sp
\fBEffects\fR: Links this_node before nxt_node in the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" link_after: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: link_after

.sp

.nf
static void link_after(const node_ptr & prev_node, const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: prev_node must be a node of a circular list\&.
.sp
\fBEffects\fR: Links this_node after prev_node in the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" swap_nodes: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: swap_nodes

.sp

.nf
static void swap_nodes(const node_ptr & this_node, 
                       const node_ptr & other_node);
.fi

.sp
\fBRequires\fR: this_node and other_node must be nodes inserted in circular lists or be empty circular lists\&.
.sp
\fBEffects\fR: Swaps the position of the nodes: this_node is inserted in other_nodes position in the second circular list and the other_node is inserted in this_node\'s position in the first circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" transfer: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: transfer

.sp

.nf
static void transfer(const node_ptr & p, const node_ptr & b, 
                     const node_ptr & e);
.fi

.sp
\fBRequires\fR: b and e must be nodes of the same circular list or an empty range\&. and p must be a node of a different circular list or may not be an iterator in
\fBEffects\fR: Removes the nodes from [b, e) range from their circular list and inserts them before p in p\'s circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" transfer: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: transfer

.sp

.nf
static void transfer(const node_ptr & p, const node_ptr & i);
.fi

.sp
\fBRequires\fR: i must a node of a circular list and p must be a node of a different circular list\&.
.sp
\fBEffects\fR: Removes the node i from its circular list and inserts it before p in p\'s circular list\&. If p == i or p == NodeTraits::get_next(i), this function is a null operation\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" reverse: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: reverse

.sp

.nf
static void reverse(const node_ptr & p);
.fi

.sp
\fBEffects\fR: Reverses the order of elements in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: This function is linear time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" move_backwards: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: move_backwards

.sp

.nf
static void move_backwards(const node_ptr & p, std::size_t n);
.fi

.sp
\fBEffects\fR: Moves the node p n positions towards the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of moved positions\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" move_forward: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: move_forward

.sp

.nf
static void move_forward(const node_ptr & p, std::size_t n);
.fi

.sp
\fBEffects\fR: Moves the node p n positions towards the beginning of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of moved positions\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" distance: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: distance

.sp

.nf
static std::size_t 
distance(const const_node_ptr & f, const const_node_ptr & l);
.fi

.sp
\fBRequires\fR: f and l must be in a circular list\&.
.sp
\fBEffects\fR: Returns the number of nodes in the range [f, l)\&.
.sp
\fBComplexity\fR: Linear
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" stable_partition: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: stable_partition

.sp

.nf
template<typename Pred> 
  static void stable_partition(node_ptr beg, const node_ptr & end, Pred pred, 
                               stable_partition_info & info);
.fi

.RE

.SS "circular_list_algorithms private static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" swap_prev: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: swap_prev

.sp

.nf
static void swap_prev(const node_ptr & this_node, const node_ptr & other_node);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" swap_next: Class template circular_list_algorithms
.\" Class template circular_list_algorithms: swap_next

.sp

.nf
static void swap_next(const node_ptr & this_node, const node_ptr & other_node);
.fi

.RE


