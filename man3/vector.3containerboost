.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE VEC" 3 "" "" ""
.SH "NAME"
boost::container::vector
.SH "SYNOPSIS"
.\" vector: Class template vector
.\" Class template vector: vector
.\" value_type: Class template vector
.\" Class template vector: value_type
.\" swap: Class template vector
.\" Class template vector: swap
.\" stored_allocator_type: Class template vector
.\" Class template vector: stored_allocator_type
.\" size_type: Class template vector
.\" Class template vector: size_type
.\" shrink_to_fit: Class template vector
.\" Class template vector: shrink_to_fit
.\" reverse_iterator: Class template vector
.\" Class template vector: reverse_iterator
.\" resize: Class template vector
.\" Class template vector: resize
.\" reserve: Class template vector
.\" Class template vector: reserve
.\" rend: Class template vector
.\" Class template vector: rend
.\" reference: Class template vector
.\" Class template vector: reference
.\" rbegin: Class template vector
.\" Class template vector: rbegin
.\" push_back: Class template vector
.\" Class template vector: push_back
.\" pop_back: Class template vector
.\" Class template vector: pop_back
.\" pointer: Class template vector
.\" Class template vector: pointer
.\" nth: Class template vector
.\" Class template vector: nth
.\" iterator: Class template vector
.\" Class template vector: iterator
.\" insert: Class template vector
.\" Class template vector: insert
.\" index_of: Class template vector
.\" Class template vector: index_of
.\" get_stored_allocator: Class template vector
.\" Class template vector: get_stored_allocator
.\" front: Class template vector
.\" Class template vector: front
.\" erase: Class template vector
.\" Class template vector: erase
.\" end: Class template vector
.\" Class template vector: end
.\" emplace_back: Class template vector
.\" Class template vector: emplace_back
.\" emplace: Class template vector
.\" Class template vector: emplace
.\" difference_type: Class template vector
.\" Class template vector: difference_type
.\" const_reverse_iterator: Class template vector
.\" Class template vector: const_reverse_iterator
.\" const_reference: Class template vector
.\" Class template vector: const_reference
.\" const_pointer: Class template vector
.\" Class template vector: const_pointer
.\" const_iterator: Class template vector
.\" Class template vector: const_iterator
.\" clear: Class template vector
.\" Class template vector: clear
.\" begin: Class template vector
.\" Class template vector: begin
.\" back: Class template vector
.\" Class template vector: back
.\" at: Class template vector
.\" Class template vector: at
.\" assign: Class template vector
.\" Class template vector: assign
.\" allocator_type: Class template vector
.\" Class template vector: allocator_type

.sp
.nf
// In header: <boost/container/vector\&.hpp>

template<typename T, typename Allocator = new_allocator<T> > 
class vector {
public:
  // types
  typedef T                                                                  value_type;            
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef Allocator                                                          stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  vector() noexcept;
  explicit vector(const allocator_type &) noexcept;
  explicit vector(size_type);
  vector(size_type, default_init_t);
  explicit vector(size_type, const allocator_type &);
  vector(size_type, default_init_t, const allocator_type &);
  vector(size_type, const T &);
  vector(size_type, const T &, const allocator_type &);
  template<typename InIt> vector(InIt, InIt);
  template<typename InIt> vector(InIt, InIt, const allocator_type &);
  vector(const vector &);
  vector(vector &&) noexcept;
  vector(std::initializer_list< value_type >, 
         const allocator_type & = allocator_type());
  vector(const vector &, const allocator_type &);
  vector(vector &&, const allocator_type &);
  vector & operator=(const vector &);
  vector & operator=(std::initializer_list< value_type >);
  vector & operator=(vector &&) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
  ~vector();

  // public member functions
  template<typename InIt> void assign(InIt, InIt last );
  void assign(std::initializer_list< T >);
  template<typename FwdIt> void assign(FwdIt, FwdIt last );
  void assign(size_type, const value_type &);
  allocator_type get_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_iterator cbegin() const noexcept;
  const_iterator cend() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const noexcept;
  size_type size() const noexcept;
  size_type max_size() const noexcept;
  void resize(size_type);
  void resize(size_type, default_init_t);
  void resize(size_type, const T &);
  size_type capacity() const noexcept;
  void reserve(size_type);
  void shrink_to_fit();
  reference front() noexcept;
  const_reference front() const noexcept;
  reference back() noexcept;
  const_reference back() const noexcept;
  reference operator[](size_type) noexcept;
  const_reference operator[](size_type) const noexcept;
  iterator nth(size_type) noexcept;
  const_iterator nth(size_type) const noexcept;
  size_type index_of(iterator) noexcept;
  size_type index_of(const_iterator) const noexcept;
  reference at(size_type);
  const_reference at(size_type) const;
  T * data() noexcept;
  const T * data() const noexcept;
  template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> bool stable_emplace_back(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace(const_iterator, Args &&\&.\&.\&.);
  void push_back(const T &);
  void push_back(T &&);
  iterator insert(const_iterator, const T &);
  iterator insert(const_iterator, T &&);
  iterator insert(const_iterator, size_type, const T &);
  template<typename InIt> iterator insert(const_iterator, InIt, InIt);
  iterator insert(const_iterator, std::initializer_list< value_type >);
  void pop_back() noexcept;
  iterator erase(const_iterator);
  iterator erase(const_iterator, const_iterator);
  void swap(vector &) noexcept(((allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value)&&!container_detail::is_version< Allocator, 0 >::value)));
  void clear() noexcept;

  // friend functions
  friend bool operator==(const vector &, const vector &);
  friend bool operator!=(const vector &, const vector &);
  friend bool operator<(const vector &, const vector &);
  friend bool operator>(const vector &, const vector &);
  friend bool operator<=(const vector &, const vector &);
  friend bool operator>=(const vector &, const vector &);
  friend void swap(vector &, vector &);
};
.fi
.SH "DESCRIPTION"
.PP
A vector is a sequence that supports random access to elements, constant time insertion and removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle\&. The number of elements in a vector may vary dynamically; memory management is automatic\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of object that is stored in the vector
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<T>
.fi

.sp
The allocator used for all internal memory management
.RE

.SS "vector public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
vector() noexcept;
.fi

.sp
\fBEffects\fR: Constructs a vector taking the allocator as parameter\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit vector(const allocator_type & a) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a vector taking the allocator as parameter\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit vector(size_type n);
.fi

.sp
\fBEffects\fR: Constructs a vector and inserts n value initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s value initialization throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
vector(size_type n, default_init_t);
.fi

.sp
\fBEffects\fR: Constructs a vector that will use a copy of allocator a and inserts n default initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s default initialization throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
explicit vector(size_type n, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a vector that will use a copy of allocator a and inserts n value initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s value initialization throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
vector(size_type n, default_init_t, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a vector that will use a copy of allocator a and inserts n default initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s default initialization throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
vector(size_type n, const T & value);
.fi

.sp
\fBEffects\fR: Constructs a vector and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
vector(size_type n, const T & value, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a vector that will use a copy of allocator a and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename InIt> vector(InIt first, InIt last);
.fi

.sp
\fBEffects\fR: Constructs a vector and inserts a copy of the range [first, last) in the vector\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s constructor taking a dereferenced InIt throws\&.
.sp
\fBComplexity\fR: Linear to the range [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename InIt> 
  vector(InIt first, InIt last, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a vector that will use a copy of allocator a and inserts a copy of the range [first, last) in the vector\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s constructor taking a dereferenced InIt throws\&.
.sp
\fBComplexity\fR: Linear to the range [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
vector(const vector & x);
.fi

.sp
\fBEffects\fR: Copy constructs a vector\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocator_type\'s allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
vector(vector && x) noexcept;
.fi

.sp
\fBEffects\fR: Move constructor\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
vector(std::initializer_list< value_type > il, 
       const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a vector that will use a copy of allocator a and inserts a copy of the range [il\&.begin(), il\&.last()) in the vector
.sp
\fBThrows\fR: If T\'s constructor taking a dereferenced initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
vector(const vector & x, const allocator_type & a);
.fi

.sp
defined(BOOST_CONTAINER_DOXYGEN_INVOKED) \fBEffects\fR: Copy constructs a vector using the specified allocator\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBThrows\fR: If allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
vector(vector && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructor using the specified allocator\&. Moves x\'s resources to *this if a == allocator_type()\&. Otherwise copies values from x to *this\&.
.sp
\fBThrows\fR: If allocation or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant if a == x\&.get_allocator(), linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
vector & operator=(const vector & x);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as x\&.
.sp
\fBPostcondition\fR: this\->size() == x\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor/assignment throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements in x\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
vector & operator=(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Make *this container contains elements from il\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
vector & operator=(vector && x) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Move assignment\&. All x\'s values are transferred to *this\&.
.sp
\fBPostcondition\fR: x\&.empty()\&. *this contains a the elements x had before the function\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
~vector();
.fi

.sp
\fBEffects\fR: Destroys the vector\&. All stored values are destroyed and used memory is deallocated\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements\&.
.RE

.SS "vector public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" assign: Class template vector
.\" Class template vector: assign

.sp

.nf
template<typename InIt> 
  void assign(InIt first, InIt last  BOOST_CONTAINER_DOCIGN);
.fi

.sp
\fBEffects\fR: Assigns the the range [first, last) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor/assignment or T\'s constructor/assignment from dereferencing InpIt throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" assign: Class template vector
.\" Class template vector: assign

.sp

.nf
void assign(std::initializer_list< T > il);
.fi

.sp
\fBEffects\fR: Assigns the the range [il\&.begin(), il\&.end()) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing iniializer_list iterator throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" assign: Class template vector
.\" Class template vector: assign

.sp

.nf
template<typename FwdIt> 
  void assign(FwdIt first, FwdIt last  BOOST_CONTAINER_DOCIGN);
.fi

.sp
\fBEffects\fR: Assigns the the range [first, last) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor/assignment or T\'s constructor/assignment from dereferencing InpIt throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" assign: Class template vector
.\" Class template vector: assign

.sp

.nf
void assign(size_type n, const value_type & val);
.fi

.sp
\fBEffects\fR: Assigns the n copies of val to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor/assignment throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a copy of the internal allocator\&.
.sp
\fBThrows\fR: If allocator\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" get_stored_allocator: Class template vector
.\" Class template vector: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" get_stored_allocator: Class template vector
.\" Class template vector: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" begin: Class template vector
.\" Class template vector: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" begin: Class template vector
.\" Class template vector: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" rbegin: Class template vector
.\" Class template vector: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rbegin: Class template vector
.\" Class template vector: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template vector
.\" Class template vector: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" rend: Class template vector
.\" Class template vector: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
\fBEffects\fR: Returns true if the vector contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" resize: Class template vector
.\" Class template vector: resize

.sp

.nf
void resize(size_type new_size);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are value initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy/move or value initialization throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" resize: Class template vector
.\" Class template vector: resize

.sp

.nf
void resize(size_type new_size, default_init_t);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are default initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy/move or default initialization throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" resize: Class template vector
.\" Class template vector: resize

.sp

.nf
void resize(size_type new_size, const T & x);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are copy constructed from x\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy/move constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
size_type capacity() const noexcept;
.fi

.sp
\fBEffects\fR: Number of elements for which memory has been allocated\&. capacity() is always greater than or equal to size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" reserve: Class template vector
.\" Class template vector: reserve

.sp

.nf
void reserve(size_type new_cap);
.fi

.sp
\fBEffects\fR: If n is less than or equal to capacity(), this call has no effect\&. Otherwise, it is a request for allocation of additional memory\&. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged\&. In either case, size() is unchanged\&.
.sp
\fBThrows\fR: If memory allocation allocation throws or T\'s copy/move constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" shrink_to_fit: Class template vector
.\" Class template vector: shrink_to_fit

.sp

.nf
void shrink_to_fit();
.fi

.sp
\fBEffects\fR: Tries to deallocate the excess of memory created with previous allocations\&. The size of the vector is unchanged
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy/move constructor throws\&.
.sp
\fBComplexity\fR: Linear to size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" front: Class template vector
.\" Class template vector: front

.sp

.nf
reference front() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the first element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" front: Class template vector
.\" Class template vector: front

.sp

.nf
const_reference front() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the first element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" back: Class template vector
.\" Class template vector: back

.sp

.nf
reference back() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the last element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" back: Class template vector
.\" Class template vector: back

.sp

.nf
const_reference back() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the last element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}

.sp

.nf
reference operator[](size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}

.sp

.nf
const_reference operator[](size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end
.\" nth: Class template vector
.\" Class template vector: nth

.sp

.nf
iterator nth(size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end
.\" nth: Class template vector
.\" Class template vector: nth

.sp

.nf
const_iterator nth(size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns a const_iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end
.\" index_of: Class template vector
.\" Class template vector: index_of

.sp

.nf
size_type index_of(iterator p) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" index_of: Class template vector
.\" Class template vector: index_of

.sp

.nf
size_type index_of(const_iterator p) const noexcept;
.fi

.sp
\fBRequires\fR: begin() <= p <= end()\&.
.sp
\fBEffects\fR: Returns the index of the element pointed by p and size() if p == end()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" at: Class template vector
.\" Class template vector: at

.sp

.nf
reference at(size_type n);
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" at: Class template vector
.\" Class template vector: at

.sp

.nf
const_reference at(size_type n) const;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}

.sp

.nf
T * data() noexcept;
.fi

.sp
\fBReturns\fR: A pointer such that [data(),data() + size()) is a valid range\&. For a non\-empty vector, data() == &front()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}

.sp

.nf
const T * data() const noexcept;
.fi

.sp
\fBReturns\fR: A pointer such that [data(),data() + size()) is a valid range\&. For a non\-empty vector, data() == &front()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" emplace_back: Class template vector
.\" Class template vector: emplace_back

.sp

.nf
template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the end of the vector\&.
.sp
\fBThrows\fR: If memory allocation throws or the in\-place constructor throws or T\'s copy/move constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> bool stable_emplace_back(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the end of the vector\&.
.sp
\fBThrows\fR: If the in\-place constructor throws\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end
.\" emplace: Class template vector
.\" Class template vector: emplace

.sp

.nf
template<class\&.\&.\&. Args> 
  iterator emplace(const_iterator position, Args &&\&.\&.\&. args);
.fi

.sp
\fBRequires\fR: position must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. before position
.sp
\fBThrows\fR: If memory allocation throws or the in\-place constructor throws or T\'s copy/move constructor/assignment throws\&.
.sp
\fBComplexity\fR: If position is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" push_back: Class template vector
.\" Class template vector: push_back

.sp

.nf
void push_back(const T & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x at the end of the vector\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" push_back: Class template vector
.\" Class template vector: push_back

.sp

.nf
void push_back(T && x);
.fi

.sp
\fBEffects\fR: Constructs a new element in the end of the vector and moves the resources of x to this new element\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end
.\" insert: Class template vector
.\" Class template vector: insert

.sp

.nf
iterator insert(const_iterator position, const T & x);
.fi

.sp
\fBRequires\fR: position must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of x before position\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor/assignment throws\&.
.sp
\fBComplexity\fR: If position is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" end: Class template vector
.\" Class template vector: end
.\" insert: Class template vector
.\" Class template vector: insert

.sp

.nf
iterator insert(const_iterator position, T && x);
.fi

.sp
\fBRequires\fR: position must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a new element before position with x\'s resources\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: If position is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" insert: Class template vector
.\" Class template vector: insert

.sp

.nf
iterator insert(const_iterator p, size_type n, const T & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert n copies of x before pos\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if n is 0\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy/move constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" insert: Class template vector
.\" Class template vector: insert

.sp

.nf
template<typename InIt> 
  iterator insert(const_iterator pos, InIt first, InIt last);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [first, last) range before pos\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or pos if first == last\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced InpIt throws or T\'s copy/move constructor/assignment throws\&.
.sp
\fBComplexity\fR: Linear to boost::container::iterator_distance [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" insert: Class template vector
.\" Class template vector: insert

.sp

.nf
iterator insert(const_iterator position, 
                std::initializer_list< value_type > il);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&. num, must be equal to boost::container::iterator_distance(first, last)
.sp
\fBEffects\fR: Insert a copy of the [first, last) range before pos\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or pos if first == last\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced InpIt throws or T\'s copy/move constructor/assignment throws\&.
.sp
\fBComplexity\fR: Linear to boost::container::iterator_distance [first, last)\&.
.sp
\fBNote\fR: This function avoids a linear operation to calculate boost::container::iterator_distance[first, last) for forward and bidirectional iterators, and a one by one insertion for input iterators\&. This is a a non\-standard extension\&.
\fBRequires\fR: position must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [il\&.begin(), il\&.end()) range before position\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or position if first == last\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" pop_back: Class template vector
.\" Class template vector: pop_back

.sp

.nf
void pop_back() noexcept;
.fi

.sp
\fBEffects\fR: Removes the last element from the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" erase: Class template vector
.\" Class template vector: erase

.sp

.nf
iterator erase(const_iterator position);
.fi

.sp
\fBEffects\fR: Erases the element at position pos\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements between pos and the last element\&. Constant if pos is the last element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" erase: Class template vector
.\" Class template vector: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

.sp
\fBEffects\fR: Erases the elements pointed by [first, last)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the distance between first and last plus linear to the elements between pos and the last element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" swap: Class template vector
.\" Class template vector: swap

.sp

.nf
void swap(vector & x) noexcept(((allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value)&&!container_detail::is_version< Allocator, 0 >::value)));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" clear: Class template vector
.\" Class template vector: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: Erases all the elements of the vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE

.SS "vector friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const vector & x, const vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const vector & x, const vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const vector & x, const vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const vector & x, const vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const vector & x, const vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const vector & x, const vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template vector
.\" Class template vector: swap

.sp

.nf
friend void swap(vector & x, vector & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


