.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLAT" 3 "" "" ""
.SH "NAME"
boost::units::static_rational
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/units/static_rational\&.hpp>

template<integer_type N, integer_type D = 1> 
class static_rational {
public:
  // types
  typedef \fIunspecified\fR                               tag; 
  typedef static_rational< Numerator, Denominator > type;  // static_rational<N,D> reduced by GCD 

  // construct/copy/destruct
  static_rational();

  // public static functions
  static integer_type numerator();
  static integer_type denominator();

  // public data members
  static const integer_type Numerator;
  static const integer_type Denominator;
};
.fi
.SH "DESCRIPTION"
.PP
This is an implementation of a compile time rational number, where
static_rational<N,D>
represents a rational number with numerator
N
and denominator
D\&. Because of the potential for ambiguity arising from multiple equivalent values of
static_rational
(e\&.g\&.
static_rational<6,2>==static_rational<3>), static rationals should always be accessed through
static_rational<N,D>::type\&. Template specialization prevents instantiation of zero denominators (i\&.e\&.
static_rational<N,0>)\&. The following compile\-time arithmetic operators are provided for
static_rational
variables only (no operators are defined between long and
static_rational):
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
mpl::negate
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
mpl::plus
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
mpl::minus
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
mpl::times
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
mpl::divides
.RE
.sp
.RE

.PP
Neither
static_power
nor
static_root
are defined for
static_rational\&. This is because template types may not be floating point values, while powers and roots of rational numbers can produce floating point values\&.
.SS "static_rational public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static_rational();
.fi

.RE

.SS "static_rational public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static integer_type numerator();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static integer_type denominator();
.fi

.RE


