.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS INTER" 3 "" "" ""
.SH "NAME"
boost::interprocess::interprocess_recursive_mutex
.SH "SYNOPSIS"
.\" unlock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: unlock
.\" try_lock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: try_lock
.\" timed_lock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: timed_lock
.\" lock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: lock
.\" interprocess_recursive_mutex: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: interprocess_recursive_mutex
.\" interprocess_recursive_mutex: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: interprocess_recursive_mutex

.sp
.nf
// In header: <boost/interprocess/sync/interprocess_recursive_mutex\&.hpp>


class interprocess_recursive_mutex {
public:
  // construct/copy/destruct
  interprocess_recursive_mutex();
  ~interprocess_recursive_mutex();

  // public member functions
  void lock();
  bool try_lock();
  bool timed_lock(const boost::posix_time::ptime &);
  void unlock();
};
.fi
.SH "DESCRIPTION"
.PP
Wraps a
interprocess_mutex
that can be placed in shared memory and can be shared between processes\&. Allows several locking calls by the same process\&. Allows timed lock tries
.SS "interprocess_recursive_mutex public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
interprocess_recursive_mutex();
.fi

.sp
Constructor\&. Throws
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
~interprocess_recursive_mutex();
.fi

.sp
Destructor\&. If any process uses the mutex after the destructor is called the result is undefined\&. Does not throw\&.
.RE

.SS "interprocess_recursive_mutex public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" lock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: lock

.sp

.nf
void lock();
.fi

.sp
Effects: The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership\&. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex\&. The mutex must be unlocked the same number of times it is locked\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" try_lock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: try_lock

.sp

.nf
bool try_lock();
.fi

.sp
Tries to lock the
interprocess_mutex, returns false when
interprocess_mutex
is already locked, returns true when success\&. The mutex must be unlocked the same number of times it is locked\&. Throws:
interprocess_exception
if a severe error is found
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" timed_lock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: timed_lock

.sp

.nf
bool timed_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Tries to lock the
interprocess_mutex, if
interprocess_mutex
can\'t be locked before abs_time time, returns false\&. The mutex must be unlocked the same number of times it is locked\&. Throws:
interprocess_exception
if a severe error is found
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlock: Class interprocess_recursive_mutex
.\" Class interprocess_recursive_mutex: unlock

.sp

.nf
void unlock();
.fi

.sp
Effects: The calling thread releases the exclusive ownership of the mutex\&. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked\&. Throws:
interprocess_exception
on error\&.
.RE


