.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_T" 3 "" "" ""
.SH "NAME"
BOOST_TTI_TRAIT_HAS_TYPE
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/tti/has_type\&.hpp>

BOOST_TTI_TRAIT_HAS_TYPE(trait, name)
.fi
.SH "DESCRIPTION"
.PP
BOOST_TTI_TRAIT_HAS_TYPE is a macro which expands to a metafunction\&. The metafunction tests whether an inner type with a particular name exists and, optionally, whether a lambda expression invoked with the inner type is true or not\&.
.PP
trait = the name of the metafunction within the tti namespace\&.
.PP
name = the name of the inner type\&.
.PP
generates a metafunction called "trait" where \'trait\' is the macro parameter\&. template<class BOOST_TTI_TP_T,class BOOST_TTI_TP_U> struct trait { static const value = unspecified; typedef mpl::bool_<true\-or\-false> type; }; The metafunction types and return: BOOST_TTI_TP_T = the enclosing type in which to look for our \'name\'\&. BOOST_TTI_TP_U = (optional) An optional template parameter, defaulting to a marker type\&. If specified it is an MPL lambda expression which is invoked with the inner type found and must return a constant boolean value\&. returns = \'value\' depends on whether or not the optional BOOST_TTI_TP_U is specified\&. If BOOST_TTI_TP_U is not specified, then \'value\' is true if the \'name\' type exists within the enclosing type BOOST_TTI_TP_T; otherwise \'value\' is false\&. If BOOST_TTI_TP_U is specified , then \'value\' is true if the \'name\' type exists within the enclosing type BOOST_TTI_TP_T and the lambda expression as specified by BOOST_TTI_TP_U, invoked by passing the actual inner type of \'name\', returns a \'value\' of true; otherwise \'value\' is false\&. The action taken with BOOST_TTI_TP_U occurs only when the \'name\' type exists within the enclosing type BOOST_TTI_TP_T\&.
.PP
Example usage:
.PP
BOOST_TTI_TRAIT_HAS_TYPE(LookFor,MyType) generates the metafunction LookFor in the current scope to look for an inner type called MyType\&.
.PP
LookFor<EnclosingType>::value is true if MyType is an inner type of EnclosingType, otherwise false\&.
.PP
LookFor<EnclosingType,ALambdaExpression>::value is true if MyType is an inner type of EnclosingType and invoking ALambdaExpression with the inner type returns a value of true, otherwise false\&.
.PP
A popular use of the optional MPL lambda expression is to check whether the type found is the same as another type, when the type found is a typedef\&. In that case our example would be:
.PP
LookFor<EnclosingType,boost::is_same<_,SomeOtherType> >::value is true if MyType is an inner type of EnclosingType and is the same type as SomeOtherType\&.

