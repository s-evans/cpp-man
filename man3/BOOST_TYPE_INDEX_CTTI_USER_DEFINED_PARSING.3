.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACR" 3 "" "" ""
.SH "NAME"
BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/type_index\&.hpp>

BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING
.fi
.SH "DESCRIPTION"
.PP
This is a helper macro for making correct pretty_names() with RTTI off\&.
.PP
BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING macro may be defined to \'(begin_skip, end_skip, runtime_skip, runtime_skip_until)\' with parameters for adding a support for compilers, that by default are not recognized by TypeIndex library\&.
.PP
\fBExample:\fR
.PP
Imagine the situation when

.sp
.if n \{\
.RS 4
.\}
.nf
boost::typeindex::ctti_type_index::type_id<int>()\&.pretty_name() 

.fi
.if n \{\
.RE
.\}
.sp
returns the following string:

.sp
.if n \{\
.RS 4
.\}
.nf
"static const char *boost::detail::ctti<int>::n() [T = int]" 

.fi
.if n \{\
.RE
.\}
.sp
and
.sp
.if n \{\
.RS 4
.\}
.nf
boost::typeindex::ctti_type_index::type_id<short>()\&.pretty_name() 

.fi
.if n \{\
.RE
.\}
.sp
returns the following:

.sp
.if n \{\
.RS 4
.\}
.nf
"static const char *boost::detail::ctti<short>::n() [T = short]" 

.fi
.if n \{\
.RE
.\}

.PP
As we may see first 39 characters are "static const char *boost::detail::ctti<" and they do not depend on the type T\&. After first 39 characters we have a human readable type name which is duplicated at the end of a string\&. String always ends on \']\', which consumes 1 character\&.
.PP
Now if we define
BOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING
to
(39, 1, false, "")
we\'ll be getting
.sp
.if n \{\
.RS 4
.\}
.nf
"int>::n() [T = int" 

.fi
.if n \{\
.RE
.\}
.sp
for
boost::typeindex::ctti_type_index::type_id<int>()\&.pretty_name()
and
.sp
.if n \{\
.RS 4
.\}
.nf
"short>::n() [T = short" 

.fi
.if n \{\
.RE
.\}
.sp
for
boost::typeindex::ctti_type_index::type_id<short>()\&.pretty_name()\&.
.PP
Now we need to take additional care of the characters that go before the last mention of our type\&. We\'ll do that by telling the macro that we need to cut off everything that goes before the "T = " including the "T = " itself:
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
(39, 1, true, "T = ") 

.fi
.if n \{\
.RE
.\}

.PP
In case of GCC or Clang command line we need to add the following line while compiling all the sources:
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
\-DBOOST_TYPE_INDEX_CTTI_USER_DEFINED_PARSING=\'(39, 1, true, "T = ")\'

.fi
.if n \{\
.RE
.\}
.sp
See
\m[blue]\fBRTTI emulation limitations\fR\m[]\&\s-2\u[1]\d\s+2
for more info\&.

