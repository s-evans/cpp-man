.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TE" 3 "" "" ""
.SH "NAME"
boost::random::linear_congruential_engine
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/random/linear_congruential\&.hpp>

template<typename IntType, IntType a, IntType c, IntType m> 
class linear_congruential_engine {
public:
  // types
  typedef IntType result_type;

  // construct/copy/destruct
  linear_congruential_engine();
  explicit linear_congruential_engine(IntType);
  template<typename SeedSeq> explicit linear_congruential_engine(SeedSeq &);
  template<typename It> linear_congruential_engine(It &, It);

  // public member functions
  void seed();
  void seed(IntType);
  template<typename SeedSeq> void seed(SeedSeq &);
  template<typename It> void seed(It &, It);
  IntType operator()();
  template<typename Iter> void generate(Iter, Iter);
  void discard(boost::uintmax_t);

  // public static functions
  static result_type min();
  static result_type max();

  // friend functions
  template<typename CharT, typename Traits> 
    friend std::basic_ostream< CharT, Traits > & 
    operator<<(std::basic_ostream< CharT, Traits > &, 
               const linear_congruential_engine &);
  template<typename CharT, typename Traits> 
    friend std::basic_istream< CharT, Traits > & 
    operator>>(std::basic_istream< CharT, Traits > &, 
               linear_congruential_engine &);

  // public data members
  static const bool has_fixed_range;
  static const IntType multiplier;
  static const IntType increment;
  static const IntType modulus;
  static const IntType default_seed;
};
.fi
.SH "DESCRIPTION"
.PP
Instantiations of class template
linear_congruential_engine
model a
pseudo\-random number generator
\&. Linear congruential pseudo\-random number generators are described in:
.PP

.PP "Mathematical methods in large\-scale computing units", D\&. H\&. Lehmer, Proc\&. 2nd Symposium on Large\-Scale Digital Calculating Machines, Harvard University Press, 1951, pp\&. 141\-146
.PP
Let x(n) denote the sequence of numbers returned by some pseudo\-random number generator\&. Then for the linear congruential generator, x(n+1) := (a * x(n) + c) mod m\&. Parameters for the generator are x(0), a, c, m\&. The template parameter IntType shall denote an integral type\&. It must be large enough to hold values a, c, and m\&. The template parameters a and c must be smaller than m\&.
.PP
Note: The quality of the generator crucially depends on the choice of the parameters\&. User code should use one of the sensibly parameterized generators such as minstd_rand instead\&.
.SS "linear_congruential_engine public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
linear_congruential_engine();
.fi

.sp
Constructs a
linear_congruential_engine, using the default seed
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit linear_congruential_engine(IntType x0);
.fi

.sp
Constructs a
linear_congruential_engine, seeding it with
x0\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename SeedSeq> explicit linear_congruential_engine(SeedSeq & seq);
.fi

.sp
Constructs a
linear_congruential_engine, seeding it with values produced by a call to
seq\&.generate()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename It> linear_congruential_engine(It & first, It last);
.fi

.sp
Constructs a
linear_congruential_engine
and seeds it with values taken from the itrator range [first, last) and adjusts first to point to the element after the last one used\&. If there are not enough elements, throws
std::invalid_argument\&.
.sp
first and last must be input iterators\&.
.RE

.SS "linear_congruential_engine public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void seed();
.fi

.sp
Calls seed(default_seed)
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void seed(IntType x0);
.fi

.sp
If c mod m is zero and x0 mod m is zero, changes the current value of the generator to 1\&. Otherwise, changes it to x0 mod m\&. If c is zero, distinct seeds in the range [1,m) will leave the generator in distinct states\&. If c is not zero, the range is [0,m)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename SeedSeq> void seed(SeedSeq & seq);
.fi

.sp
Seeds a
linear_congruential_engine
using values from a SeedSeq\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename It> void seed(It & first, It last);
.fi

.sp
seeds a
linear_congruential_engine
with values taken from the itrator range [first, last) and adjusts
first
to point to the element after the last one used\&. If there are not enough elements, throws
std::invalid_argument\&.
.sp
first
and
last
must be input iterators\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
IntType operator()();
.fi

.sp
Returns the next value of the
linear_congruential_engine\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename Iter> void generate(Iter first, Iter last);
.fi

.sp
Fills a range with random values
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
void discard(boost::uintmax_t z);
.fi

.sp
Advances the state of the generator by
z\&.
.RE

.SS "linear_congruential_engine public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static result_type min();
.fi

.sp
Returns the smallest value that the
linear_congruential_engine
can produce\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static result_type max();
.fi

.sp
Returns the largest value that the
linear_congruential_engine
can produce\&.
.RE

.SS "linear_congruential_engine friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename CharT, typename Traits> 
  friend std::basic_ostream< CharT, Traits > & 
  operator<<(std::basic_ostream< CharT, Traits > & os, 
             const linear_congruential_engine & lcg);
.fi

.sp
Writes a
linear_congruential_engine
to a
std::ostream\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename CharT, typename Traits> 
  friend std::basic_istream< CharT, Traits > & 
  operator>>(std::basic_istream< CharT, Traits > & is, 
             linear_congruential_engine & lcg);
.fi

.sp
Reads a
linear_congruential_engine
from a
std::istream\&.
.RE


