.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS BASIC_SINK" 3 "" "" ""
.SH "NAME"
boost::log::sinks::basic_sink_frontend \- A base class for a logging sink frontend\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/sinks/basic_sink_frontend\&.hpp>


class basic_sink_frontend : public sink {
public:
  // types
  typedef base_type::exception_handler_type exception_handler_type;  // An exception handler type\&. 

  // construct/copy/destruct
  explicit basic_sink_frontend(bool);

  // public member functions
  template<typename FunT> void set_filter(FunT const &);
  void reset_filter();
  template<typename FunT> void set_exception_handler(FunT const &);
  void reset_exception_handler();
  virtual bool will_consume(attribute_value_set const &);

  // protected member functions
  mutex_type & frontend_mutex() const;
  exception_handler_type & exception_handler();
  exception_handler_type const & exception_handler() const;
  template<typename BackendMutexT, typename BackendT> 
    void feed_record(record_view const &, BackendMutexT &, BackendT &);
  template<typename BackendMutexT, typename BackendT> 
    bool try_feed_record(record_view const &, BackendMutexT &, BackendT &);
  template<typename BackendMutexT, typename BackendT> 
    void flush_backend(BackendMutexT &, BackendT &);

  // private member functions
  template<typename BackendMutexT, typename BackendT> 
    void flush_backend_impl(BackendMutexT &, BackendT &, mpl::true_);
  template<typename BackendMutexT, typename BackendT> 
    void flush_backend_impl(BackendMutexT &, BackendT &, mpl::false_);
};
.fi
.SH "DESCRIPTION"
.SS "basic_sink_frontend public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit basic_sink_frontend(bool cross_thread);
.fi

.sp
Initializing constructor\&. 
.PP
Parameters:
.RS 4
.PP
cross_thread
.RS 4
The flag indicates whether the sink passes log records between different threads
.RE
.RE
.RE

.SS "basic_sink_frontend public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename FunT> void set_filter(FunT const & filter);
.fi

.sp
The method sets sink\-specific filter functional object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void reset_filter();
.fi

.sp
The method resets the filter
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename FunT> void set_exception_handler(FunT const & handler);
.fi

.sp
The method sets an exception handler function
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void reset_exception_handler();
.fi

.sp
The method resets the exception handler function
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
virtual bool will_consume(attribute_value_set const & attrs);
.fi

.sp
The method returns
true
if no filter is set or the attribute values pass the filter
.sp

.PP
Parameters:
.RS 4
.PP
attrs
.RS 4
A set of attribute values of a logging record
.RE
.RE
.RE

.SS "basic_sink_frontend protected member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
mutex_type & frontend_mutex() const;
.fi

Returns reference to the frontend mutex\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
exception_handler_type & exception_handler();
.fi

Returns reference to the exception handler\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
exception_handler_type const & exception_handler() const;
.fi

Returns reference to the exception handler\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename BackendMutexT, typename BackendT> 
  void feed_record(record_view const & rec, BackendMutexT & backend_mutex, 
                   BackendT & backend);
.fi

Feeds log record to the backend\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename BackendMutexT, typename BackendT> 
  bool try_feed_record(record_view const & rec, BackendMutexT & backend_mutex, 
                       BackendT & backend);
.fi

Attempts to feeds log record to the backend, does not block if \fIbackend_mutex\fR is locked\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename BackendMutexT, typename BackendT> 
  void flush_backend(BackendMutexT & backend_mutex, BackendT & backend);
.fi

Flushes record buffers in the backend, if one supports it\&. .RE

.SS "basic_sink_frontend private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename BackendMutexT, typename BackendT> 
  void flush_backend_impl(BackendMutexT & backend_mutex, BackendT & backend, 
                          mpl::true_);
.fi

Flushes record buffers in the backend (the actual implementation) .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename BackendMutexT, typename BackendT> 
  void flush_backend_impl(BackendMutexT &, BackendT &, mpl::false_);
.fi

Flushes record buffers in the backend (stub for backends that don\'t support flushing) .RE


