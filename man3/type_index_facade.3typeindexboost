.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::typeindex::type_index_facade
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/type_index/type_index_facade\&.hpp>

template<typename Derived, typename TypeInfo> 
class type_index_facade {
public:
  // types
  typedef TypeInfo type_info_t;

  // public member functions
  const char * name() const noexcept;
  std::string pretty_name() const;
  bool equal(const Derived &) const noexcept;
  bool before(const Derived &) const noexcept;
  std::size_t hash_code() const noexcept;

  // protected member functions
  const char * raw_name() const noexcept;
  const type_info_t & type_info() const noexcept;

  // protected static functions
  template<typename T> static Derived type_id() noexcept;
  template<typename T> static Derived type_id_with_cvr() noexcept;
  template<typename T> static Derived type_id_runtime(const T &) noexcept;
};
.fi
.SH "DESCRIPTION"
.PP
This class takes care about the comparison operators, hash functions and ostream operators\&. Use this class as a public base class for defining new type_info\-conforming classes\&.
.PP
\fBExample:\fR

.sp
.if n \{\
.RS 4
.\}
.nf
class stl_type_index: public type_index_facade<stl_type_index, std::type_info> 
{
public:
    typedef std::type_info type_info_t;
private:
    const type_info_t* data_;

public:
    stl_type_index(const type_info_t& data) noexcept
        : data_(&data)
    {}
// \&.\&.\&.
};

.fi
.if n \{\
.RE
.\}

.PP

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.PP
Take a look at the protected methods\&. They are
\fBnot\fR
\fBdefined\fR
in
type_index_facade\&. Protected member functions raw_name()
\fBmust\fR
be defined in Derived class\&. All the other methods are mandatory\&.
.sp .5v
.RE

.PP \fBSee Also:\fR.PP \'Making a custom type_index\' section for more information about creating your own type_index using type_index_facade\&.
.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Derived
.fi

.sp
Class derived from type_index_facade\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename TypeInfo
.fi

.sp
Class that will be used as a base type_info class\&.
.RE

.SS "type_index_facade public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
const char * name() const noexcept;
.fi

.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined in Derived class\&. Overrides
\fBmust\fR
not throw\&.
.PP
Returns:
.RS 4
Name of a type\&. By default returns Derived::raw_name()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
std::string pretty_name() const;
.fi

.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined in Derived class\&. Overrides may throw\&.
.PP
Returns:
.RS 4
Human readable type name\&. By default returns Derived::name()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool equal(const Derived & rhs) const noexcept;
.fi

.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined in Derived class\&. Overrides
\fBmust\fR
not throw\&.
.PP
Returns:
.RS 4
True if two types are equal\&. By default compares types by raw_name()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
bool before(const Derived & rhs) const noexcept;
.fi

.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined in Derived class\&. Overrides
\fBmust\fR
not throw\&.
.PP
Returns:
.RS 4
True if rhs is greater than this\&. By default compares types by raw_name()\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
std::size_t hash_code() const noexcept;
.fi

.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined in Derived class\&. Overrides
\fBmust\fR
not throw\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
<boost/functional/hash\&.hpp> has to be included if this function is used\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
Hash code of a type\&. By default hashes types by raw_name()\&.
.RE
.RE

.SS "type_index_facade protected member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
const char * raw_name() const noexcept;
.fi

.sp
\fBOverride:\fR
This function
\fBmust\fR
be redefined in Derived class\&. Overrides
\fBmust\fR
not throw\&.
.PP
Returns:
.RS 4
Pointer to unredable/raw type name\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
const type_info_t & type_info() const noexcept;
.fi

.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined in Derived class\&. Overrides
\fBmust\fR
not throw\&.
.PP
Returns:
.RS 4
Const reference to underlying low level type_info_t\&.
.RE
.RE

.SS "type_index_facade protected static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename T> static Derived type_id() noexcept;
.fi

.sp
This is a factory method that is used to create instances of Derived classes\&. boost::typeindex::type_id() will call this method, if Derived has same type as boost::typeindex::type_index\&.
.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined and made public in Derived class\&. Overrides
\fBmust\fR
not throw\&. Overrides
\fBmust\fR
remove const, volatile && and & modifiers from T\&.
.PP
Template Parameters:
.RS 4
.PP
T
.RS 4
Type for which type_index must be created\&.
.RE
.RE
.PP
Returns:
.RS 4
type_index for type T\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename T> static Derived type_id_with_cvr() noexcept;
.fi

.sp
This is a factory method that is used to create instances of Derived classes\&. boost::typeindex::type_id_with_cvr() will call this method, if Derived has same type as boost::typeindex::type_index\&.
.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined and made public in Derived class\&. Overrides
\fBmust\fR
not throw\&. Overrides
\fBmust\fR
\fBnot\fR
remove const, volatile && and & modifiers from T\&.
.PP
Template Parameters:
.RS 4
.PP
T
.RS 4
Type for which type_index must be created\&.
.RE
.RE
.PP
Returns:
.RS 4
type_index for type T\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename T> 
  static Derived type_id_runtime(const T & variable) noexcept;
.fi

.sp
This is a factory method that is used to create instances of Derived classes\&. boost::typeindex::type_id_runtime(const T&) will call this method, if Derived has same type as boost::typeindex::type_index\&.
.sp
\fBOverride:\fR
This function
\fBmay\fR
be redefined and made public in Derived class\&.
.PP
Parameters:
.RS 4
.PP
variable
.RS 4
Variable which runtime type will be stored in type_index\&.
.RE
.RE
.PP
Returns:
.RS 4
type_index with runtime type of variable\&.
.RE
.RE


