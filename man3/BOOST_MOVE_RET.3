.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_MOVE_R" 3 "" "" ""
.SH "NAME"
BOOST_MOVE_RET
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/move/core\&.hpp>

BOOST_MOVE_RET(RET_TYPE, REF)
.fi
.SH "DESCRIPTION"
.PP
This macro is used to achieve portable move return semantics\&. The C++11 Standard allows implicit move returns when the object to be returned is designated by a lvalue and:
.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The criteria for elision of a copy operation are met OR
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The criteria would be met save for the fact that the source object is a function parameter
.RE
.sp
.RE

.PP
For C++11 conforming compilers this macros only yields to REF:
return BOOST_MOVE_RET(RET_TYPE, REF);
\->
return REF;
.PP
For compilers without rvalue references this macro does an explicit move if the move emulation is activated and the return type (RET_TYPE) is not a reference\&.
.PP
For non\-conforming compilers with rvalue references like Visual 2010 & 2012, an explicit move is performed if RET_TYPE is not a reference\&.
.PP
\fBCaution\fR: When using this macro in non\-conforming or C++03 compilers, a move will be performed even if the C++11 standard does not allow it (e\&.g\&. returning a static variable)\&. The user is responsible for using this macro only to return local objects that met C++11 criteria\&.

