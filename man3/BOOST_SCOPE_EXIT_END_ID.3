.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_SC" 3 "" "" ""
.SH "NAME"
BOOST_SCOPE_EXIT_END_ID \- This macro allows to terminate multiple scope exit bodies on the same line\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/scope_exit\&.hpp>

BOOST_SCOPE_EXIT_END_ID(id)
.fi
.SH "DESCRIPTION"
.PP
This macro is equivalent to
BOOST_SCOPE_EXIT_END
but it can be expanded multiple times on the same line if different identifiers
id
are provided for each expansion (see
BOOST_SCOPE_EXIT_END
for more information)\&.
.PP
\fBParameters:\fR
.TS
allbox tab(:);
l l.
T{
\fBid\fR
T}:T{
A unique identifier token which can be concatenated by the preprocessor (__LINE__, scope_exit_number_1_on_line_123, a combination of alphanumeric tokens, etc)\&.
T}
.TE
.sp 1

.PP
\fBNote:\fR
This macro can be useful when the scope exit macros are expanded within user\-defined macros (because macros all expand on the same line)\&. On some compilers (e\&.g\&., MSVC which supports the non standard
__COUNTER__
macro) it might not be necessary to use this macro but the use of this macro is always necessary to ensure portability when expanding multiple scope exit macros on the same line (because this library can only portably use
__LINE__
to internally generate unique identifiers)\&.
.PP
\fBSee:\fR
BOOST_SCOPE_EXIT_ID,
BOOST_SCOPE_EXIT_ID_TPL,
BOOST_SCOPE_EXIT_END\&.

