.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_PROT" 3 "" "" ""
.SH "NAME"
BOOST_PROTO_EXTENDS \- For creating expression wrappers that add behaviors to a Proto expression template, like proto::extends<>, but while retaining POD\-ness of the expression wrapper\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/extends\&.hpp>

BOOST_PROTO_EXTENDS(Expr, Derived, Domain)
.fi
.SH "DESCRIPTION"
.PP
Equivalent to:

.sp
.if n \{\
.RS 4
.\}
.nf
BOOST_PROTO_BASIC_EXTENDS(Expr, Derived, Domain)
BOOST_PROTO_EXTENDS_ASSIGN()
BOOST_PROTO_EXTENDS_SUBSCRIPT()
BOOST_PROTO_EXTENDS_FUNCTION()
.fi
.if n \{\
.RE
.\}
.sp

.PP
If the
Domain
parameter is dependent, you can specify it as
typename Domain, as in
BOOST_PROTO_EXTENDS(Expr, Derived, typename Domain)
.PP

\fBExample:\fR
.sp
.if n \{\
.RS 4
.\}
.nf
template< class Expr >
struct my_expr;

struct my_domain
  : proto::domain< proto::pod_generator< my_expr > >
{};

template< class Expr >
struct my_expr
{
    // OK, this makes my_expr<> a valid Proto expression extension\&.
    // my_expr<> has overloaded assignment, subscript,
    // and function call operators that build expression templates\&.
    BOOST_PROTO_EXTENDS(Expr, my_expr, my_domain)
};

// OK, my_expr<> is POD, so this is statically initialized:
my_expr< proto::terminal<int>::type > const _1 = {{1}};
.fi
.if n \{\
.RE
.\}
.sp


