.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS NAMED_SHA" 3 "" "" ""
.SH "NAME"
boost::interprocess::named_sharable_mutex
.SH "SYNOPSIS"
.\" unlock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: unlock_sharable
.\" unlock: Class named_sharable_mutex
.\" Class named_sharable_mutex: unlock
.\" try_lock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: try_lock_sharable
.\" try_lock: Class named_sharable_mutex
.\" Class named_sharable_mutex: try_lock
.\" timed_lock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: timed_lock_sharable
.\" timed_lock: Class named_sharable_mutex
.\" Class named_sharable_mutex: timed_lock
.\" remove: Class named_sharable_mutex
.\" Class named_sharable_mutex: remove
.\" named_sharable_mutex: Class named_sharable_mutex
.\" Class named_sharable_mutex: named_sharable_mutex
.\" named_sharable_mutex: Class named_sharable_mutex
.\" Class named_sharable_mutex: named_sharable_mutex
.\" lock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: lock_sharable
.\" lock: Class named_sharable_mutex
.\" Class named_sharable_mutex: lock

.sp
.nf
// In header: <boost/interprocess/sync/named_sharable_mutex\&.hpp>


class named_sharable_mutex {
public:
  // construct/copy/destruct
  named_sharable_mutex(create_only_t, const char *, 
                       const permissions & = permissions());
  named_sharable_mutex(open_or_create_t, const char *, 
                       const permissions & = permissions());
  named_sharable_mutex(open_only_t, const char *);
  ~named_sharable_mutex();

  // public member functions
  void lock();
  bool try_lock();
  bool timed_lock(const boost::posix_time::ptime &);
  void unlock();
  void lock_sharable();
  bool try_lock_sharable();
  bool timed_lock_sharable(const boost::posix_time::ptime &);
  void unlock_sharable();

  // public static functions
  static bool remove(const char *);
};
.fi
.SH "DESCRIPTION"
.PP
A sharable mutex with a global name, so it can be found from different processes\&. This mutex can\'t be placed in shared memory, and each process should have it\'s own named sharable mutex\&.
.SS "named_sharable_mutex public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
named_sharable_mutex(create_only_t create_only, const char * name, 
                     const permissions & perm = permissions());
.fi

.sp
Creates a global sharable mutex with a name\&. If the sharable mutex can\'t be created throws
interprocess_exception
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" named_sharable_mutex: Class named_sharable_mutex
.\" Class named_sharable_mutex: named_sharable_mutex

.sp

.nf
named_sharable_mutex(open_or_create_t open_or_create, const char * name, 
                     const permissions & perm = permissions());
.fi

.sp
Opens or creates a global sharable mutex with a name\&. If the sharable mutex is created, this call is equivalent to
named_sharable_mutex(create_only_t, \&.\&.\&.) If the sharable mutex is already created, this call is equivalent to
named_sharable_mutex(open_only_t, \&.\&.\&. )\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
named_sharable_mutex(open_only_t open_only, const char * name);
.fi

.sp
Opens a global sharable mutex with a name if that sharable mutex is previously\&. created\&. If it is not previously created this function throws
interprocess_exception\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" remove: Class named_sharable_mutex
.\" Class named_sharable_mutex: remove

.sp

.nf
~named_sharable_mutex();
.fi

.sp
Destroys *this and indicates that the calling process is finished using the resource\&. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource\&. The resource can still be opened again calling the open constructor overload\&. To erase the resource from the system use remove()\&.
.RE

.SS "named_sharable_mutex public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" lock: Class named_sharable_mutex
.\" Class named_sharable_mutex: lock

.sp

.nf
void lock();
.fi

.sp
Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive or sharable ownership of the mutex, it waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" try_lock: Class named_sharable_mutex
.\" Class named_sharable_mutex: try_lock

.sp

.nf
bool try_lock();
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting\&. If no other thread has exclusive or sharable ownership of the mutex this succeeds\&. Returns: If it can acquire exclusive ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" timed_lock: Class named_sharable_mutex
.\" Class named_sharable_mutex: timed_lock

.sp

.nf
bool timed_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, or sharable ownership of the mutex or abs_time is reached\&. Returns: If acquires exclusive ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlock: Class named_sharable_mutex
.\" Class named_sharable_mutex: unlock

.sp

.nf
void unlock();
.fi

.sp
Precondition: The thread must have exclusive ownership of the mutex\&. Effects: The calling thread releases the exclusive ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" lock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: lock_sharable

.sp

.nf
void lock_sharable();
.fi

.sp
Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" try_lock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: try_lock_sharable

.sp

.nf
bool try_lock_sharable();
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting\&. If no other thread has exclusive ownership of the mutex this succeeds\&. Returns: If it can acquire sharable ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" timed_lock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: timed_lock_sharable

.sp

.nf
bool timed_lock_sharable(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached\&. Returns: If acquires sharable ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" unlock_sharable: Class named_sharable_mutex
.\" Class named_sharable_mutex: unlock_sharable

.sp

.nf
void unlock_sharable();
.fi

.sp
Precondition: The thread must have sharable ownership of the mutex\&. Effects: The calling thread releases the sharable ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE

.SS "named_sharable_mutex public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" remove: Class named_sharable_mutex
.\" Class named_sharable_mutex: remove

.sp

.nf
static bool remove(const char * name);
.fi

.sp
Erases a named sharable mutex from the system\&. Returns false on error\&. Never throws\&.
.RE


