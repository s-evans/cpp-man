.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEXT_FILE_B" 3 "" "" ""
.SH "NAME"
boost::log::sinks::text_file_backend \- An implementation of a text file logging sink backend\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/sinks/text_file_backend\&.hpp>


class text_file_backend : public basic_formatted_sink_backend< char, combine_requirements< synchronized_feeding, flushing >::type >
{
public:
  // types
  typedef base_type::char_type            char_type;                      // Character type\&. 
  typedef base_type::string_type          string_type;                    // String type to be used as a message text holder\&. 
  typedef std::basic_ostream< char_type > stream_type;                    // Stream type\&. 
  typedef \fIunspecified\fR                     open_handler_type;              // File open handler\&. 
  typedef \fIunspecified\fR                     close_handler_type;             // File close handler\&. 
  typedef \fIunspecified\fR                     time_based_rotation_predicate;  // Predicate that defines the time\-based condition for file rotation\&. 

  // construct/copy/destruct
  text_file_backend();
  template<typename\&.\&.\&. ArgsT> explicit text_file_backend(ArgsT\&.\&.\&.const &);
  ~text_file_backend();

  // public member functions
  template<typename PathT> void set_file_name_pattern(PathT const &);
  void set_open_mode(std::ios_base::openmode);
  void set_file_collector(shared_ptr< file::collector > const &);
  void set_open_handler(open_handler_type const &);
  void set_close_handler(close_handler_type const &);
  void set_rotation_size(uintmax_t);
  void set_time_based_rotation(time_based_rotation_predicate const &);
  void auto_flush(bool = true);
  uintmax_t scan_for_files(file::scan_method = file::scan_matching, 
                           bool = true);
  void consume(record_view const &, string_type const &);
  void flush();
  void rotate_file();
};
.fi
.SH "DESCRIPTION"
.PP
The sink backend puts formatted log records to a text file\&. The sink supports file rotation and advanced file control, such as size and file count restriction\&.
.SS "text_file_backend public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
text_file_backend();
.fi

.sp
Default constructor\&. The constructed sink backend uses default values of all the parameters\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename\&.\&.\&. ArgsT> explicit text_file_backend(ArgsT\&.\&.\&.const & args);
.fi

.sp
Constructor\&. Creates a sink backend with the specified named parameters\&. The following named parameters are supported:
.sp

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
file_name
\- Specifies the file name pattern where logs are actually written to\&. The pattern may contain directory and file name portions, but only the file name may contain placeholders\&. The backend supports Boost\&.DateTime placeholders for injecting current time and date into the file name\&. Also, an additional N placeholder is supported, it will be replaced with an integral increasing file counter\&. The placeholder may also contain width specification in the printf\-compatible form (e\&.g\&. %5N)\&. The printed file counter will always be zero\-filled\&. If
file_name
is not specified, pattern "%5N\&.log" will be used\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
open_mode
\- File open mode\&. The mode should be presented in form of mask compatible to
std::ios_base::openmode\&. If not specified,
trunc | out
will be used\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rotation_size
\- Specifies the approximate size, in characters written, of the temporary file upon which the file is passed to the file collector\&. Note the size does not count any possible character conversions that may take place during writing to the file\&. If not specified, the file won\'t be rotated upon reaching any size\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
time_based_rotation
\- Specifies the predicate for time\-based file rotation\&. No time\-based file rotations will be performed, if not specified\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
auto_flush
\- Specifies a flag, whether or not to automatically flush the file after each written log record\&. By default, is
false\&.
.RE
.RS 4

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Read the caution note regarding file name pattern in the
sinks::file::collector::scan_for_files
documentation\&.
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
~text_file_backend();
.fi

.sp
Destructor
.RE

.SS "text_file_backend public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename PathT> void set_file_name_pattern(PathT const & pattern);
.fi

.sp
The method sets file name wildcard for the files being written\&. The wildcard supports date and time injection into the file name\&.
.sp

.PP
Parameters:
.RS 4
.PP
pattern
.RS 4
The name pattern for the file being written\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void set_open_mode(std::ios_base::openmode mode);
.fi

.sp
The method sets the file open mode
.sp

.PP
Parameters:
.RS 4
.PP
mode
.RS 4
File open mode
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void set_file_collector(shared_ptr< file::collector > const & collector);
.fi

.sp
The method sets the log file collector function\&. The function is called on file rotation and is being passed the written file name\&.
.sp

.PP
Parameters:
.RS 4
.PP
collector
.RS 4
The file collector function object
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void set_open_handler(open_handler_type const & handler);
.fi

.sp
The method sets file opening handler\&. The handler will be called every time the backend opens a new temporary file\&. The handler may write a header to the opened file in order to maintain file validity\&.
.sp

.PP
Parameters:
.RS 4
.PP
handler
.RS 4
The file open handler function object
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void set_close_handler(close_handler_type const & handler);
.fi

.sp
The method sets file closing handler\&. The handler will be called every time the backend closes a temporary file\&. The handler may write a footer to the opened file in order to maintain file validity\&.
.sp

.PP
Parameters:
.RS 4
.PP
handler
.RS 4
The file close handler function object
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void set_rotation_size(uintmax_t size);
.fi

.sp
The method sets maximum file size\&. When the size is reached, file rotation is performed\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The size does not count any possible character translations that may happen in the underlying API\&. This may result in greater actual sizes of the written files\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
size
.RS 4
The maximum file size, in characters\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
void set_time_based_rotation(time_based_rotation_predicate const & predicate);
.fi

.sp
The method sets the predicate that defines the time\-based condition for file rotation\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The rotation always occurs on writing a log record, so the rotation is not strictly bound to the specified condition\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
predicate
.RS 4
The predicate that defines the time\-based condition for file rotation\&. If empty, no time\-based rotation will take place\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
void auto_flush(bool f = true);
.fi

.sp
Sets the flag to automatically flush buffers of all attached streams after each log record
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
uintmax_t scan_for_files(file::scan_method method = file::scan_matching, 
                         bool update_counter = true);
.fi

.sp
Performs scanning of the target directory for log files that may have been left from previous runs of the application\&. The found files are considered by the file collector as if they were rotated\&.
.sp
The file scan can be performed in two ways: either all files in the target directory will be considered as log files, or only those files that satisfy the file name pattern\&. See documentation on
sinks::file::collector::scan_for_files
for more information\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The method essentially delegates to the same\-named function of the file collector\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
method
.RS 4
File scanning method
.RE
.PP
update_counter
.RS 4
If
true
and
\fImethod\fR
is
scan_matching, the method attempts to update the internal file counter according to the found files\&. The counter is unaffected otherwise\&.
.RE
.RE
.PP
Requires:
.RS 4
File collector and the proper file name pattern have already been set\&.
.RE
.PP
Returns:
.RS 4
The number of files found\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
void consume(record_view const & rec, string_type const & formatted_message);
.fi

.sp
The method writes the message to the sink
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
void flush();
.fi

.sp
The method flushes the currently open log file
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
void rotate_file();
.fi

.sp
The method rotates the file
.RE


