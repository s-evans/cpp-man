.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE SLI" 3 "" "" ""
.SH "NAME"
boost::intrusive::slist
.SH "SYNOPSIS"
.\" value_type: Class template slist
.\" Class template slist: value_type
.\" value_traits: Class template slist
.\" Class template slist: value_traits
.\" unique_and_dispose: Class template slist
.\" Class template slist: unique_and_dispose
.\" unique: Class template slist
.\" Class template slist: unique
.\" swap: Class template slist
.\" Class template slist: swap
.\" splice_after: Class template slist
.\" Class template slist: splice_after
.\" splice: Class template slist
.\" Class template slist: splice
.\" sort: Class template slist
.\" Class template slist: sort
.\" size_type: Class template slist
.\" Class template slist: size_type
.\" size: Class template slist
.\" Class template slist: size
.\" shift_forward: Class template slist
.\" Class template slist: shift_forward
.\" shift_backwards: Class template slist
.\" Class template slist: shift_backwards
.\" s_iterator_to: Class template slist
.\" Class template slist: s_iterator_to
.\" reverse: Class template slist
.\" Class template slist: reverse
.\" remove_if: Class template slist
.\" Class template slist: remove_if
.\" remove_and_dispose_if: Class template slist
.\" Class template slist: remove_and_dispose_if
.\" remove_and_dispose: Class template slist
.\" Class template slist: remove_and_dispose
.\" remove: Class template slist
.\" Class template slist: remove
.\" reference: Class template slist
.\" Class template slist: reference
.\" push_front: Class template slist
.\" Class template slist: push_front
.\" push_back: Class template slist
.\" Class template slist: push_back
.\" priv_swap_lists: Class template slist
.\" Class template slist: priv_swap_lists
.\" priv_swap_cache_last: Class template slist
.\" Class template slist: priv_swap_cache_last
.\" priv_splice_after: Class template slist
.\" Class template slist: priv_splice_after
.\" priv_shift_forward: Class template slist
.\" Class template slist: priv_shift_forward
.\" priv_shift_backwards: Class template slist
.\" Class template slist: priv_shift_backwards
.\" priv_reverse: Class template slist
.\" Class template slist: priv_reverse
.\" priv_incorporate_after: Class template slist
.\" Class template slist: priv_incorporate_after
.\" priv_container_from_end_iterator: Class template slist
.\" Class template slist: priv_container_from_end_iterator
.\" previous: Class template slist
.\" Class template slist: previous
.\" pop_front_and_dispose: Class template slist
.\" Class template slist: pop_front_and_dispose
.\" pop_front: Class template slist
.\" Class template slist: pop_front
.\" pointer: Class template slist
.\" Class template slist: pointer
.\" node_traits: Class template slist
.\" Class template slist: node_traits
.\" node_ptr: Class template slist
.\" Class template slist: node_ptr
.\" node_algorithms: Class template slist
.\" Class template slist: node_algorithms
.\" node: Class template slist
.\" Class template slist: node
.\" merge: Class template slist
.\" Class template slist: merge
.\" last: Class template slist
.\" Class template slist: last
.\" iterator_to: Class template slist
.\" Class template slist: iterator_to
.\" iterator: Class template slist
.\" Class template slist: iterator
.\" insert_after: Class template slist
.\" Class template slist: insert_after
.\" insert: Class template slist
.\" Class template slist: insert
.\" header_holder_type: Class template slist
.\" Class template slist: header_holder_type
.\" front: Class template slist
.\" Class template slist: front
.\" erase_and_dispose: Class template slist
.\" Class template slist: erase_and_dispose
.\" erase_after_and_dispose: Class template slist
.\" Class template slist: erase_after_and_dispose
.\" erase_after: Class template slist
.\" Class template slist: erase_after
.\" erase: Class template slist
.\" Class template slist: erase
.\" end: Class template slist
.\" Class template slist: end
.\" dispose_and_assign: Class template slist
.\" Class template slist: dispose_and_assign
.\" difference_type: Class template slist
.\" Class template slist: difference_type
.\" container_from_end_iterator: Class template slist
.\" Class template slist: container_from_end_iterator
.\" const_reference: Class template slist
.\" Class template slist: const_reference
.\" const_pointer: Class template slist
.\" Class template slist: const_pointer
.\" const_node_ptr: Class template slist
.\" Class template slist: const_node_ptr
.\" const_iterator: Class template slist
.\" Class template slist: const_iterator
.\" clone_from: Class template slist
.\" Class template slist: clone_from
.\" clear_and_dispose: Class template slist
.\" Class template slist: clear_and_dispose
.\" clear: Class template slist
.\" Class template slist: clear
.\" check: Class template slist
.\" Class template slist: check
.\" cend: Class template slist
.\" Class template slist: cend
.\" cbegin: Class template slist
.\" Class template slist: cbegin
.\" begin: Class template slist
.\" Class template slist: begin
.\" before_begin: Class template slist
.\" Class template slist: before_begin
.\" back: Class template slist
.\" Class template slist: back
.\" assign: Class template slist
.\" Class template slist: assign

.sp
.nf
// In header: <boost/intrusive/slist\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class slist {
public:
  // types
  typedef ValueTraits                                value_traits;      
  typedef value_traits::pointer                      pointer;           
  typedef value_traits::const_pointer                const_pointer;     
  typedef pointer_traits< pointer >::element_type    value_type;        
  typedef pointer_traits< pointer >::reference       reference;         
  typedef pointer_traits< const_pointer >::reference const_reference;   
  typedef pointer_traits< pointer >::difference_type difference_type;   
  typedef SizeType                                   size_type;         
  typedef slist_iterator< value_traits, false >      iterator;          
  typedef slist_iterator< value_traits, true >       const_iterator;    
  typedef value_traits::node_traits                  node_traits;       
  typedef node_traits::node                          node;              
  typedef node_traits::node_ptr                      node_ptr;          
  typedef node_traits::const_node_ptr                const_node_ptr;    
  typedef \fIunspecified\fR                                header_holder_type;
  typedef \fIunspecified\fR                                node_algorithms;   

  // construct/copy/destruct
  explicit slist(const value_traits & = value_traits());
  template<typename Iterator> 
    slist(Iterator, Iterator, const value_traits & = value_traits());
  slist(slist &&);
  slist & operator=(slist &&);
  ~slist();

  // public member functions
  void clear();
  template<typename Disposer> void clear_and_dispose(Disposer);
  void push_front(reference);
  void push_back(reference);
  void pop_front();
  template<typename Disposer> void pop_front_and_dispose(Disposer);
  reference front();
  const_reference front() const;
  reference back();
  const_reference back() const;
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  iterator before_begin();
  const_iterator before_begin() const;
  const_iterator cbefore_begin() const;
  iterator last();
  const_iterator last() const;
  const_iterator clast() const;
  size_type size() const;
  bool empty() const;
  void swap(slist &);
  void shift_backwards(size_type = 1);
  void shift_forward(size_type = 1);
  template<typename Cloner, typename Disposer> 
    void clone_from(const slist &, Cloner, Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(slist &&, Cloner, Disposer);
  iterator insert_after(const_iterator, reference);
  template<typename Iterator> 
    void insert_after(const_iterator, Iterator, Iterator);
  iterator insert(const_iterator, reference);
  template<typename Iterator> void insert(const_iterator, Iterator, Iterator);
  iterator erase_after(const_iterator);
  iterator erase_after(const_iterator, const_iterator);
  iterator erase_after(const_iterator, const_iterator, size_type);
  iterator erase(const_iterator);
  iterator erase(const_iterator, const_iterator);
  iterator erase(const_iterator, const_iterator, size_type);
  template<typename Disposer> 
    iterator erase_after_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    iterator erase_after_and_dispose(const_iterator, const_iterator, Disposer);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, const_iterator, Disposer);
  template<typename Iterator> void assign(Iterator, Iterator);
  template<typename Iterator, typename Disposer> 
    void dispose_and_assign(Disposer, Iterator, Iterator);
  void splice_after(const_iterator, slist &, const_iterator * = 0);
  void splice_after(const_iterator, slist &, const_iterator);
  void splice_after(const_iterator, slist &, const_iterator, const_iterator);
  void splice_after(const_iterator, slist &, const_iterator, const_iterator, 
                    size_type);
  void splice(const_iterator, slist &, const_iterator * = 0);
  void splice(const_iterator, slist &, const_iterator);
  void splice(const_iterator, slist &, const_iterator, const_iterator);
  void splice(const_iterator, slist &, const_iterator, const_iterator, 
              size_type);
  template<typename Predicate> void sort(Predicate);
  void sort();
  template<typename Predicate> 
    void merge(slist &, Predicate, const_iterator * = 0);
  void merge(slist &);
  void reverse();
  void remove(const_reference);
  template<typename Disposer> 
    void remove_and_dispose(const_reference, Disposer);
  template<typename Pred> void remove_if(Pred);
  template<typename Pred, typename Disposer> 
    void remove_and_dispose_if(Pred, Disposer);
  void unique();
  template<typename BinaryPredicate> void unique(BinaryPredicate);
  template<typename Disposer> void unique_and_dispose(Disposer);
  template<typename BinaryPredicate, typename Disposer> 
    void unique_and_dispose(BinaryPredicate, Disposer);
  iterator iterator_to(reference);
  const_iterator iterator_to(const_reference) const;
  iterator previous(iterator);
  const_iterator previous(const_iterator) const;
  iterator previous(const_iterator, iterator);
  const_iterator previous(const_iterator, const_iterator) const;
  void check() const;

  // public static functions
  static slist & container_from_end_iterator(iterator);
  static const slist & container_from_end_iterator(const_iterator);
  static iterator s_iterator_to(reference);
  static const_iterator s_iterator_to(const_reference);

  // private member functions
  void priv_splice_after(const node_ptr &, slist &, const node_ptr &, 
                         const node_ptr &);
  void priv_incorporate_after(const node_ptr &, const node_ptr &, 
                              const node_ptr &);
  void priv_reverse(\fIunspecified\fR);
  void priv_reverse(\fIunspecified\fR);
  void priv_shift_backwards(size_type, \fIunspecified\fR);
  void priv_shift_backwards(size_type, \fIunspecified\fR);
  void priv_shift_forward(size_type, \fIunspecified\fR);
  void priv_shift_forward(size_type, \fIunspecified\fR);

  // private static functions
  static void priv_swap_cache_last(slist *, slist *);
  static void priv_swap_lists(const node_ptr &, const node_ptr &, \fIunspecified\fR);
  static void priv_swap_lists(const node_ptr &, const node_ptr &, \fIunspecified\fR);
  static slist & priv_container_from_end_iterator(const const_iterator &);

  // public data members
  static const bool constant_time_size;
  static const bool stateful_value_traits;
  static const bool linear;
  static const bool cache_last;
  static const bool has_container_from_iterator;
};
.fi
.SH "DESCRIPTION"
.\" previous: Class template slist
.\" Class template slist: previous
.PP
The class template slist is an intrusive container, that encapsulates a singly\-linked list\&. You can use such a list to squeeze the last bit of performance from your application\&. Unfortunately, the little gains come with some huge drawbacks\&. A lot of member functions can\'t be implemented as efficiently as for standard containers\&. To overcome this limitation some other member functions with rather unusual semantics have to be introduced\&.
.PP
The template parameter
T
is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
base_hook<>/member_hook<>/value_traits<>,
constant_time_size<>,
size_type<>,
linear<>
and
cache_last<>\&.
.PP
The iterators of slist are forward iterators\&. slist provides a static function called "previous" to compute the previous iterator of a given iterator\&. This function has linear complexity\&. To improve the usability esp\&. with the \'*_after\' functions, ++end() == begin() and previous(begin()) == end() are defined\&. An new special function "before_begin()" is defined, which returns an iterator that points one less the beginning of the list: ++before_begin() == begin()
.SS "slist public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit slist(const value_traits & v_traits = value_traits());
.fi

.sp
\fBEffects\fR: constructs an empty list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" distance: Class template slist
.\" Class template slist: distance

.sp

.nf
template<typename Iterator> 
  slist(Iterator b, Iterator e, 
        const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Constructs a list equal to [b ,e)\&.
.sp
\fBComplexity\fR: Linear in distance(b, e)\&. No copy constructors are called\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
slist(slist && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
slist & operator=(slist && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~slist();
.fi

.sp
\fBEffects\fR: If it\'s a safe\-mode or auto\-unlink value, the destructor does nothing (ie\&. no code is generated)\&. Otherwise it detaches all elements from this\&. In this case the objects in the list are not deleted (i\&.e\&. no destructors are called), but the hooks according to the
value_traits
template parameter are set to their default value\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the list, if it\'s a safe\-mode or auto\-unlink value\&. Otherwise constant\&.
.RE

.SS "slist public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" clear: Class template slist
.\" Class template slist: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all the elements of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements of the list\&. if it\'s a safe\-mode or auto\-unlink value_type\&. Constant time otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" clear_and_dispose: Class template slist
.\" Class template slist: clear_and_dispose

.sp

.nf
template<typename Disposer> void clear_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements of the container Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements of the list\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" push_front: Class template slist
.\" Class template slist: push_front

.sp

.nf
void push_front(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue\&.
.sp
\fBEffects\fR: Inserts the value in the front of the list\&. No copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" push_back: Class template slist
.\" Class template slist: push_back

.sp

.nf
void push_back(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue\&.
.sp
\fBEffects\fR: Inserts the value in the back of the list\&. No copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. This function is only available is cache_last<> is true\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" pop_front: Class template slist
.\" Class template slist: pop_front

.sp

.nf
void pop_front();
.fi

.sp
\fBEffects\fR: Erases the first element of the list\&. No destructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" pop_front_and_dispose: Class template slist
.\" Class template slist: pop_front_and_dispose

.sp

.nf
template<typename Disposer> void pop_front_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the first element of the list\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" front: Class template slist
.\" Class template slist: front

.sp

.nf
reference front();
.fi

.sp
\fBEffects\fR: Returns a reference to the first element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" front: Class template slist
.\" Class template slist: front

.sp

.nf
const_reference front() const;
.fi

.sp
\fBEffects\fR: Returns a const_reference to the first element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" back: Class template slist
.\" Class template slist: back

.sp

.nf
reference back();
.fi

.sp
\fBEffects\fR: Returns a reference to the last element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. This function is only available is cache_last<> is true\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" back: Class template slist
.\" Class template slist: back

.sp

.nf
const_reference back() const;
.fi

.sp
\fBEffects\fR: Returns a const_reference to the last element of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. This function is only available is cache_last<> is true\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" begin: Class template slist
.\" Class template slist: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" begin: Class template slist
.\" Class template slist: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" cbegin: Class template slist
.\" Class template slist: cbegin

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" cend: Class template slist
.\" Class template slist: cend

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" before_begin: Class template slist
.\" Class template slist: before_begin

.sp

.nf
iterator before_begin();
.fi

.sp
\fBEffects\fR: Returns an iterator that points to a position before the first element\&. Equivalent to "end()"
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" before_begin: Class template slist
.\" Class template slist: before_begin

.sp

.nf
const_iterator before_begin() const;
.fi

.sp
\fBEffects\fR: Returns an iterator that points to a position before the first element\&. Equivalent to "end()"
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
const_iterator cbefore_begin() const;
.fi

.sp
\fBEffects\fR: Returns an iterator that points to a position before the first element\&. Equivalent to "end()"
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" last: Class template slist
.\" Class template slist: last

.sp

.nf
iterator last();
.fi

.sp
\fBEffects\fR: Returns an iterator to the last element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: This function is present only if cached_last<> option is true\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" last: Class template slist
.\" Class template slist: last

.sp

.nf
const_iterator last() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the last element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: This function is present only if cached_last<> option is true\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
const_iterator clast() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the last element contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: This function is present only if cached_last<> option is true\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" size: Class template slist
.\" Class template slist: size

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements contained in the list\&. if
constant_time_size
is false\&. Constant time otherwise\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the list contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" swap: Class template slist
.\" Class template slist: swap

.sp

.nf
void swap(slist & other);
.fi

.sp
\fBEffects\fR: Swaps the elements of x and *this\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements of both lists\&. Constant\-time if linear<> and/or cache_last<> options are used\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" shift_backwards: Class template slist
.\" Class template slist: shift_backwards

.sp

.nf
void shift_backwards(size_type n = 1);
.fi

.sp
\fBEffects\fR: Moves backwards all the elements, so that the first element becomes the second, the second becomes the third\&.\&.\&. the last element becomes the first one\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements plus the number shifts\&.
.sp
\fBNote\fR: Iterators Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" shift_forward: Class template slist
.\" Class template slist: shift_forward

.sp

.nf
void shift_forward(size_type n = 1);
.fi

.sp
\fBEffects\fR: Moves forward all the elements, so that the second element becomes the first, the third becomes the second\&.\&.\&. the first element becomes the last one\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements plus the number shifts\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" clone_from: Class template slist
.\" Class template slist: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(const slist & src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" clone_from: Class template slist
.\" Class template slist: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(slist && src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" insert_after: Class template slist
.\" Class template slist: insert_after

.sp

.nf
iterator insert_after(const_iterator prev_p, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and prev_p must point to an element contained by the list or to end()\&.
.sp
\fBEffects\fR: Inserts the value after the position pointed by prev_p\&. No copy constructor is called\&.
.sp
\fBReturns\fR: An iterator to the inserted element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" insert_after: Class template slist
.\" Class template slist: insert_after

.sp

.nf
template<typename Iterator> 
  void insert_after(const_iterator prev_p, Iterator f, Iterator l);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type and prev_p must point to an element contained by the list or to the end node\&.
.sp
\fBEffects\fR: Inserts the [f, l) after the position prev_p\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" insert: Class template slist
.\" Class template slist: insert

.sp

.nf
iterator insert(const_iterator p, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and p must point to an element contained by the list or to end()\&.
.sp
\fBEffects\fR: Inserts the value before the position pointed by p\&. No copy constructor is called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before p\&. Constant\-time if cache_last<> is true and p == end()\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" insert: Class template slist
.\" Class template slist: insert

.sp

.nf
template<typename Iterator> 
  void insert(const_iterator p, Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type and p must point to an element contained by the list or to the end node\&.
.sp
\fBEffects\fR: Inserts the pointed by b and e before the position p\&. No copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted plus linear to the elements before b\&. Linear to the number of elements to insert if cache_last<> option is true and p == end()\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase_after: Class template slist
.\" Class template slist: erase_after

.sp

.nf
iterator erase_after(const_iterator prev);
.fi

.sp
\fBEffects\fR: Erases the element after the element pointed by prev of the list\&. No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" range: Class template slist
.\" Class template slist: range
.\" erase_after: Class template slist
.\" Class template slist: erase_after

.sp

.nf
iterator erase_after(const_iterator before_f, const_iterator l);
.fi

.sp
\fBEffects\fR: Erases the range (before_f, l) from the list\&. No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of erased elements if it\'s a safe\-mode , auto\-unlink value or constant\-time size is activated\&. Constant time otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" range: Class template slist
.\" Class template slist: range
.\" distance: Class template slist
.\" Class template slist: distance
.\" erase_after: Class template slist
.\" Class template slist: erase_after

.sp

.nf
iterator erase_after(const_iterator before_f, const_iterator l, size_type n);
.fi

.sp
\fBEffects\fR: Erases the range (before_f, l) from the list\&. n must be distance(before_f, l) \- 1\&. No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: constant\-time if
link_mode
is normal_link\&. Linear to the elements (l \- before_f) otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase: Class template slist
.\" Class template slist: erase

.sp

.nf
iterator erase(const_iterator i);
.fi

.sp
\fBEffects\fR: Erases the element pointed by i of the list\&. No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed element, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements before i\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase: Class template slist
.\" Class template slist: erase

.sp

.nf
iterator erase(const_iterator f, const_iterator l);
.fi

.sp
\fBRequires\fR: f and l must be valid iterator to elements in *this\&.
.sp
\fBEffects\fR: Erases the range pointed by b and e\&. No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements before l\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" distance: Class template slist
.\" Class template slist: distance
.\" erase: Class template slist
.\" Class template slist: erase

.sp

.nf
iterator erase(const_iterator f, const_iterator l, size_type n);
.fi

.sp
\fBEffects\fR: Erases the range [f, l) from the list\&. n must be distance(f, l)\&. No destructors are called\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: linear to the elements before f if
link_mode
is normal_link and
constant_time_size
is activated\&. Linear to the elements before l otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase_after_and_dispose: Class template slist
.\" Class template slist: erase_after_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_after_and_dispose(const_iterator prev, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element after the element pointed by prev of the list\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" range: Class template slist
.\" Class template slist: range
.\" erase_after_and_dispose: Class template slist
.\" Class template slist: erase_after_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_after_and_dispose(const_iterator before_f, const_iterator l, 
                                   Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the range (before_f, l) from the list\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Lineal to the elements (l \- before_f + 1)\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase_and_dispose: Class template slist
.\" Class template slist: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator i, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element pointed by i of the list\&. No destructors are called\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed element, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements before i\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" erase_and_dispose: Class template slist
.\" Class template slist: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator f, const_iterator l, 
                             Disposer disposer);
.fi

.sp
\fBRequires\fR: f and l must be valid iterator to elements in *this\&. Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the range pointed by b and e\&. No destructors are called\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: the first element remaining beyond the removed elements, or end() if no such element exists\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of erased elements plus linear to the elements before f\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" assign: Class template slist
.\" Class template slist: assign

.sp

.nf
template<typename Iterator> void assign(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Clears the list and inserts the range pointed by b and e\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted plus linear to the elements contained in the list if it\'s a safe\-mode or auto\-unlink value\&. Linear to the number of elements inserted in the list otherwise\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" dispose_and_assign: Class template slist
.\" Class template slist: dispose_and_assign

.sp

.nf
template<typename Iterator, typename Disposer> 
  void dispose_and_assign(Disposer disposer, Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Clears the list and inserts the range pointed by b and e\&. No destructors or copy constructors are called\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements inserted plus linear to the elements contained in the list\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" before_begin: Class template slist
.\" Class template slist: before_begin
.\" splice_after: Class template slist
.\" Class template slist: splice_after

.sp

.nf
void splice_after(const_iterator prev, slist & x, const_iterator * l = 0);
.fi

.sp
\fBRequires\fR: prev must point to an element contained by this list or to the before_begin() element
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, after the the element pointed by prev\&. No destructors or copy constructors are called\&.
.sp
\fBReturns\fR: Nothing\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: In general, linear to the elements contained in x\&. Constant\-time if cache_last<> option is true and also constant\-time if linear<> option is true "this" is empty and "l" is not used\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.sp
\fBAdditional note\fR: If the optional parameter "l" is provided, it will be assigned to the last spliced element or prev if x is empty\&. This iterator can be used as new "prev" iterator for a new splice_after call\&. that will splice new values after the previously spliced values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" before_begin: Class template slist
.\" Class template slist: before_begin
.\" splice_after: Class template slist
.\" Class template slist: splice_after

.sp

.nf
void splice_after(const_iterator prev_pos, slist & x, const_iterator prev_ele);
.fi

.sp
\fBRequires\fR: prev must point to an element contained by this list or to the before_begin() element\&. prev_ele must point to an element contained in list x or must be x\&.before_begin()\&.
.sp
\fBEffects\fR: Transfers the element after prev_ele, from list x to this list, after the element pointed by prev\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" before_begin: Class template slist
.\" Class template slist: before_begin
.\" splice_after: Class template slist
.\" Class template slist: splice_after

.sp

.nf
void splice_after(const_iterator prev_pos, slist & x, const_iterator before_f, 
                  const_iterator before_l);
.fi

.sp
\fBRequires\fR: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_f and before_l belong to x and ++before_f != x\&.end() && before_l != x\&.end()\&.
.sp
\fBEffects\fR: Transfers the range (before_f, before_l] from list x to this list, after the element pointed by prev_pos\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements transferred if
constant_time_size
is true\&. Constant\-time otherwise\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" before_begin: Class template slist
.\" Class template slist: before_begin
.\" splice_after: Class template slist
.\" Class template slist: splice_after

.sp

.nf
void splice_after(const_iterator prev_pos, slist & x, const_iterator before_f, 
                  const_iterator before_l, size_type n);
.fi

.sp
\fBRequires\fR: prev_pos must be a dereferenceable iterator in *this or be before_begin(), and before_f and before_l belong to x and ++before_f != x\&.end() && before_l != x\&.end() and n == distance(before_f, before_l)\&.
.sp
\fBEffects\fR: Transfers the range (before_f, before_l] from list x to this list, after the element pointed by p\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" splice: Class template slist
.\" Class template slist: splice

.sp

.nf
void splice(const_iterator it, slist & x, const_iterator * l = 0);
.fi

.sp
\fBRequires\fR: it is an iterator to an element in *this\&.
.sp
\fBEffects\fR: Transfers all the elements of list x to this list, before the the element pointed by it\&. No destructors or copy constructors are called\&.
.sp
\fBReturns\fR: Nothing\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements contained in x plus linear to the elements before it\&. Linear to the elements before it if cache_last<> option is true\&. Constant\-time if cache_last<> option is true and it == end()\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.sp
\fBAdditional note\fR: If the optional parameter "l" is provided, it will be assigned to the last spliced element or prev if x is empty\&. This iterator can be used as new "prev" iterator for a new splice_after call\&. that will splice new values after the previously spliced values\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" splice: Class template slist
.\" Class template slist: splice

.sp

.nf
void splice(const_iterator pos, slist & x, const_iterator elem);
.fi

.sp
\fBRequires\fR: it p must be a valid iterator of *this\&. elem must point to an element contained in list x\&.
.sp
\fBEffects\fR: Transfers the element elem, from list x to this list, before the element pointed by pos\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements before pos and before elem\&. Linear to the elements before elem if cache_last<> option is true and pos == end()\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" splice: Class template slist
.\" Class template slist: splice

.sp

.nf
void splice(const_iterator pos, slist & x, const_iterator f, const_iterator l);
.fi

.sp
\fBRequires\fR: pos must be a dereferenceable iterator in *this and f and f belong to x and f and f a valid range on x\&.
.sp
\fBEffects\fR: Transfers the range [f, l) from list x to this list, before the element pointed by pos\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the sum of elements before pos, f, and l plus linear to the number of elements transferred if
constant_time_size
is true\&. Linear to the sum of elements before f, and l plus linear to the number of elements transferred if
constant_time_size
is true if cache_last<> is true and pos == end()
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" splice: Class template slist
.\" Class template slist: splice

.sp

.nf
void splice(const_iterator pos, slist & x, const_iterator f, const_iterator l, 
            size_type n);
.fi

.sp
\fBRequires\fR: pos must be a dereferenceable iterator in *this and f and l belong to x and f and l a valid range on x\&. n == distance(f, l)\&.
.sp
\fBEffects\fR: Transfers the range [f, l) from list x to this list, before the element pointed by pos\&. No destructors or copy constructors are called\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the sum of elements before pos, f, and l\&. Linear to the sum of elements before f and l if cache_last<> is true and pos == end()\&.
.sp
\fBNote\fR: Iterators of values obtained from list x now point to elements of this list\&. Iterators of this list and all the references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" sort: Class template slist
.\" Class template slist: sort

.sp

.nf
template<typename Predicate> void sort(Predicate p);
.fi

.sp
\fBEffects\fR: This function sorts the list *this according to std::less<value_type>\&. The sort is stable, that is, the relative order of equivalent elements is preserved\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the predicate throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: The number of comparisons is approximately N log N, where N is the list\'s size\&.
.sp
\fBNote\fR: Iterators and references are not invalidated
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" size: Class template slist
.\" Class template slist: size
.\" sort: Class template slist
.\" Class template slist: sort

.sp

.nf
void sort();
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or std::less<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" end: Class template slist
.\" Class template slist: end
.\" size: Class template slist
.\" Class template slist: size
.\" merge: Class template slist
.\" Class template slist: merge

.sp

.nf
template<typename Predicate> 
  void merge(slist & x, Predicate p, const_iterator * l = 0);
.fi

.sp
\fBRequires\fR: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct\&.
.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBReturns\fR: Nothing\&.
.sp
\fBThrows\fR: If the predicate throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&.
.sp
\fBAdditional note\fR: If optional "l" argument is passed, it is assigned to an iterator to the last transferred value or end() is x is empty\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" size: Class template slist
.\" Class template slist: size
.\" merge: Class template slist
.\" Class template slist: merge

.sp

.nf
void merge(slist & x);
.fi

.sp
\fBEffects\fR: This function removes all of x\'s elements and inserts them in order into *this according to std::less<value_type>\&. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x\&.
.sp
\fBThrows\fR: if std::less<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: This function is linear time: it performs at most size() + x\&.size() \- 1 comparisons\&.
.sp
\fBNote\fR: Iterators and references are not invalidated
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" reverse: Class template slist
.\" Class template slist: reverse

.sp

.nf
void reverse();
.fi

.sp
\fBEffects\fR: Reverses the order of elements in the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: This function is linear to the contained elements\&.
.sp
\fBNote\fR: Iterators and references are not invalidated
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" size: Class template slist
.\" Class template slist: size
.\" size: Class template slist
.\" Class template slist: size
.\" remove: Class template slist
.\" Class template slist: remove

.sp

.nf
void remove(const_reference value);
.fi

.sp
\fBEffects\fR: Removes all the elements that compare equal to value\&. No destructors are called\&.
.sp
\fBThrows\fR: If std::equal_to<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&. This function is linear time: it performs exactly size() comparisons for equality\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" size: Class template slist
.\" Class template slist: size
.\" remove_and_dispose: Class template slist
.\" Class template slist: remove_and_dispose

.sp

.nf
template<typename Disposer> 
  void remove_and_dispose(const_reference value, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes all the elements that compare equal to value\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If std::equal_to<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" size: Class template slist
.\" Class template slist: size
.\" remove_if: Class template slist
.\" Class template slist: remove_if

.sp

.nf
template<typename Pred> void remove_if(Pred pred);
.fi

.sp
\fBEffects\fR: Removes all the elements for which a specified predicate is satisfied\&. No destructors are called\&.
.sp
\fBThrows\fR: If pred throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() calls to the predicate\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}
.\" size: Class template slist
.\" Class template slist: size
.\" remove_and_dispose_if: Class template slist
.\" Class template slist: remove_and_dispose_if

.sp

.nf
template<typename Pred, typename Disposer> 
  void remove_and_dispose_if(Pred pred, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes all the elements for which a specified predicate is satisfied\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If pred throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time\&. It performs exactly size() comparisons for equality\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}
.\" unique: Class template slist
.\" Class template slist: unique

.sp

.nf
void unique();
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that are equal from the list\&. No destructors are called\&.
.sp
\fBThrows\fR: If std::equal_to<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1) comparisons calls to pred())\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}
.\" unique: Class template slist
.\" Class template slist: unique

.sp

.nf
template<typename BinaryPredicate> void unique(BinaryPredicate pred);
.fi

.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list\&. No destructors are called\&.
.sp
\fBThrows\fR: If the predicate throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1) comparisons equality comparisons\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'65.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "65." 4.2
.\}
.\" unique_and_dispose: Class template slist
.\" Class template slist: unique_and_dispose

.sp

.nf
template<typename Disposer> void unique_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If std::equal_to<value_type> throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1) comparisons equality comparisons\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'66.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "66." 4.2
.\}
.\" unique_and_dispose: Class template slist
.\" Class template slist: unique_and_dispose

.sp

.nf
template<typename BinaryPredicate, typename Disposer> 
  void unique_and_dispose(BinaryPredicate pred, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list\&. Disposer::operator()(pointer) is called for every removed element\&.
.sp
\fBThrows\fR: If the predicate throws\&. Basic guarantee\&.
.sp
\fBComplexity\fR: Linear time (size()\-1) comparisons equality comparisons\&.
.sp
\fBNote\fR: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'67.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "67." 4.2
.\}
.\" iterator_to: Class template slist
.\" Class template slist: iterator_to

.sp

.nf
iterator iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be a reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns a const_iterator pointing to the element
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'68.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "68." 4.2
.\}
.\" iterator_to: Class template slist
.\" Class template slist: iterator_to

.sp

.nf
const_iterator iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be a const reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns an iterator pointing to the element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'69.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "69." 4.2
.\}
.\" previous: Class template slist
.\" Class template slist: previous

.sp

.nf
iterator previous(iterator i);
.fi

.sp
\fBReturns\fR: The iterator to the element before i in the list\&. Returns the end\-iterator, if either i is the begin\-iterator or the list is empty\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before i\&. Constant if cache_last<> is true and i == end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'70.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "70." 4.2
.\}
.\" previous: Class template slist
.\" Class template slist: previous

.sp

.nf
const_iterator previous(const_iterator i) const;
.fi

.sp
\fBReturns\fR: The const_iterator to the element before i in the list\&. Returns the end\-const_iterator, if either i is the begin\-const_iterator or the list is empty\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before i\&. Constant if cache_last<> is true and i == end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'71.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "71." 4.2
.\}
.\" previous: Class template slist
.\" Class template slist: previous

.sp

.nf
iterator previous(const_iterator prev_from, iterator i);
.fi

.sp
\fBReturns\fR: The iterator to the element before i in the list, starting the search on element after prev_from\&. Returns the end\-iterator, if either i is the begin\-iterator or the list is empty\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before i\&. Constant if cache_last<> is true and i == end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'72.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "72." 4.2
.\}
.\" previous: Class template slist
.\" Class template slist: previous

.sp

.nf
const_iterator previous(const_iterator prev_from, const_iterator i) const;
.fi

.sp
\fBReturns\fR: The const_iterator to the element before i in the list, starting the search on element after prev_from\&. Returns the end\-const_iterator, if either i is the begin\-const_iterator or the list is empty\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements before i\&. Constant if cache_last<> is true and i == end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'73.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "73." 4.2
.\}
.\" check: Class template slist
.\" Class template slist: check

.sp

.nf
void check() const;
.fi

.sp
\fBEffects\fR: Asserts the integrity of the container\&.
.sp
\fBComplexity\fR: Linear time\&.
.sp
\fBNote\fR: The method has no effect when asserts are turned off (e\&.g\&., with NDEBUG)\&. Experimental function, interface might change in future versions\&.
.RE

.SS "slist public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" container_from_end_iterator: Class template slist
.\" Class template slist: container_from_end_iterator

.sp

.nf
static slist & container_from_end_iterator(iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end iterator of slist\&.
.sp
\fBEffects\fR: Returns a const reference to the slist associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" container_from_end_iterator: Class template slist
.\" Class template slist: container_from_end_iterator

.sp

.nf
static const slist & container_from_end_iterator(const_iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end const_iterator of slist\&.
.sp
\fBEffects\fR: Returns a const reference to the slist associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" s_iterator_to: Class template slist
.\" Class template slist: s_iterator_to

.sp

.nf
static iterator s_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be a reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns a const_iterator pointing to the element
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&. This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" s_iterator_to: Class template slist
.\" Class template slist: s_iterator_to

.sp

.nf
static const_iterator s_iterator_to(const_reference value);
.fi

.sp
\fBRequires\fR: value must be a const reference to a value inserted in a list\&.
.sp
\fBEffects\fR: This function returns an iterator pointing to the element\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: Iterators and references are not invalidated\&. This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE

.SS "slist private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" priv_splice_after: Class template slist
.\" Class template slist: priv_splice_after

.sp

.nf
void priv_splice_after(const node_ptr & prev_pos_n, slist & x, 
                       const node_ptr & before_f_n, 
                       const node_ptr & before_l_n);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" priv_incorporate_after: Class template slist
.\" Class template slist: priv_incorporate_after

.sp

.nf
void priv_incorporate_after(const node_ptr & prev_pos_n, 
                            const node_ptr & first_n, 
                            const node_ptr & before_l_n);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" priv_reverse: Class template slist
.\" Class template slist: priv_reverse

.sp

.nf
void priv_reverse(\fIunspecified\fR);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" priv_reverse: Class template slist
.\" Class template slist: priv_reverse

.sp

.nf
void priv_reverse(\fIunspecified\fR);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" priv_shift_backwards: Class template slist
.\" Class template slist: priv_shift_backwards

.sp

.nf
void priv_shift_backwards(size_type n, \fIunspecified\fR);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" priv_shift_backwards: Class template slist
.\" Class template slist: priv_shift_backwards

.sp

.nf
void priv_shift_backwards(size_type n, \fIunspecified\fR);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" priv_shift_forward: Class template slist
.\" Class template slist: priv_shift_forward

.sp

.nf
void priv_shift_forward(size_type n, \fIunspecified\fR);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" priv_shift_forward: Class template slist
.\" Class template slist: priv_shift_forward

.sp

.nf
void priv_shift_forward(size_type n, \fIunspecified\fR);
.fi

.RE

.SS "slist private static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" priv_swap_cache_last: Class template slist
.\" Class template slist: priv_swap_cache_last

.sp

.nf
static void priv_swap_cache_last(slist * this_impl, slist * other_impl);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" priv_swap_lists: Class template slist
.\" Class template slist: priv_swap_lists

.sp

.nf
static void priv_swap_lists(const node_ptr & this_node, 
                            const node_ptr & other_node, \fIunspecified\fR);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" priv_swap_lists: Class template slist
.\" Class template slist: priv_swap_lists

.sp

.nf
static void priv_swap_lists(const node_ptr & this_node, 
                            const node_ptr & other_node, \fIunspecified\fR);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" priv_container_from_end_iterator: Class template slist
.\" Class template slist: priv_container_from_end_iterator

.sp

.nf
static slist & 
priv_container_from_end_iterator(const const_iterator & end_iterator);
.fi

.RE


