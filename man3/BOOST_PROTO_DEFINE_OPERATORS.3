.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST" 3 "" "" ""
.SH "NAME"
BOOST_PROTO_DEFINE_OPERATORS \- Defines a complete set of expression template\-building operator overloads for use with non\-Proto terminal types\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/operators\&.hpp>

BOOST_PROTO_DEFINE_OPERATORS(Trait, Domain)
.fi
.SH "DESCRIPTION"
.PP
With
BOOST_PROTO_DEFINE_OPERATORS(), it is possible to non\-intrusively adapt an existing (non\-Proto) type to be a Proto terminal\&.
.PP

Trait
is the name of a unary Boolean metafunction that returns true for any types you would like to treat as Proto terminals\&.
.PP

Domain
is the name of the Proto domain associated with these new Proto terminals\&. You may use
proto::default_domain
for the
Domain
if you do not wish to associate these terminals with any domain\&.
.PP

\fBExample:\fR

.sp
.if n \{\
.RS 4
.\}
.nf
namespace My {
  // A non\-Proto terminal type
  struct S {};

  // A unary Boolean metafunction that returns true for type S
  template<typename T> struct IsS : mpl::false_ {};
  template<> struct IsS<S> : mpl::true_ {};
  
  // Make S a Proto terminal non\-intrusively by defining the
  // appropriate operator overloads\&. This should be in the same
  // namespace as S so that these overloads can be found by
  // argument\-dependent lookup
  BOOST_PROTO_DEFINE_OPERATORS(IsS, proto::default_domain)
}

int main() {
  My::S s1, s2;
  
  // OK, this builds a Proto expression template:
  s1 + s2; 
}
.fi
.if n \{\
.RE
.\}
.sp


