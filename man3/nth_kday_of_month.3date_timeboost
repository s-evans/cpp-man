.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::date_time::nth_kday_of_month \- Useful generator functor for finding holidays\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/date_generators\&.hpp>

template<typename date_type> 
class nth_kday_of_month :
  public boost::date_time::year_based_generator< date_type >
{
public:
  // types
  typedef date_type::calendar_type        calendar_type;   
  typedef calendar_type::day_of_week_type day_of_week_type;
  typedef calendar_type::month_type       month_type;      
  typedef calendar_type::year_type        year_type;       
  typedef date_type::duration_type        duration_type;   

  enum week_num { first = =1, second, third, fourth, fifth };

  // construct/copy/destruct
  nth_kday_of_month(week_num, day_of_week_type, month_type);

  // public member functions
  virtual date_type get_date(year_type) const;
  month_type month() const;
  week_num nth_week() const;
  day_of_week_type day_of_week() const;
  const char * nth_week_as_str() const;
  virtual std::string to_string() const;
};
.fi
.SH "DESCRIPTION"
.PP
Based on the idea in Cal\&. Calc\&. for finding holidays that are the \'first Monday of September\'\&. When instantiated with \'fifth\' kday of month, the result will be the last kday of month which can be the fourth or fifth depending on the structure of the month\&.
.PP
The algorithm here basically guesses for the first day of the month\&. Then finds the first day of the correct type\&. That is, if the first of the month is a Tuesday and it needs Wenesday then we simply increment by a day and then we can add the length of a week until we get to the \'nth kday\'\&. There are probably more efficient algorithms based on using a mod 7, but this one works reasonably well for basic applications\&.
.SS "nth_kday_of_month public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
nth_kday_of_month(week_num week_no, day_of_week_type dow, month_type m);
.fi

.RE

.SS "nth_kday_of_month public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
virtual date_type get_date(year_type y) const;
.fi

Return a concrete date when provided with a year specific year\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
month_type month() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
week_num nth_week() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
day_of_week_type day_of_week() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
const char * nth_week_as_str() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
virtual std::string to_string() const;
.fi

.sp
Returns string suitable for use in POSIX time zone string\&. Returns a string formatted as "M4\&.3\&.0" ==> 3rd Sunday in April\&.
.RE


