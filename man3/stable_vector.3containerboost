.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::container::stable_vector
.SH "SYNOPSIS"
.\" value_type: Class template stable_vector
.\" Class template stable_vector: value_type
.\" swap: Class template stable_vector
.\" Class template stable_vector: swap
.\" stored_allocator_type: Class template stable_vector
.\" Class template stable_vector: stored_allocator_type
.\" stable_vector: Class template stable_vector
.\" Class template stable_vector: stable_vector
.\" size_type: Class template stable_vector
.\" Class template stable_vector: size_type
.\" shrink_to_fit: Class template stable_vector
.\" Class template stable_vector: shrink_to_fit
.\" reverse_iterator: Class template stable_vector
.\" Class template stable_vector: reverse_iterator
.\" resize: Class template stable_vector
.\" Class template stable_vector: resize
.\" reserve: Class template stable_vector
.\" Class template stable_vector: reserve
.\" rend: Class template stable_vector
.\" Class template stable_vector: rend
.\" reference: Class template stable_vector
.\" Class template stable_vector: reference
.\" rbegin: Class template stable_vector
.\" Class template stable_vector: rbegin
.\" push_back: Class template stable_vector
.\" Class template stable_vector: push_back
.\" pop_back: Class template stable_vector
.\" Class template stable_vector: pop_back
.\" pointer: Class template stable_vector
.\" Class template stable_vector: pointer
.\" nth: Class template stable_vector
.\" Class template stable_vector: nth
.\" iterator: Class template stable_vector
.\" Class template stable_vector: iterator
.\" insert: Class template stable_vector
.\" Class template stable_vector: insert
.\" index_of: Class template stable_vector
.\" Class template stable_vector: index_of
.\" get_stored_allocator: Class template stable_vector
.\" Class template stable_vector: get_stored_allocator
.\" front: Class template stable_vector
.\" Class template stable_vector: front
.\" erase: Class template stable_vector
.\" Class template stable_vector: erase
.\" end: Class template stable_vector
.\" Class template stable_vector: end
.\" emplace_back: Class template stable_vector
.\" Class template stable_vector: emplace_back
.\" emplace: Class template stable_vector
.\" Class template stable_vector: emplace
.\" difference_type: Class template stable_vector
.\" Class template stable_vector: difference_type
.\" const_reverse_iterator: Class template stable_vector
.\" Class template stable_vector: const_reverse_iterator
.\" const_reference: Class template stable_vector
.\" Class template stable_vector: const_reference
.\" const_pointer: Class template stable_vector
.\" Class template stable_vector: const_pointer
.\" const_iterator: Class template stable_vector
.\" Class template stable_vector: const_iterator
.\" clear: Class template stable_vector
.\" Class template stable_vector: clear
.\" begin: Class template stable_vector
.\" Class template stable_vector: begin
.\" back: Class template stable_vector
.\" Class template stable_vector: back
.\" at: Class template stable_vector
.\" Class template stable_vector: at
.\" assign: Class template stable_vector
.\" Class template stable_vector: assign
.\" allocator_type: Class template stable_vector
.\" Class template stable_vector: allocator_type

.sp
.nf
// In header: <boost/container/stable_vector\&.hpp>

template<typename T, typename Allocator = new_allocator<T> > 
class stable_vector {
public:
  // types
  typedef T                                                                  value_type;            
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef node_allocator_type                                                stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  stable_vector();
  explicit stable_vector(const allocator_type &) noexcept;
  explicit stable_vector(size_type);
  stable_vector(size_type, default_init_t);
  explicit stable_vector(size_type, const allocator_type &);
  stable_vector(size_type, default_init_t, const allocator_type &);
  stable_vector(size_type, const T &, 
                const allocator_type & = allocator_type());
  template<typename InputIterator> 
    stable_vector(InputIterator, InputIterator, 
                  const allocator_type & = allocator_type());
  stable_vector(const stable_vector &);
  stable_vector(std::initializer_list< value_type >, 
                const allocator_type & = allocator_type());
  stable_vector(stable_vector &&);
  stable_vector(const stable_vector &, const allocator_type &);
  stable_vector(stable_vector &&, const allocator_type &);
  stable_vector & operator=(const stable_vector &);
  stable_vector & 
  operator=(stable_vector &&) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
  stable_vector & operator=(std::initializer_list< value_type >);
  ~stable_vector();

  // public member functions
  void assign(size_type, const T &);
  template<typename InputIterator> void assign(InputIterator, InputIterator);
  void assign(std::initializer_list< value_type >);
  allocator_type get_allocator() const;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_iterator cbegin() const noexcept;
  const_iterator cend() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const noexcept;
  size_type size() const noexcept;
  size_type max_size() const noexcept;
  void resize(size_type);
  void resize(size_type, default_init_t);
  void resize(size_type, const T &);
  size_type capacity() const noexcept;
  void reserve(size_type);
  void shrink_to_fit();
  reference front() noexcept;
  const_reference front() const noexcept;
  reference back() noexcept;
  const_reference back() const noexcept;
  reference operator[](size_type) noexcept;
  const_reference operator[](size_type) const noexcept;
  iterator nth(size_type) noexcept;
  const_iterator nth(size_type) const noexcept;
  size_type index_of(iterator) noexcept;
  size_type index_of(const_iterator) const noexcept;
  reference at(size_type);
  const_reference at(size_type) const;
  template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace(const_iterator, Args &&\&.\&.\&.);
  void push_back(const T &);
  void push_back(T &&);
  iterator insert(const_iterator, const T &);
  iterator insert(const_iterator, T &&);
  iterator insert(const_iterator, size_type, const T &);
  iterator insert(const_iterator, std::initializer_list< value_type >);
  template<typename InputIterator> 
    iterator insert(const_iterator, InputIterator, InputIterator);
  void pop_back() noexcept;
  iterator erase(const_iterator) noexcept;
  iterator erase(const_iterator, const_iterator) noexcept;
  void swap(stable_vector &) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
  void clear() noexcept;

  // friend functions
  friend bool operator==(const stable_vector &, const stable_vector &);
  friend bool operator!=(const stable_vector &, const stable_vector &);
  friend bool operator<(const stable_vector &, const stable_vector &);
  friend bool operator>(const stable_vector &, const stable_vector &);
  friend bool operator<=(const stable_vector &, const stable_vector &);
  friend bool operator>=(const stable_vector &, const stable_vector &);
  friend void swap(stable_vector &, stable_vector &);
};
.fi
.SH "DESCRIPTION"
.\" end: Class template stable_vector
.\" Class template stable_vector: end
.PP
Originally developed by Joaquin M\&. Lopez Munoz,
stable_vector
is a std::vector drop\-in replacement implemented as a node container, offering iterator and reference stability\&.
.PP
Here are the details taken from the author\'s blog (\m[blue]\fBIntroducing stable_vector\fR\m[]\&\s-2\u[1]\d\s+2):
.PP
We present
stable_vector, a fully STL\-compliant stable container that provides most of the features of std::vector except element contiguity\&.
.PP
General properties:
stable_vector
satisfies all the requirements of a container, a reversible container and a sequence and provides all the optional operations present in std::vector\&. Like std::vector, iterators are random access\&.
stable_vector
does not provide element contiguity; in exchange for this absence, the container is stable, i\&.e\&. references and iterators to an element of a
stable_vector
remain valid as long as the element is not erased, and an iterator that has been assigned the return value of end() always remain valid until the destruction of the associated
stable_vector\&.
.PP
Operation complexity: The big\-O complexities of
stable_vector
operations match exactly those of std::vector\&. In general, insertion/deletion is constant time at the end of the sequence and linear elsewhere\&. Unlike std::vector,
stable_vector
does not internally perform any value_type destruction, copy or assignment operations other than those exactly corresponding to the insertion of new elements or deletion of stored elements, which can sometimes compensate in terms of performance for the extra burden of doing more pointer manipulation and an additional allocation per element\&.
.PP
Exception safety: As
stable_vector
does not internally copy elements around, some operations provide stronger exception safety guarantees than in std::vector\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename T
.fi

.sp
The type of object that is stored in the stable_vector
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<T>
.fi

.sp
The allocator used for all internal memory management
.RE

.SS "stable_vector public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
stable_vector();
.fi

.sp
\fBEffects\fR: Default constructs a
stable_vector\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit stable_vector(const allocator_type & al) noexcept;
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
taking the allocator as parameter\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit stable_vector(size_type n);
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
and inserts n value initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
stable_vector(size_type n, default_init_t);
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
and inserts n default initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
explicit stable_vector(size_type n, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
that will use a copy of allocator a and inserts n value initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
stable_vector(size_type n, default_init_t, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
that will use a copy of allocator a and inserts n default initialized values\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
stable_vector(size_type n, const T & t, 
              const allocator_type & al = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
that will use a copy of allocator a and inserts n copies of value\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s default or copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  stable_vector(InputIterator first, InputIterator last, 
                const allocator_type & al = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
that will use a copy of allocator a and inserts a copy of the range [first, last) in the
stable_vector\&.
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced InIt throws\&.
.sp
\fBComplexity\fR: Linear to the range [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
stable_vector(const stable_vector & x);
.fi

.sp
\fBEffects\fR: Copy constructs a
stable_vector\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
stable_vector(std::initializer_list< value_type > il, 
              const allocator_type & l = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs a
stable_vector
that will use a copy of allocator a and inserts a copy of the range [il\&.begin(), il\&.last()) in the
stable_vector
.sp
\fBThrows\fR: If allocator_type\'s default constructor throws or T\'s constructor taking a dereferenced initializer_list iterator throws\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
stable_vector(stable_vector && x);
.fi

.sp
\fBEffects\fR: Move constructor\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocator_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
stable_vector(const stable_vector & x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a
stable_vector
using the specified allocator\&.
.sp
\fBPostcondition\fR: x == *this\&.
.sp
\fBComplexity\fR: Linear to the elements x contains\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
stable_vector(stable_vector && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructor using the specified allocator\&. Moves x\'s resources to *this\&.
.sp
\fBThrows\fR: If allocator_type\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant if a == x\&.get_allocator(), linear otherwise
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
stable_vector & operator=(const stable_vector & x);
.fi

.sp
\fBEffects\fR: Makes *this contain the same elements as x\&.
.sp
\fBPostcondition\fR: this\->size() == x\&.size()\&. *this contains a copy of each of x\'s elements\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the number of elements in x\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
stable_vector & 
operator=(stable_vector && x) noexcept(allocator_traits_type::propagate_on_container_move_assignment::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Move assignment\&. All x\'s values are transferred to *this\&.
.sp
\fBPostcondition\fR: x\&.empty()\&. *this contains a the elements x had before the function\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or T\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
stable_vector & operator=(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Make *this container contains elements from il\&.
.sp
\fBComplexity\fR: Linear to the range [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
~stable_vector();
.fi

.sp
\fBEffects\fR: Destroys the
stable_vector\&. All stored values are destroyed and used memory is deallocated\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements\&.
.RE

.SS "stable_vector public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" assign: Class template stable_vector
.\" Class template stable_vector: assign

.sp

.nf
void assign(size_type n, const T & t);
.fi

.sp
\fBEffects\fR: Assigns the n copies of val to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" assign: Class template stable_vector
.\" Class template stable_vector: assign

.sp

.nf
template<typename InputIterator> 
  void assign(InputIterator first, InputIterator last);
.fi

.sp
\fBEffects\fR: Assigns the the range [first, last) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing InpIt throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" assign: Class template stable_vector
.\" Class template stable_vector: assign

.sp

.nf
void assign(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Assigns the the range [il\&.begin(), il\&.end()) to *this\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s constructor from dereferencing initializer_list iterator throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const;
.fi

.sp
\fBEffects\fR: Returns a copy of the internal allocator\&.
.sp
\fBThrows\fR: If allocator\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" get_stored_allocator: Class template stable_vector
.\" Class template stable_vector: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" get_stored_allocator: Class template stable_vector
.\" Class template stable_vector: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" begin: Class template stable_vector
.\" Class template stable_vector: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" begin: Class template stable_vector
.\" Class template stable_vector: begin

.sp

.nf
const_iterator begin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" end: Class template stable_vector
.\" Class template stable_vector: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" end: Class template stable_vector
.\" Class template stable_vector: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rbegin: Class template stable_vector
.\" Class template stable_vector: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" rbegin: Class template stable_vector
.\" Class template stable_vector: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rend: Class template stable_vector
.\" Class template stable_vector: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template stable_vector
.\" Class template stable_vector: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
\fBEffects\fR: Returns true if the
stable_vector
contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" resize: Class template stable_vector
.\" Class template stable_vector: resize

.sp

.nf
void resize(size_type n);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are value initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s value initialization throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" resize: Class template stable_vector
.\" Class template stable_vector: resize

.sp

.nf
void resize(size_type n, default_init_t);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are default initialized\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s default initialization throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" resize: Class template stable_vector
.\" Class template stable_vector: resize

.sp

.nf
void resize(size_type n, const T & t);
.fi

.sp
\fBEffects\fR: Inserts or erases elements at the end such that the size becomes n\&. New elements are copy constructed from x\&.
.sp
\fBThrows\fR: If memory allocation throws, or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to the difference between size() and new_size\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
size_type capacity() const noexcept;
.fi

.sp
\fBEffects\fR: Number of elements for which memory has been allocated\&. capacity() is always greater than or equal to size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" reserve: Class template stable_vector
.\" Class template stable_vector: reserve

.sp

.nf
void reserve(size_type n);
.fi

.sp
\fBEffects\fR: If n is less than or equal to capacity(), this call has no effect\&. Otherwise, it is a request for allocation of additional memory\&. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged\&. In either case, size() is unchanged\&.
.sp
\fBThrows\fR: If memory allocation allocation throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" shrink_to_fit: Class template stable_vector
.\" Class template stable_vector: shrink_to_fit

.sp

.nf
void shrink_to_fit();
.fi

.sp
\fBEffects\fR: Tries to deallocate the excess of memory created with previous allocations\&. The size of the
stable_vector
is unchanged
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Linear to size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" front: Class template stable_vector
.\" Class template stable_vector: front

.sp

.nf
reference front() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the first element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" front: Class template stable_vector
.\" Class template stable_vector: front

.sp

.nf
const_reference front() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the first element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" back: Class template stable_vector
.\" Class template stable_vector: back

.sp

.nf
reference back() noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a reference to the last element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" back: Class template stable_vector
.\" Class template stable_vector: back

.sp

.nf
const_reference back() const noexcept;
.fi

.sp
\fBRequires\fR: !empty()
.sp
\fBEffects\fR: Returns a const reference to the last element of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}

.sp

.nf
reference operator[](size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}

.sp

.nf
const_reference operator[](size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" end: Class template stable_vector
.\" Class template stable_vector: end
.\" nth: Class template stable_vector
.\" Class template stable_vector: nth

.sp

.nf
iterator nth(size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template stable_vector
.\" Class template stable_vector: end
.\" nth: Class template stable_vector
.\" Class template stable_vector: nth

.sp

.nf
const_iterator nth(size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns a const_iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" index_of: Class template stable_vector
.\" Class template stable_vector: index_of

.sp

.nf
size_type index_of(iterator p) noexcept;
.fi

.sp
\fBRequires\fR: begin() <= p <= end()\&.
.sp
\fBEffects\fR: Returns the index of the element pointed by p and size() if p == end()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" index_of: Class template stable_vector
.\" Class template stable_vector: index_of

.sp

.nf
size_type index_of(const_iterator p) const noexcept;
.fi

.sp
\fBRequires\fR: begin() <= p <= end()\&.
.sp
\fBEffects\fR: Returns the index of the element pointed by p and size() if p == end()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" at: Class template stable_vector
.\" Class template stable_vector: at

.sp

.nf
reference at(size_type n);
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" at: Class template stable_vector
.\" Class template stable_vector: at

.sp

.nf
const_reference at(size_type n) const;
.fi

.sp
\fBRequires\fR: size() > n\&.
.sp
\fBEffects\fR: Returns a const reference to the nth element from the beginning of the container\&.
.sp
\fBThrows\fR: std::range_error if n >= size()
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" emplace_back: Class template stable_vector
.\" Class template stable_vector: emplace_back

.sp

.nf
template<class\&.\&.\&. Args> void emplace_back(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the end of the
stable_vector\&.
.sp
\fBThrows\fR: If memory allocation throws or the in\-place constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" end: Class template stable_vector
.\" Class template stable_vector: end
.\" emplace: Class template stable_vector
.\" Class template stable_vector: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. before p
.sp
\fBThrows\fR: If memory allocation throws or the in\-place constructor throws\&.
.sp
\fBComplexity\fR: If p is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" push_back: Class template stable_vector
.\" Class template stable_vector: push_back

.sp

.nf
void push_back(const T & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x at the end of the
stable_vector\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" push_back: Class template stable_vector
.\" Class template stable_vector: push_back

.sp

.nf
void push_back(T && x);
.fi

.sp
\fBEffects\fR: Constructs a new element in the end of the
stable_vector
and moves the resources of x to this new element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" end: Class template stable_vector
.\" Class template stable_vector: end
.\" insert: Class template stable_vector
.\" Class template stable_vector: insert

.sp

.nf
iterator insert(const_iterator p, const T & x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of x before p\&.
.sp
\fBReturns\fR: An iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws or x\'s copy constructor throws\&.
.sp
\fBComplexity\fR: If p is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" end: Class template stable_vector
.\" Class template stable_vector: end
.\" insert: Class template stable_vector
.\" Class template stable_vector: insert

.sp

.nf
iterator insert(const_iterator p, T && x);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a new element before p with x\'s resources\&.
.sp
\fBReturns\fR: an iterator to the inserted element\&.
.sp
\fBThrows\fR: If memory allocation throws\&.
.sp
\fBComplexity\fR: If p is end(), amortized constant time Linear time otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" insert: Class template stable_vector
.\" Class template stable_vector: insert

.sp

.nf
iterator insert(const_iterator p, size_type n, const T & t);
.fi

.sp
\fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert n copies of x before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if n is 0\&.
.sp
\fBThrows\fR: If memory allocation throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to n\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" insert: Class template stable_vector
.\" Class template stable_vector: insert

.sp

.nf
iterator insert(const_iterator p, std::initializer_list< value_type > il);
.fi

\fBRequires\fR: p must be a valid iterator of *this\&. \fBRequires\fR: p must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [il\&.begin(), il\&.end()) range before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if first == last\&.
.sp
\fBComplexity\fR: Linear to distance [il\&.begin(), il\&.end())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" insert: Class template stable_vector
.\" Class template stable_vector: insert

.sp

.nf
template<typename InputIterator> 
  iterator insert(const_iterator p, InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: pos must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Insert a copy of the [first, last) range before p\&.
.sp
\fBReturns\fR: an iterator to the first inserted element or p if first == last\&.
.sp
\fBThrows\fR: If memory allocation throws, T\'s constructor from a dereferenced InpIt throws or T\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to distance [first, last)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" pop_back: Class template stable_vector
.\" Class template stable_vector: pop_back

.sp

.nf
void pop_back() noexcept;
.fi

.sp
\fBEffects\fR: Removes the last element from the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" erase: Class template stable_vector
.\" Class template stable_vector: erase

.sp

.nf
iterator erase(const_iterator p) noexcept;
.fi

.sp
\fBEffects\fR: Erases the element at p\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements between p and the last element\&. Constant if p is the last element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" erase: Class template stable_vector
.\" Class template stable_vector: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last) noexcept;
.fi

.sp
\fBEffects\fR: Erases the elements pointed by [first, last)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the distance between first and last plus linear to the elements between p and the last element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" swap: Class template stable_vector
.\" Class template stable_vector: swap

.sp

.nf
void swap(stable_vector & x) noexcept(allocator_traits_type::propagate_on_container_swap::value||allocator_traits_type::is_always_equal::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" clear: Class template stable_vector
.\" Class template stable_vector: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: Erases all the elements of the
stable_vector\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the
stable_vector\&.
.RE

.SS "stable_vector friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const stable_vector & x, const stable_vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const stable_vector & x, const stable_vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const stable_vector & x, const stable_vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const stable_vector & x, const stable_vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const stable_vector & x, const stable_vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const stable_vector & x, const stable_vector & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template stable_vector
.\" Class template stable_vector: swap

.sp

.nf
friend void swap(stable_vector & x, stable_vector & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


