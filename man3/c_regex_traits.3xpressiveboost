.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLA" 3 "" "" ""
.SH "NAME"
boost::xpressive::c_regex_traits \- Encapsaulates the standard C locale functions for use by the basic_regex<> class template\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/xpressive/xpressive_fwd\&.hpp>

template<typename Char> 
struct c_regex_traits {
  // construct/copy/destruct
  c_regex_traits(locale_type const & = locale_type());

  // public member functions
  bool operator==(c_regex_traits< char_type > const &) const;
  bool operator!=(c_regex_traits< char_type > const &) const;
  string_type fold_case(char_type) const;
  locale_type imbue(locale_type);
  template<> char widen(char);
  template<> wchar_t widen(char);
  template<> unsigned char hash(char);
  template<> unsigned char hash(wchar_t);
  template<> int value(char, int);
  template<> int value(wchar_t, int);

  // public static functions
  static char_type widen(char);
  static unsigned char hash(char_type);
  static char_type translate(char_type);
  static char_type translate_nocase(char_type);
  static char_type tolower(char_type);
  static char_type toupper(char_type);
  static bool in_range(char_type, char_type, char_type);
  static bool in_range_nocase(char_type, char_type, char_type);
  template<typename FwdIter> static string_type transform(FwdIter, FwdIter);
  template<typename FwdIter> 
    static string_type transform_primary(FwdIter, FwdIter);
  template<typename FwdIter> 
    static string_type lookup_collatename(FwdIter, FwdIter);
  template<typename FwdIter> 
    static char_class_type lookup_classname(FwdIter, FwdIter, bool);
  static bool isctype(char_type, char_class_type);
  static int value(char_type, int);
  static locale_type getloc();
};
.fi
.SH "DESCRIPTION"
.SS "c_regex_traits public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
c_regex_traits(locale_type const & loc = locale_type());
.fi

.sp
Initialize a
c_regex_traits
object to use the global C locale\&.
.RE

.SS "c_regex_traits public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool operator==(c_regex_traits< char_type > const &) const;
.fi

.sp
Checks two
c_regex_traits
objects for equality
.sp

.PP
Returns:
.RS 4
true\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool operator!=(c_regex_traits< char_type > const &) const;
.fi

.sp
Checks two
c_regex_traits
objects for inequality
.sp

.PP
Returns:
.RS 4
false\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
string_type fold_case(char_type ch) const;
.fi

.sp
Returns a
string_type
containing all the characters that compare equal disregrarding case to the one passed in\&. This function can only be called if
has_fold_case<c_regex_traits<Char> >::value
is
true\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
string_type
containing all chars which are equal to
ch
when disregarding case
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
locale_type imbue(locale_type loc);
.fi

.sp
No\-op
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<> char widen(char ch);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<> wchar_t widen(char ch);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<> unsigned char hash(char ch);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<> unsigned char hash(wchar_t ch);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<> int value(char ch, int radix);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<> int value(wchar_t ch, int radix);
.fi

.RE

.SS "c_regex_traits public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static char_type widen(char ch);
.fi

.sp
Convert a char to a Char
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
ch if Char is char, std::btowc(ch) if Char is wchar_t\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static unsigned char hash(char_type ch);
.fi

.sp
Returns a hash value for a Char in the range [0, UCHAR_MAX]
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
a value between 0 and UCHAR_MAX, inclusive\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
static char_type translate(char_type ch);
.fi

.sp
No\-op
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
ch
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
static char_type translate_nocase(char_type ch);
.fi

.sp
Converts a character to lower\-case using the current global C locale\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
static char_type tolower(char_type ch);
.fi

.sp
Converts a character to lower\-case using the current global C locale\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
std::tolower(ch) if Char is char, std::towlower(ch) if Char is wchar_t\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
static char_type toupper(char_type ch);
.fi

.sp
Converts a character to upper\-case using the current global C locale\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
std::toupper(ch) if Char is char, std::towupper(ch) if Char is wchar_t\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
static bool in_range(char_type first, char_type last, char_type ch);
.fi

.sp
Checks to see if a character is within a character range\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.PP
first
.RS 4
The bottom of the range, inclusive\&.
.RE
.PP
last
.RS 4
The top of the range, inclusive\&.
.RE
.RE
.PP
Returns:
.RS 4
first <= ch && ch <= last\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
static bool in_range_nocase(char_type first, char_type last, char_type ch);
.fi

.sp
Checks to see if a character is within a character range, irregardless of case\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The default implementation doesn\'t do proper Unicode case folding, but this is the best we can do with the standard C locale functions\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.PP
first
.RS 4
The bottom of the range, inclusive\&.
.RE
.PP
last
.RS 4
The top of the range, inclusive\&.
.RE
.RE
.PP
Returns:
.RS 4
in_range(first, last, ch) || in_range(first, last, tolower(ch)) || in_range(first, last, toupper(ch))
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static string_type transform(FwdIter begin, FwdIter end);
.fi

.sp
Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v\&.transform(G1, G2) < v\&.transform(H1, H2)\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not currently used
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static string_type transform_primary(FwdIter begin, FwdIter end);
.fi

.sp
Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v\&.transform_primary(G1, G2) < v\&.transform_primary(H1, H2)\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not currently used
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static string_type lookup_collatename(FwdIter begin, FwdIter end);
.fi

.sp
Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2)\&. Returns an empty string if the character sequence is not a valid collating element\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not currently used
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static char_class_type 
  lookup_classname(FwdIter begin, FwdIter end, bool icase);
.fi

.sp
For the character class name represented by the specified character sequence, return the corresponding bitmask representation\&.
.sp

.PP
Parameters:
.RS 4
.PP
begin
.RS 4
A forward iterator to the start of the character sequence representing the name of the character class\&.
.RE
.PP
end
.RS 4
The end of the character sequence\&.
.RE
.PP
icase
.RS 4
Specifies whether the returned bitmask should represent the case\-insensitive version of the character class\&.
.RE
.RE
.PP
Returns:
.RS 4
A bitmask representing the character class\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
static bool isctype(char_type ch, char_class_type mask);
.fi

.sp
Tests a character against a character class bitmask\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The character to test\&.
.RE
.PP
mask
.RS 4
The character class bitmask against which to test\&.
.RE
.RE
.PP
Requires:
.RS 4
mask is a bitmask returned by lookup_classname, or is several such masks bit\-or\'ed together\&.
.RE
.PP
Returns:
.RS 4
true if the character is a member of any of the specified character classes, false otherwise\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
static int value(char_type ch, int radix);
.fi

.sp
Convert a digit character into the integer it represents\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The digit character\&.
.RE
.PP
radix
.RS 4
The radix to use for the conversion\&.
.RE
.RE
.PP
Requires:
.RS 4
radix is one of 8, 10, or 16\&.
.RE
.PP
Returns:
.RS 4
\-1 if ch is not a digit character, the integer value of the character otherwise\&. If char_type is char, std::strtol is used for the conversion\&. If char_type is wchar_t, std::wcstol is used\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
static locale_type getloc();
.fi

.sp
No\-op
.RE


