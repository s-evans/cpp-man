.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTION ANY_CAST" 3 "" "" ""
.SH "NAME"
boost::type_erasure::any_cast
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/type_erasure/any_cast\&.hpp>


template<typename T, typename Concept, typename Tag> 
  T any_cast(any< Concept, Tag > & arg);
template<typename T, typename Concept, typename Tag> 
  T any_cast(const any< Concept, Tag > & arg);
template<typename T, typename Concept, typename Tag> 
  T any_cast(any< Concept, Tag > * arg);
template<typename T, typename Concept, typename Tag> 
  T any_cast(const any< Concept, Tag > * arg);
.fi
.SH "DESCRIPTION"
.PP
Attempts to extract the object that
arg
holds\&. If casting to a pointer fails,
any_cast
returns a null pointer\&. Casting to
void*
always succeeds and returns the address of stored object\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
any<mpl::vector<typeid_<>, copy_constructible<> > > x(1);
any_cast<int>(x);      // returns 1
any_cast<int&>(x);     // returns a reference to the contents of x
any_cast<double>(x);   // throws bad_any_cast
any_cast<int*>(&x);    // returns a pointer to the contents of x
any_cast<void*>(&x);   // returns a pointer to the contents of x
any_cast<double*>(&x); // returns NULL

.fi
.if n \{\
.RE
.\}

.PP

.PP
Requires:
.RS 4
if
arg
is a pointer,
T
must be a pointer type\&.
.RE
.PP
Requires:
.RS 4
Concept
must contain typeid_<Tag>\&.
.RE
.PP
Throws:
.RS 4
bad_any_cast
if
arg
doesn\'t contain an object of type
T
and we\'re casting to a value or reference\&.
.RE

