.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE H" 3 "" "" ""
.SH "NAME"
boost::intrusive::hashtable
.SH "SYNOPSIS"
.\" value_type: Class template hashtable
.\" Class template hashtable: value_type
.\" value_traits: Class template hashtable
.\" Class template hashtable: value_traits
.\" swap: Class template hashtable
.\" Class template hashtable: swap
.\" suggested_upper_bucket_count: Class template hashtable
.\" Class template hashtable: suggested_upper_bucket_count
.\" suggested_lower_bucket_count: Class template hashtable
.\" Class template hashtable: suggested_lower_bucket_count
.\" size_type: Class template hashtable
.\" Class template hashtable: size_type
.\" size: Class template hashtable
.\" Class template hashtable: size
.\" siterator: Class template hashtable
.\" Class template hashtable: siterator
.\" s_local_iterator_to: Class template hashtable
.\" Class template hashtable: s_local_iterator_to
.\" rehash: Class template hashtable
.\" Class template hashtable: rehash
.\" reference: Class template hashtable
.\" Class template hashtable: reference
.\" pointer: Class template hashtable
.\" Class template hashtable: pointer
.\" node_traits: Class template hashtable
.\" Class template hashtable: node_traits
.\" node_reference: Class template hashtable
.\" Class template hashtable: node_reference
.\" node_ptr: Class template hashtable
.\" Class template hashtable: node_ptr
.\" node_algorithms: Class template hashtable
.\" Class template hashtable: node_algorithms
.\" node: Class template hashtable
.\" Class template hashtable: node
.\" local_iterator_to: Class template hashtable
.\" Class template hashtable: local_iterator_to
.\" local_iterator: Class template hashtable
.\" Class template hashtable: local_iterator
.\" key_type: Class template hashtable
.\" Class template hashtable: key_type
.\" key_of_value: Class template hashtable
.\" Class template hashtable: key_of_value
.\" key_equal: Class template hashtable
.\" Class template hashtable: key_equal
.\" iterator_to: Class template hashtable
.\" Class template hashtable: iterator_to
.\" iterator: Class template hashtable
.\" Class template hashtable: iterator
.\" insert_unique_commit: Class template hashtable
.\" Class template hashtable: insert_unique_commit
.\" insert_unique_check: Class template hashtable
.\" Class template hashtable: insert_unique_check
.\" insert_unique: Class template hashtable
.\" Class template hashtable: insert_unique
.\" insert_equal: Class template hashtable
.\" Class template hashtable: insert_equal
.\" insert_commit_data: Class template hashtable
.\" Class template hashtable: insert_commit_data
.\" incremental_rehash: Class template hashtable
.\" Class template hashtable: incremental_rehash
.\" hashtable_size_traits_wrapper: Class template hashtable
.\" Class template hashtable: hashtable_size_traits_wrapper
.\" hasher: Class template hashtable
.\" Class template hashtable: hasher
.\" hash_bool_flags: Class template hashtable
.\" Class template hashtable: hash_bool_flags
.\" find: Class template hashtable
.\" Class template hashtable: find
.\" erase_and_dispose: Class template hashtable
.\" Class template hashtable: erase_and_dispose
.\" erase: Class template hashtable
.\" Class template hashtable: erase
.\" end: Class template hashtable
.\" Class template hashtable: end
.\" difference_type: Class template hashtable
.\" Class template hashtable: difference_type
.\" count: Class template hashtable
.\" Class template hashtable: count
.\" const_siterator: Class template hashtable
.\" Class template hashtable: const_siterator
.\" const_reference: Class template hashtable
.\" Class template hashtable: const_reference
.\" const_pointer: Class template hashtable
.\" Class template hashtable: const_pointer
.\" const_node_reference: Class template hashtable
.\" Class template hashtable: const_node_reference
.\" const_node_ptr: Class template hashtable
.\" Class template hashtable: const_node_ptr
.\" const_local_iterator: Class template hashtable
.\" Class template hashtable: const_local_iterator
.\" const_iterator: Class template hashtable
.\" Class template hashtable: const_iterator
.\" clone_from: Class template hashtable
.\" Class template hashtable: clone_from
.\" clear_and_dispose: Class template hashtable
.\" Class template hashtable: clear_and_dispose
.\" clear: Class template hashtable
.\" Class template hashtable: clear
.\" cend: Class template hashtable
.\" Class template hashtable: cend
.\" cbegin: Class template hashtable
.\" Class template hashtable: cbegin
.\" bucket_type: Class template hashtable
.\" Class template hashtable: bucket_type
.\" bucket_ptr: Class template hashtable
.\" Class template hashtable: bucket_ptr
.\" begin: Class template hashtable
.\" Class template hashtable: begin

.sp
.nf
// In header: <boost/intrusive/hashtable\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class hashtable : private hashtable_size_traits_wrapper< hashdata_internal< ValueTraits, VoidOrKeyOfValue, VoidOrKeyHash, VoidOrKeyEqual, BucketTraits, SizeType, BoolFlags &(hash_bool_flags::incremental_pos|hash_bool_flags::cache_begin_pos) >, SizeType,(BoolFlags &hash_bool_flags::constant_time_size_pos)!=0 >
{
public:
  // types
  typedef ValueTraits                                                            value_traits;        
  typedef value_traits::pointer                                                  pointer;             
  typedef value_traits::const_pointer                                            const_pointer;       
  typedef value_traits::value_type                                               value_type;          
  typedef hash_types_base::key_type                                              key_type;            
  typedef hash_types_base::key_of_value                                          key_of_value;        
  typedef pointer_traits< pointer >::reference                                   reference;           
  typedef pointer_traits< const_pointer >::reference                             const_reference;     
  typedef pointer_traits< pointer >::difference_type                             difference_type;     
  typedef SizeType                                                               size_type;           
  typedef internal_type::key_equal                                               key_equal;           
  typedef internal_type::hasher                                                  hasher;              
  typedef \fIunspecified\fR                                                            bucket_type;         
  typedef internal_type::bucket_ptr                                              bucket_ptr;          
  typedef slist::iterator                                                        siterator;           
  typedef slist::const_iterator                                                  const_siterator;     
  typedef internal_type::iterator                                                iterator;            
  typedef internal_type::const_iterator                                          const_iterator;      
  typedef internal_type::local_iterator                                          local_iterator;      
  typedef internal_type::const_local_iterator                                    const_local_iterator;
  typedef value_traits::node_traits                                              node_traits;         
  typedef node_traits::node                                                      node;                
  typedef pointer_traits< pointer >::template rebind_pointer< node >::type       node_ptr;            
  typedef pointer_traits< pointer >::template rebind_pointer< const node >::type const_node_ptr;      
  typedef pointer_traits< node_ptr >::reference                                  node_reference;      
  typedef pointer_traits< const_node_ptr >::reference                            const_node_reference;
  typedef slist::node_algorithms                                                 node_algorithms;     
  typedef \fIunspecified\fR                                                            insert_commit_data;  

  // construct/copy/destruct
  explicit hashtable(const bucket_traits &, const hasher & = hasher(), 
                     const key_equal & = key_equal(), 
                     const value_traits & = value_traits());
  template<typename Iterator> 
    hashtable(bool, Iterator, Iterator, const bucket_traits &, 
              const hasher & = hasher(), const key_equal & = key_equal(), 
              const value_traits & = value_traits());
  hashtable(hashtable &&);
  hashtable & operator=(hashtable &&);
  ~hashtable();

  // public member functions
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  hasher hash_function() const;
  key_equal key_eq() const;
  bool empty() const;
  size_type size() const;
  void swap(hashtable &);
  template<typename Cloner, typename Disposer> 
    void clone_from(const hashtable &, Cloner, Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(hashtable &&, Cloner, Disposer);
  iterator insert_equal(reference);
  template<typename Iterator> void insert_equal(Iterator, Iterator);
  std::pair< iterator, bool > insert_unique(reference);
  template<typename Iterator> void insert_unique(Iterator, Iterator);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    std::pair< iterator, bool > 
    insert_unique_check(const KeyType &, KeyHasher, KeyEqual, 
                        insert_commit_data &);
  iterator insert_unique_commit(reference, const insert_commit_data &);
  void erase(const_iterator);
  void erase(const_iterator, const_iterator);
  size_type erase(const key_type &);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    size_type erase(const KeyType &, KeyHasher, KeyEqual);
  template<typename Disposer> void erase_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    void erase_and_dispose(const_iterator, const_iterator, Disposer);
  template<typename Disposer> 
    size_type erase_and_dispose(const key_type &, Disposer);
  template<typename KeyType, typename KeyHasher, typename KeyEqual, 
           typename Disposer> 
    size_type erase_and_dispose(const KeyType &, KeyHasher, KeyEqual, 
                                Disposer);
  void clear();
  template<typename Disposer> void clear_and_dispose(Disposer);
  size_type count(const key_type &) const;
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    size_type count(const KeyType &, KeyHasher, KeyEqual) const;
  iterator find(const key_type &);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    iterator find(const KeyType &, KeyHasher, KeyEqual);
  const_iterator find(const key_type &) const;
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    const_iterator find(const KeyType &, KeyHasher, KeyEqual) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    std::pair< iterator, iterator > 
    equal_range(const KeyType &, KeyHasher, KeyEqual);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  template<typename KeyType, typename KeyHasher, typename KeyEqual> 
    std::pair< const_iterator, const_iterator > 
    equal_range(const KeyType &, KeyHasher, KeyEqual) const;
  iterator iterator_to(reference);
  const_iterator iterator_to(const_reference) const;
  local_iterator local_iterator_to(reference);
  const_local_iterator local_iterator_to(const_reference) const;
  size_type bucket_count() const;
  size_type bucket_size(size_type) const;
  size_type bucket(const key_type &) const;
  template<typename KeyType, typename KeyHasher> 
    size_type bucket(const KeyType &, KeyHasher) const;
  bucket_ptr bucket_pointer() const;
  local_iterator begin(size_type);
  const_local_iterator begin(size_type) const;
  const_local_iterator cbegin(size_type) const;
  local_iterator end(size_type);
  const_local_iterator end(size_type) const;
  const_local_iterator cend(size_type) const;
  void rehash(const bucket_traits &);
  bool incremental_rehash(bool = true);
  bool incremental_rehash(const bucket_traits &);
  size_type split_count() const;

  // public static functions
  static local_iterator s_local_iterator_to(reference);
  static const_local_iterator s_local_iterator_to(const_reference);
  static size_type suggested_upper_bucket_count(size_type);
  static size_type suggested_lower_bucket_count(size_type);

  // public data members
  static const bool stateful_value_traits;
  static const bool store_hash;
  static const bool unique_keys;
  static const bool constant_time_size;
  static const bool cache_begin;
  static const bool compare_hash;
  static const bool incremental;
  static const bool power_2_buckets;
  static const bool optimize_multikey;
};
.fi
.SH "DESCRIPTION"
.PP
The class template hashtable is an intrusive hash table container, that is used to construct intrusive
unordered_set
and
unordered_multiset
containers\&. The no\-throw guarantee holds only, if the VoidOrKeyEqual object and Hasher don\'t throw\&.
.PP
hashtable is a semi\-intrusive container: each object to be stored in the container must contain a proper hook, but the container also needs additional auxiliary memory to work: hashtable needs a pointer to an array of type
bucket_type
to be passed in the constructor\&. This bucket array must have at least the same lifetime as the container\&. This makes the use of hashtable more complicated than purely intrusive containers\&.
bucket_type
is default\-constructible, copyable and assignable
.PP
The template parameter
T
is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
base_hook<>/member_hook<>/value_traits<>,
constant_time_size<>,
size_type<>,
hash<>
and
equal<>
bucket_traits<>, power_2_buckets<>, cache_begin<> and incremental<>\&.
.PP
hashtable only provides forward iterators but it provides 4 iterator types: iterator and const_iterator to navigate through the whole container and local_iterator and const_local_iterator to navigate through the values stored in a single bucket\&. Local iterators are faster and smaller\&.
.PP
It\'s not recommended to use non constant\-time size hashtables because several key functions, like "empty()", become non\-constant time functions\&. Non constant_time size hashtables are mainly provided to support auto\-unlink hooks\&.
.PP
hashtables, does not make automatic rehashings nor offers functions related to a load factor\&. Rehashing can be explicitly requested and the user must provide a new bucket array that will be used from that moment\&.
.PP
Since no automatic rehashing is done, iterators are never invalidated when inserting or erasing elements\&. Iterators are only invalidated when rehashing\&.
.SS "hashtable public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit hashtable(const bucket_traits & b_traits, 
                   const hasher & hash_func = hasher(), 
                   const key_equal & equal_func = key_equal(), 
                   const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: buckets must not be being used by any other resource\&.
.sp
\fBEffects\fR: Constructs an empty
unordered_set, storing a reference to the bucket array and copies of the key_hasher and equal_func functors\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor or invocation of hash_func or equal_func throws\&.
.sp
\fBNotes\fR: buckets array must be disposed only after *this is disposed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" distance: Class template hashtable
.\" Class template hashtable: distance

.sp

.nf
template<typename Iterator> 
  hashtable(bool unique, Iterator b, Iterator e, 
            const bucket_traits & b_traits, 
            const hasher & hash_func = hasher(), 
            const key_equal & equal_func = key_equal(), 
            const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: buckets must not be being used by any other resource and dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Constructs an empty container and inserts elements from [b, e)\&.
.sp
\fBComplexity\fR: If N is distance(b, e): Average case is O(N) (with a good hash function and with buckets_len >= N),worst case O(N^2)\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor or invocation of hasher or key_equal throws\&.
.sp
\fBNotes\fR: buckets array must be disposed only after *this is disposed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
hashtable(hashtable && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
hashtable & operator=(hashtable && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~hashtable();
.fi

.sp
\fBEffects\fR: Detaches all elements from this\&. The objects in the
unordered_set
are not deleted (i\&.e\&. no destructors are called)\&.
.sp
\fBComplexity\fR: Linear to the number of elements in the
unordered_set, if it\'s a safe\-mode or auto\-unlink value\&. Otherwise constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE

.SS "hashtable public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" begin: Class template hashtable
.\" Class template hashtable: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the beginning of the
unordered_set\&.
.sp
\fBComplexity\fR: Amortized constant time\&. Worst case (empty
unordered_set): O(this\->bucket_count())
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" begin: Class template hashtable
.\" Class template hashtable: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the
unordered_set\&.
.sp
\fBComplexity\fR: Amortized constant time\&. Worst case (empty
unordered_set): O(this\->bucket_count())
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" cbegin: Class template hashtable
.\" Class template hashtable: cbegin

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the
unordered_set\&.
.sp
\fBComplexity\fR: Amortized constant time\&. Worst case (empty
unordered_set): O(this\->bucket_count())
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the end of the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" cend: Class template hashtable
.\" Class template hashtable: cend

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
hasher hash_function() const;
.fi

.sp
\fBEffects\fR: Returns the hasher object used by the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If hasher copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
key_equal key_eq() const;
.fi

.sp
\fBEffects\fR: Returns the key_equal object used by the
unordered_set\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If key_equal copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container is empty\&.
.sp
\fBComplexity\fR: if constant\-time size and
cache_begin
options are disabled, average constant time (worst case, with empty() == true: O(this\->bucket_count())\&. Otherwise constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" size: Class template hashtable
.\" Class template hashtable: size

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of elements stored in the
unordered_set\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this if
constant_time_size
is false\&. Constant\-time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" swap: Class template hashtable
.\" Class template hashtable: swap
.\" swap: Class template hashtable
.\" Class template hashtable: swap

.sp

.nf
void swap(hashtable & other);
.fi

.sp
\fBRequires\fR: the hasher and the equality function unqualified swap call should not throw\&.
.sp
\fBEffects\fR: Swaps the contents of two unordered_sets\&. Swaps also the contained bucket array and equality and hasher functors\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the swap() call for the comparison or hash functors found using ADL throw\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" clone_from: Class template hashtable
.\" Class template hashtable: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(const hashtable & src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw Cloner should yield to nodes that compare equal and produce the same hash than the original node\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this\&. The hash function and the equality predicate are copied from the source\&.
.sp
If
store_hash
option is true, this method does not use the hash function\&.
.sp
If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner or hasher throw or hash or equality predicate copying throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" clone_from: Class template hashtable
.\" Class template hashtable: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(hashtable && src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw Cloner should yield to nodes that compare equal and produce the same hash than the original node\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this\&. The hash function and the equality predicate are copied from the source\&.
.sp
If
store_hash
option is true, this method does not use the hash function\&.
.sp
If any operation throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner or hasher throw or hash or equality predicate copying throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" insert_equal: Class template hashtable
.\" Class template hashtable: insert_equal

.sp

.nf
iterator insert_equal(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue
.sp
\fBEffects\fR: Inserts the value into the
unordered_set\&.
.sp
\fBReturns\fR: An iterator to the inserted value\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" distance: Class template hashtable
.\" Class template hashtable: distance
.\" insert_equal: Class template hashtable
.\" Class template hashtable: insert_equal

.sp

.nf
template<typename Iterator> void insert_equal(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Equivalent to this\->insert_equal(t) for each element in [b, e)\&.
.sp
\fBComplexity\fR: Average case O(N), where N is distance(b, e)\&. Worst case O(N*this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Basic guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" insert_unique: Class template hashtable
.\" Class template hashtable: insert_unique

.sp

.nf
std::pair< iterator, bool > insert_unique(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue
.sp
\fBEffects\fR: Tries to inserts value into the
unordered_set\&.
.sp
\fBReturns\fR: If the value is not already present inserts it and returns a pair containing the iterator to the new value and true\&. If there is an equivalent value returns a pair containing an iterator to the already present value and false\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" distance: Class template hashtable
.\" Class template hashtable: distance
.\" insert_unique: Class template hashtable
.\" Class template hashtable: insert_unique

.sp

.nf
template<typename Iterator> void insert_unique(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Equivalent to this\->insert_unique(t) for each element in [b, e)\&.
.sp
\fBComplexity\fR: Average case O(N), where N is distance(b, e)\&. Worst case O(N*this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Basic guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" insert_unique_check: Class template hashtable
.\" Class template hashtable: insert_unique_check

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  std::pair< iterator, bool > 
  insert_unique_check(const KeyType & key, KeyHasher hash_func, 
                      KeyEqual equal_func, insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Checks if a value can be inserted in the
unordered_set, using a user provided key instead of the value itself\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing an iterator to the already present value and false\&. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&. Strong guarantee\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the node that is used to impose the hash or the equality is much cheaper to construct than the value_type and this function offers the possibility to use that the part to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant\-time\&.
.sp
"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the
unordered_set\&.
.sp
After a successful rehashing insert_commit_data remains valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" insert_unique_commit: Class template hashtable
.\" Class template hashtable: insert_unique_commit

.sp

.nf
iterator insert_unique_commit(reference value, 
                              const insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: value must be an lvalue of type value_type\&. commit_data must have been obtained from a previous call to "insert_check"\&. No objects should have been inserted or erased from the
unordered_set
between the "insert_check" that filled "commit_data" and the call to "insert_commit"\&.
.sp
\fBEffects\fR: Inserts the value in the
unordered_set
using the information obtained from the "commit_data" that a previous "insert_check" filled\&.
.sp
\fBReturns\fR: An iterator to the newly inserted object\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function has only sense if a "insert_check" has been previously executed to fill "commit_data"\&. No value should be inserted or erased between the "insert_check" and "insert_commit" calls\&.
.sp
After a successful rehashing insert_commit_data remains valid\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" erase: Class template hashtable
.\" Class template hashtable: erase

.sp

.nf
void erase(const_iterator i);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by i\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased element\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" erase: Class template hashtable
.\" Class template hashtable: erase

.sp

.nf
void erase(const_iterator b, const_iterator e);
.fi

.sp
\fBEffects\fR: Erases the range pointed to by b end e\&.
.sp
\fBComplexity\fR: Average case O(distance(b, e)), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" erase: Class template hashtable
.\" Class template hashtable: erase

.sp

.nf
size_type erase(const key_type & key);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given value\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" erase: Class template hashtable
.\" Class template hashtable: erase

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  size_type erase(const KeyType & key, KeyHasher hash_func, 
                  KeyEqual equal_func);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Erases all the elements that have the same hash and compare equal with the given key\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" erase_and_dispose: Class template hashtable
.\" Class template hashtable: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  void erase_and_dispose(const_iterator i, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element pointed to by i\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" erase_and_dispose: Class template hashtable
.\" Class template hashtable: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  void erase_and_dispose(const_iterator b, const_iterator e, 
                         Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the range pointed to by b end e\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBComplexity\fR: Average case O(distance(b, e)), worst case O(this\->size())\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" erase_and_dispose: Class template hashtable
.\" Class template hashtable: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  size_type erase_and_dispose(const key_type & key, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given value\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" erase_and_dispose: Class template hashtable
.\" Class template hashtable: erase_and_dispose

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual, 
         typename Disposer> 
  size_type erase_and_dispose(const KeyType & key, KeyHasher hash_func, 
                              KeyEqual equal_func, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "equal_func"\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&. Basic guarantee\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" clear: Class template hashtable
.\" Class template hashtable: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all of the elements\&.
.sp
\fBComplexity\fR: Linear to the number of elements on the container\&. if it\'s a safe\-mode or auto\-unlink value_type\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" clear_and_dispose: Class template hashtable
.\" Class template hashtable: clear_and_dispose

.sp

.nf
template<typename Disposer> void clear_and_dispose(Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all of the elements\&.
.sp
\fBComplexity\fR: Linear to the number of elements on the container\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" count: Class template hashtable
.\" Class template hashtable: count

.sp

.nf
size_type count(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given value
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" count: Class template hashtable
.\" Class template hashtable: count

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  size_type count(const KeyType & key, KeyHasher hash_func, 
                  KeyEqual equal_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Returns the number of contained elements with the given key
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal throw\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end
.\" find: Class template hashtable
.\" Class template hashtable: find

.sp

.nf
iterator find(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element is equal to "value" or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end
.\" find: Class template hashtable
.\" Class template hashtable: find

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  iterator find(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Finds an iterator to the first element whose key is "key" according to the given hash and equality functor or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end
.\" find: Class template hashtable
.\" Class template hashtable: find

.sp

.nf
const_iterator find(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Finds a const_iterator to the first element whose key is "key" or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end
.\" find: Class template hashtable
.\" Class template hashtable: find

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  const_iterator 
  find(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Finds an iterator to the first element whose key is "key" according to the given hasher and equality functor or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Average case O(1), worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns a range containing all elements with values equivalent to value\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  std::pair< iterator, iterator > 
  equal_range(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func);
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Returns a range containing all elements with equivalent keys\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(key, hash_func, equal_func))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If hash_func or the equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns a range containing all elements with values equivalent to value\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(value))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the internal hasher or the equality functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyHasher, typename KeyEqual> 
  std::pair< const_iterator, const_iterator > 
  equal_range(const KeyType & key, KeyHasher hash_func, KeyEqual equal_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
"equal_func" must be a equality function that induces the same equality as key_equal\&. The difference is that "equal_func" compares an arbitrary key with the contained values\&.
.sp
\fBEffects\fR: Returns a range containing all elements with equivalent keys\&. Returns std::make_pair(this\->end(), this\->end()) if no such elements exist\&.
.sp
\fBComplexity\fR: Average case O(this\->count(key, hash_func, equal_func))\&. Worst case O(this\->size())\&.
.sp
\fBThrows\fR: If the hasher or equal_func throw\&.
.sp
\fBNote\fR: This function is used when constructing a value_type is expensive and the value_type can be compared with a cheaper key type\&. Usually this key is part of the value_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" iterator_to: Class template hashtable
.\" Class template hashtable: iterator_to

.sp

.nf
iterator iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the internal hash function throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" iterator_to: Class template hashtable
.\" Class template hashtable: iterator_to

.sp

.nf
const_iterator iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the internal hash function throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" local_iterator_to: Class template hashtable
.\" Class template hashtable: local_iterator_to

.sp

.nf
local_iterator local_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" local_iterator_to: Class template hashtable
.\" Class template hashtable: local_iterator_to

.sp

.nf
const_local_iterator local_iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}

.sp

.nf
size_type bucket_count() const;
.fi

.sp
\fBEffects\fR: Returns the number of buckets passed in the constructor or the last rehash function\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}

.sp

.nf
size_type bucket_size(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns the number of elements in the nth bucket\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}

.sp

.nf
size_type bucket(const key_type & k) const;
.fi

.sp
\fBEffects\fR: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the hash functor throws\&.
.sp
\fBNote\fR: the return value is in the range [0, this\->bucket_count())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyHasher> 
  size_type bucket(const KeyType & k, KeyHasher hash_func) const;
.fi

.sp
\fBRequires\fR: "hash_func" must be a hash function that induces the same hash values as the stored hasher\&. The difference is that "hash_func" hashes the given key instead of the value_type\&.
.sp
\fBEffects\fR: Returns the index of the bucket in which elements with keys equivalent to k would be found, if any such element existed\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If hash_func throws\&.
.sp
\fBNote\fR: the return value is in the range [0, this\->bucket_count())\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}

.sp

.nf
bucket_ptr bucket_pointer() const;
.fi

.sp
\fBEffects\fR: Returns the bucket array pointer passed in the constructor or the last rehash function\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" begin: Class template hashtable
.\" Class template hashtable: begin

.sp

.nf
local_iterator begin(size_type n);
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a local_iterator pointing to the beginning of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}
.\" begin: Class template hashtable
.\" Class template hashtable: begin

.sp

.nf
const_local_iterator begin(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}
.\" cbegin: Class template hashtable
.\" Class template hashtable: cbegin

.sp

.nf
const_local_iterator cbegin(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the beginning of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end

.sp

.nf
local_iterator end(size_type n);
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a local_iterator pointing to the end of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}
.\" end: Class template hashtable
.\" Class template hashtable: end

.sp

.nf
const_local_iterator end(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" cend: Class template hashtable
.\" Class template hashtable: cend

.sp

.nf
const_local_iterator cend(size_type n) const;
.fi

.sp
\fBRequires\fR: n is in the range [0, this\->bucket_count())\&.
.sp
\fBEffects\fR: Returns a const_local_iterator pointing to the end of the sequence stored in the bucket n\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: [this\->begin(n), this\->end(n)) is a valid range containing all of the elements in the nth bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" rehash: Class template hashtable
.\" Class template hashtable: rehash

.sp

.nf
void rehash(const bucket_traits & new_bucket_traits);
.fi

.sp
\fBRequires\fR: new_bucket_traits can hold a pointer to a new bucket array or the same as the old bucket array with a different length\&. new_size is the length of the the array pointed by new_buckets\&. If new_bucket_traits\&.bucket_begin() == this\->bucket_pointer() new_bucket_traits\&.bucket_count() can be bigger or smaller than this\->bucket_count()\&. \'new_bucket_traits\' copy constructor should not throw\&.
.sp
\fBEffects\fR: Updates the internal reference with the new bucket, erases the values from the old bucket and inserts then in the new one\&. Bucket traits hold by *this is assigned from new_bucket_traits\&. If the container is configured as incremental<>, the split bucket is set to the new bucket_count()\&.
.sp
If
store_hash
option is true, this method does not use the hash function\&.
.sp
\fBComplexity\fR: Average case linear in this\->size(), worst case quadratic\&.
.sp
\fBThrows\fR: If the hasher functor throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" incremental_rehash: Class template hashtable
.\" Class template hashtable: incremental_rehash

.sp

.nf
bool incremental_rehash(bool grow = true);
.fi

.sp
\fBRequires\fR:
.sp
\fBEffects\fR:
.sp
\fBComplexity\fR:
.sp
\fBThrows\fR:
.sp
\fBNote\fR: this method is only available if incremental<true> option is activated\&.
.sp
grow
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" size: Class template hashtable
.\" Class template hashtable: size
.\" incremental_rehash: Class template hashtable
.\" Class template hashtable: incremental_rehash

.sp

.nf
bool incremental_rehash(const bucket_traits & new_bucket_traits);
.fi

.sp
\fBEffects\fR: If new_bucket_traits\&.bucket_count() is not this\->bucket_count()/2 or this\->bucket_count()*2, or this\->split_bucket() != new_bucket_traits\&.bucket_count() returns false and does nothing\&.
.sp
Otherwise, copy assigns new_bucket_traits to the internal
bucket_traits
and transfers all the objects from old buckets to the new ones\&.
.sp
\fBComplexity\fR: Linear to size()\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBNote\fR: this method is only available if incremental<true> option is activated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}

.sp

.nf
size_type split_count() const;
.fi

.sp
\fBRequires\fR: incremental<> option must be set
.sp
\fBEffects\fR: returns the current split count
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing
.RE

.SS "hashtable public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" s_local_iterator_to: Class template hashtable
.\" Class template hashtable: s_local_iterator_to

.sp

.nf
static local_iterator s_local_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" s_local_iterator_to: Class template hashtable
.\" Class template hashtable: s_local_iterator_to

.sp

.nf
static const_local_iterator s_local_iterator_to(const_reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a
unordered_set
of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_local_iterator belonging to the
unordered_set
that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" suggested_upper_bucket_count: Class template hashtable
.\" Class template hashtable: suggested_upper_bucket_count

.sp

.nf
static size_type suggested_upper_bucket_count(size_type n);
.fi

.sp
\fBEffects\fR: Returns the nearest new bucket count optimized for the container that is bigger or equal than n\&. This suggestion can be used to create bucket arrays with a size that will usually improve container\'s performance\&. If such value does not exist, the higher possible value is returned\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" suggested_lower_bucket_count: Class template hashtable
.\" Class template hashtable: suggested_lower_bucket_count

.sp

.nf
static size_type suggested_lower_bucket_count(size_type n);
.fi

.sp
\fBEffects\fR: Returns the nearest new bucket count optimized for the container that is smaller or equal than n\&. This suggestion can be used to create bucket arrays with a size that will usually improve container\'s performance\&. If such value does not exist, the lowest possible value is returned\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


