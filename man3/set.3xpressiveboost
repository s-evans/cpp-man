.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "GLOBAL SET" 3 "" "" ""
.SH "NAME"
boost::xpressive::set \- Used to create character sets\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/xpressive/regex_primitives\&.hpp>

\fIunspecified\fR set;
.fi
.SH "DESCRIPTION"
.PP
There are two ways to create character sets with the \'set\' identifier\&. The easiest is to create a comma\-separated list of the characters in the set, as in (set= \'a\',\'b\',\'c\')\&. This set will match \'a\', \'b\', or \'c\'\&. The other way is to define the set as an argument to the set subscript operator\&. For instance, set[ \'a\' | range(\'b\',\'c\') | digit ] will match an \'a\', \'b\', \'c\' or a digit character\&.
.PP
To complement a set, apply the \'~\' operator\&. For instance, ~(set= \'a\',\'b\',\'c\') will match any character that is not an \'a\', \'b\', or \'c\'\&.
.PP
Sets can be composed of other, possibly complemented, sets\&. For instance, set[ ~digit | ~(set= \'a\',\'b\',\'c\') ]\&.

