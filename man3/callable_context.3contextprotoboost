.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPL" 3 "" "" ""
.SH "NAME"
boost::proto::context::callable_context \- An evaluation context adaptor that makes authoring a context a simple matter of writing function overloads, rather then writing template specializations\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/context/callable\&.hpp>

template<typename Context, 
         typename DefaultCtx = proto::context::default_context> 
struct callable_context {
  // member classes/structs/unions
  template<typename Expr, typename ThisContext = Context> 
  struct eval :  \fIsee\-below\fR {
  };
};
.fi
.SH "DESCRIPTION"
.PP

proto::callable_context<>
is a base class that implements the context protocol by passing fanned\-out expression nodes to the derived context, making it easy to customize the handling of expression types by writing function overloads\&. Only those expression types needing special handling require explicit handling\&. All others are dispatched to a user\-specified default context,
DefaultCtx\&.
.PP

proto::callable_context<>
is defined simply as:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
template<typename Context, typename DefaultCtx = default_context>
struct callable_context {
  template<typename Expr, typename ThisContext = Context>
  struct eval :
    mpl::if_<
      is_expr_handled_<Expr, Context>, // For exposition
      proto::context::callable_eval<Expr, ThisContext>,
      typename DefaultCtx::template eval<Expr, Context>
    >::type
  {};
};
.fi
.if n \{\
.RE
.\}
.sp

.PP
The Boolean metafunction
is_expr_handled_<>
uses metaprogramming tricks to determine whether
Context
has an overloaded function call operator that accepts the fanned\-out constituents of an expression of type
Expr\&. If so, the handling of the expression is dispatched to
proto::context::callable_eval<>\&. If not, it is dispatched to the user\-specified
DefaultCtx\&.
.PP

\fBExample:\fR
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
// An evaluation context that increments all
// integer terminals in\-place\&.
struct increment_ints :
  proto::context::callable_context<
    increment_ints const                // derived context
    proto::context::null_context const  // fall\-back context
  >
{
    typedef void result_type;

    // Handle int terminals here:
    void operator()(proto::tag::terminal, int &i) const
    {
       ++i;
    }
};
.fi
.if n \{\
.RE
.\}
.sp

.PP
With
increment_ints, we can do the following:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
proto::literal<int> i = 0, j = 10;
proto::eval( i \- j * 3\&.14, increment_ints() );

assert( i\&.get() == 1 && j\&.get() == 11 );
.fi
.if n \{\
.RE
.\}
.sp


