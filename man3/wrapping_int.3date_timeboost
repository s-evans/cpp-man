.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::date_time::wrapping_int \- A wrapping integer used to support time durations (WARNING: only instantiate with a signed type)
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/wrapping_int\&.hpp>

template<typename int_type_, int_type_ wrap_val> 
class wrapping_int {
public:
  // types
  typedef int_type_ int_type;

  // construct/copy/destruct
  wrapping_int(int_type);

  // public static functions
  static int_type wrap_value();

  // public member functions
  int_type as_int() const;
  operator int_type() const;
  template<typename IntT> IntT add(IntT);
  template<typename IntT> IntT subtract(IntT);

  // private member functions
  template<typename IntT> IntT calculate_wrap(IntT);
};
.fi
.SH "DESCRIPTION"
.PP
In composite date and time types this type is used to wrap at the day boundary\&. Ex: A wrapping_int<short, 10> will roll over after nine, and roll under below zero\&. This gives a range of [0,9]
.PP
NOTE: it is strongly recommended that
wrapping_int2
be used instead of
wrapping_int
as
wrapping_int
is to be depricated at some point soon\&.
.PP
Also Note that warnings will occur if instantiated with an unsigned type\&. Only a signed type should be used!
.SS "wrapping_int public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
wrapping_int(int_type v);
.fi

Add, return true if wrapped\&. .RE

.SS "wrapping_int public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static int_type wrap_value();
.fi

.RE

.SS "wrapping_int public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
int_type as_int() const;
.fi

Explicit converion method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
operator int_type() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename IntT> IntT add(IntT v);
.fi

.sp
Add, return number of wraps performed\&. The sign of the returned value will indicate which direction the wraps went\&. Ex: add a negative number and wrapping under could occur, this would be indicated by a negative return value\&. If wrapping over took place, a positive value would be returned
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename IntT> IntT subtract(IntT v);
.fi

.sp
Subtract will return \'+d\' if wrapping under took place (\'d\' is the number of wraps) The sign of the returned value will indicate which direction the wraps went (positive indicates wrap under, negative indicates wrap over)\&. Ex: subtract a negative number and wrapping over could occur, this would be indicated by a negative return value\&. If wrapping under took place, a positive value would be returned\&.
.RE

.SS "wrapping_int private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename IntT> IntT calculate_wrap(IntT wrap);
.fi

.RE


