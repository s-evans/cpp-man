.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STR" 3 "" "" ""
.SH "NAME"
boost::container::constructible_with_allocator_suffix
.SH "SYNOPSIS"
.\" constructible_with_allocator_suffix: Struct template constructible_with_allocator_suffix
.\" Struct template constructible_with_allocator_suffix: constructible_with_allocator_suffix

.sp
.nf
// In header: <boost/container/scoped_allocator\&.hpp>

template<typename T> 
struct constructible_with_allocator_suffix {

  // public data members
  static const bool value;
};
.fi
.SH "DESCRIPTION"
.\" constructible_with_allocator_suffix: Struct template constructible_with_allocator_suffix
.\" Struct template constructible_with_allocator_suffix: constructible_with_allocator_suffix
.\" allocator: Struct template constructible_with_allocator_suffix
.\" Struct template constructible_with_allocator_suffix: allocator
.\" allocator_type: Struct template constructible_with_allocator_suffix
.\" Struct template constructible_with_allocator_suffix: allocator_type
.\" allocator: Struct template constructible_with_allocator_suffix
.\" Struct template constructible_with_allocator_suffix: allocator
.PP
\fBRemark\fR: if a specialization constructible_with_allocator_suffix<X>::value is true, indicates that T may be constructed with an allocator as its last constructor argument\&. Ideally, all constructors of T (including the copy and move constructors) should have a variant that accepts a final argument of allocator_type\&.
.PP
\fBRequires\fR: if a specialization constructible_with_allocator_suffix<X>::value is true, T must have a nested type, allocator_type and at least one constructor for which allocator_type is the last parameter\&. If not all constructors of T can be called with a final allocator_type argument, and if T is used in a context where a container must call such a constructor, then the program is ill\-formed\&.
.PP
template <class T, class Allocator = allocator<T> > class Z { public: typedef Allocator allocator_type;
.PP
// Default constructor with optional allocator suffix Z(const allocator_type& a = allocator_type());
.PP
// Copy constructor and allocator\-extended copy constructor Z(const Z& zz); Z(const Z& zz, const allocator_type& a); };
.PP
// Specialize trait for class template Z template <class T, class Allocator = allocator<T> > struct constructible_with_allocator_suffix<Z<T,Allocator> > { static const bool value = true; };
.PP
\fBNote\fR: This trait is a workaround inspired by "N2554: The Scoped A Model (Rev 2)" (Pablo Halpern, 2008\-02\-29) to backport the scoped allocator model to C++03, as in C++03 there is no mechanism to detect if a type can be constructed from arbitrary arguments\&. Applications aiming portability with several compilers should always define this trait\&.
.PP
In conforming C++11 compilers or compilers supporting SFINAE expressions (when BOOST_NO_SFINAE_EXPR is NOT defined), this trait is ignored and C++11 rules will be used to detect if a type should be constructed with suffix or prefix allocator arguments\&.

