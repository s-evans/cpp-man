.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMP" 3 "" "" ""
.SH "NAME"
boost::proto::external_transforms \- A map from grammars to transforms, used as a way to externally associate transforms\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/transform/when\&.hpp>

template<typename\&.\&.\&. When> 
struct external_transforms {
  // types
  typedef mpl::map< typename to_mpl_pair< When >::type\&.\&.\&. > map_type;  // For exposition only\&.

  // member classes/structs/unions
  template<typename Grammar> 
  struct when :
     proto::otherwise< typename mpl::at< map_type, Grammar >::type >
  {
  };
};
.fi
.SH "DESCRIPTION"
.PP
It is sometimes desirable to define a grammar that can be customized with different sets of transforms\&. To do that, where you would normally specify a transform within a grammar, you can instead put
proto::external_transform; for example:
proto::when< some_grammar, proto::external_transform >\&. Then, when invoking the grammar, you can pass an approriately\-defined instance of
proto::external_transforms
as the Data parameter\&. When an expression matches
some_grammar, Proto will look up the approprite transform in the Data parameter using
some_grammar
as a key\&.
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
struct int_terminal
  : proto::terminal<int>
{};

struct char_terminal
  : proto::terminal<char>
{};

struct my_grammar
  : proto::or_<
        // The next two grammar rules are customization points\&.
        // The associated transforms are specified externally
        // using external_transforms below\&.
        proto::when< int_terminal, proto::external_transform >
      , proto::when< char_terminal, proto::external_transform >
      , proto::when<
            proto::plus< my_grammar, my_grammar >
          , proto::fold< proto::_, int(), my_grammar >
        >
    >
{};

// Here is where the transforms are associated with the
// grammar rules above\&.
struct my_transforms
  : proto::external_transforms<
        proto::when<int_terminal, print(proto::_value)>
      , proto::when<char_terminal, print(proto::_value)>
    >
{};

// \&.\&.\&.

proto::literal<int> i(1);
proto::literal<char> c(\'a\');
my_transforms trx;

// Evaluate "i+c" using my_grammar with the specified transforms:
my_grammar()(i + c, 0, trx);

// If you would also like to pass arbitrary data along with the
// transforms, you can use a transform environment, as so:
my_grammar()(i + c, 0, (proto::data = 42, proto::transforms = trx));
.fi
.if n \{\
.RE
.\}
.sp


