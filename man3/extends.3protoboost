.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE E" 3 "" "" ""
.SH "NAME"
boost::proto::extends \- For adding behaviors to a Proto expression template\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/extends\&.hpp>

template<typename Expr, typename Derived, 
         typename Domain = proto::default_domain> 
struct extends {
  // types
  typedef typename Expr::proto_base_expr          proto_base_expr;   
  typedef Domain                                  proto_domain;      
  typedef Derived                                 proto_derived_expr;
  typedef extends                                 proto_extends;     
  typedef typename proto_base_expr::proto_tag     proto_tag;         
  typedef typename proto_base_expr::proto_args    proto_args;        
  typedef typename proto_base_expr::proto_arity   proto_arity;       
  typedef typename proto_base_expr::proto_grammar proto_grammar;     
  typedef typename proto_base_expr::proto_child\fIN\fR  proto_childN;        // For each \fIN\fR in \fI[0,max(1,proto_arity_c))\fR

  // member classes/structs/unions
  template<typename Signature> 
  struct result {
    // types
    typedef \fIunspecified\fR type;
  };

  // construct/copy/destruct
  extends();
  extends(extends const &);
  extends(Expr const &);

  // public static functions
  static Derived const make(Expr const &);

  // public member functions
  proto_base_expr & proto_base();
  proto_base_expr const & proto_base() const;
  template<typename A> \fIunspecified\fR operator=(A &);
  template<typename A> \fIunspecified\fR operator=(A const &);
  template<typename A> \fIunspecified\fR operator=(A &) const;
  template<typename A> \fIunspecified\fR operator=(A const &) const;
  template<typename A> \fIunspecified\fR operator[](A &);
  template<typename A> \fIunspecified\fR operator[](A const &);
  template<typename A> \fIunspecified\fR operator[](A &) const;
  template<typename A> \fIunspecified\fR operator[](A const &) const;
  template<typename\&.\&.\&. A> \fIunspecified\fR operator()(A const &\&.\&.\&.);
  template<typename\&.\&.\&. A> \fIunspecified\fR operator()(A const &\&.\&.\&.) const;

  // public data members
  Expr proto_expr_;  // For exposition only\&.
  static const long proto_arity_c;  // = proto_base_expr::proto_arity_c;
};
.fi
.SH "DESCRIPTION"
.PP
Use
proto::extends<>
to give expressions in your domain custom data members and member functions\&.
.PP
Conceptually, using
proto::extends<>
is akin to inheriting from
proto::expr<>
and adding your own members\&. Using
proto::extends<>
is generally preferrable to straight inheritance because the members that would be inherited from
proto::expr<>
would be wrong; they would incorrectly slice off your additional members when building larger expressions from smaller ones\&.
proto::extends<>
automatically gives your expression types the appropriate operator overloads that preserve your domain\-specific members when composing expression trees\&.
.PP
Expression extensions are typically defined as follows:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
template< typename Expr >
struct my_expr
  : proto::extends<
        Expr            // The expression type we\'re extending
      , my_expr< Expr > // The type we\'re defining
      , my_domain       // The domain associated with this expression extension
    >
{
    // An expression extension is constructed from the expression
    // it is extending\&.
    my_expr( Expr const & e = Expr() )
      : my_expr::proto_extends( e )
    {}
    
    // Unhide proto::extends::operator=
    // (This is only necessary if a lazy assignment operator
    // makes sense for your domain\-specific language\&.)
    BOOST_PROTO_EXTENDS_USING_ASSIGN(my_expr)
    
    /*
    \&.\&.\&. domain\-specific members go here \&.\&.\&.
    */
};
.fi
.if n \{\
.RE
.\}
.sp

.PP
See also:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_EXTENDS().RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_EXTENDS_USING_ASSIGN().RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_EXTENDS_USING_ASSIGN_NON_DEPENDENT().RE
.sp
.RE

.SS "extends public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
extends();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
extends(extends const & that);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
extends(Expr const & expr_);
.fi

.RE

.SS "extends public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static Derived const make(Expr const & expr);
.fi

.sp
Construct an expression extension from the base expression\&.
.RE

.SS "extends public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
proto_base_expr & proto_base();
.fi

.PP
Returns:
.RS 4
proto_expr_\&.proto_base().RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
proto_base_expr const & proto_base() const;
.fi

.PP
Returns:
.RS 4
proto_expr_\&.proto_base().RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator=(A & a);
.fi

.sp
Lazy assignment expression
.PP
Returns:
.RS 4
A new expression node representing the assignment operation\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator=(A const & a);
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator=(A & a) const;
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator=(A const & a) const;
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator[](A & a);
.fi

.sp
Lazy subscript expression
.PP
Returns:
.RS 4
A new expression node representing the subscript operation\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator[](A const & a);
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator[](A & a) const;
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename A> \fIunspecified\fR operator[](A const & a) const;
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
template<typename\&.\&.\&. A> \fIunspecified\fR operator()(A const &\&.\&.\&. a);
.fi

.sp
Lazy function call
.PP
Returns:
.RS 4
A new expression node representing the function call operation\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
template<typename\&.\&.\&. A> \fIunspecified\fR operator()(A const &\&.\&.\&. a) const;
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


