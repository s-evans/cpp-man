.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::container::flat_multiset
.SH "SYNOPSIS"
.\" value_type: Class template flat_multiset
.\" Class template flat_multiset: value_type
.\" value_compare: Class template flat_multiset
.\" Class template flat_multiset: value_compare
.\" upper_bound: Class template flat_multiset
.\" Class template flat_multiset: upper_bound
.\" swap: Class template flat_multiset
.\" Class template flat_multiset: swap
.\" stored_allocator_type: Class template flat_multiset
.\" Class template flat_multiset: stored_allocator_type
.\" size_type: Class template flat_multiset
.\" Class template flat_multiset: size_type
.\" shrink_to_fit: Class template flat_multiset
.\" Class template flat_multiset: shrink_to_fit
.\" reverse_iterator: Class template flat_multiset
.\" Class template flat_multiset: reverse_iterator
.\" reserve: Class template flat_multiset
.\" Class template flat_multiset: reserve
.\" rend: Class template flat_multiset
.\" Class template flat_multiset: rend
.\" reference: Class template flat_multiset
.\" Class template flat_multiset: reference
.\" rbegin: Class template flat_multiset
.\" Class template flat_multiset: rbegin
.\" pointer: Class template flat_multiset
.\" Class template flat_multiset: pointer
.\" nth: Class template flat_multiset
.\" Class template flat_multiset: nth
.\" lower_bound: Class template flat_multiset
.\" Class template flat_multiset: lower_bound
.\" key_type: Class template flat_multiset
.\" Class template flat_multiset: key_type
.\" key_compare: Class template flat_multiset
.\" Class template flat_multiset: key_compare
.\" iterator: Class template flat_multiset
.\" Class template flat_multiset: iterator
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert
.\" index_of: Class template flat_multiset
.\" Class template flat_multiset: index_of
.\" get_stored_allocator: Class template flat_multiset
.\" Class template flat_multiset: get_stored_allocator
.\" find: Class template flat_multiset
.\" Class template flat_multiset: find
.\" erase: Class template flat_multiset
.\" Class template flat_multiset: erase
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" emplace: Class template flat_multiset
.\" Class template flat_multiset: emplace
.\" difference_type: Class template flat_multiset
.\" Class template flat_multiset: difference_type
.\" count: Class template flat_multiset
.\" Class template flat_multiset: count
.\" const_reverse_iterator: Class template flat_multiset
.\" Class template flat_multiset: const_reverse_iterator
.\" const_reference: Class template flat_multiset
.\" Class template flat_multiset: const_reference
.\" const_pointer: Class template flat_multiset
.\" Class template flat_multiset: const_pointer
.\" const_iterator: Class template flat_multiset
.\" Class template flat_multiset: const_iterator
.\" clear: Class template flat_multiset
.\" Class template flat_multiset: clear
.\" begin: Class template flat_multiset
.\" Class template flat_multiset: begin
.\" allocator_type: Class template flat_multiset
.\" Class template flat_multiset: allocator_type
.\" allocator_traits_type: Class template flat_multiset
.\" Class template flat_multiset: allocator_traits_type

.sp
.nf
// In header: <boost/container/flat_set\&.hpp>

template<typename Key, typename Compare = std::less<Key>, 
         typename Allocator = new_allocator<Key> > 
class flat_multiset {
public:
  // types
  typedef Key                                                                key_type;              
  typedef Key                                                                value_type;            
  typedef Compare                                                            key_compare;           
  typedef Compare                                                            value_compare;         
  typedef ::boost::container::allocator_traits< Allocator >                  allocator_traits_type; 
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef implementation_defined                                             stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  explicit flat_multiset();
  explicit flat_multiset(const Compare &, 
                         const allocator_type & = allocator_type());
  explicit flat_multiset(const allocator_type &);
  template<typename InputIterator> 
    flat_multiset(InputIterator, InputIterator, const Compare & = Compare(), 
                  const allocator_type & = allocator_type());
  template<typename InputIterator> 
    flat_multiset(InputIterator, InputIterator, const allocator_type &);
  template<typename InputIterator> 
    flat_multiset(ordered_range_t, InputIterator, InputIterator, 
                  const Compare & = Compare(), 
                  const allocator_type & = allocator_type());
  flat_multiset(std::initializer_list< value_type >, 
                const Compare & = Compare(), 
                const allocator_type & = allocator_type());
  flat_multiset(std::initializer_list< value_type >, const allocator_type &);
  flat_multiset(ordered_unique_range_t, std::initializer_list< value_type >, 
                const Compare & = Compare(), 
                const allocator_type & = allocator_type());
  flat_multiset(const flat_multiset &);
  flat_multiset(flat_multiset &&);
  flat_multiset(const flat_multiset &, const allocator_type &);
  flat_multiset(flat_multiset &&, const allocator_type &);
  flat_multiset & operator=(const flat_multiset &);
  flat_multiset & 
  operator=(flat_multiset &&) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
  flat_multiset & operator=(std::initializer_list< value_type >);

  // public member functions
  allocator_type get_allocator() const noexcept;
  stored_allocator_type & get_stored_allocator() noexcept;
  const stored_allocator_type & get_stored_allocator() const noexcept;
  iterator begin() noexcept;
  const_iterator begin() const;
  const_iterator cbegin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  const_iterator cend() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const noexcept;
  size_type size() const noexcept;
  size_type max_size() const noexcept;
  size_type capacity() const noexcept;
  void reserve(size_type);
  void shrink_to_fit();
  template<class\&.\&.\&. Args> iterator emplace(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace_hint(const_iterator, Args &&\&.\&.\&.);
  iterator insert(const value_type &);
  iterator insert(value_type &&);
  iterator insert(const_iterator, const value_type &);
  iterator insert(const_iterator, value_type &&);
  template<typename InputIterator> void insert(InputIterator, InputIterator);
  template<typename InputIterator> 
    void insert(ordered_range_t, InputIterator, InputIterator);
  void insert(std::initializer_list< value_type >);
  void insert(ordered_range_t, std::initializer_list< value_type >);
  iterator erase(const_iterator);
  size_type erase(const key_type &);
  iterator erase(const_iterator, const_iterator);
  void swap(flat_multiset &) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
  void clear() noexcept;
  key_compare key_comp() const;
  value_compare value_comp() const;
  iterator find(const key_type &);
  const_iterator find(const key_type &) const;
  iterator nth(size_type) noexcept;
  const_iterator nth(size_type) const noexcept;
  size_type index_of(iterator) noexcept;
  size_type index_of(const_iterator) const noexcept;
  size_type count(const key_type &) const;
  iterator lower_bound(const key_type &);
  const_iterator lower_bound(const key_type &) const;
  iterator upper_bound(const key_type &);
  const_iterator upper_bound(const key_type &) const;
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  std::pair< iterator, iterator > equal_range(const key_type &);

  // friend functions
  friend bool operator==(const flat_multiset &, const flat_multiset &);
  friend bool operator!=(const flat_multiset &, const flat_multiset &);
  friend bool operator<(const flat_multiset &, const flat_multiset &);
  friend bool operator>(const flat_multiset &, const flat_multiset &);
  friend bool operator<=(const flat_multiset &, const flat_multiset &);
  friend bool operator>=(const flat_multiset &, const flat_multiset &);
  friend void swap(flat_multiset &, flat_multiset &);
};
.fi
.SH "DESCRIPTION"
.PP
flat_multiset
is a Sorted Associative Container that stores objects of type Key\&.
.PP
flat_multiset
can store multiple copies of the same key value\&.
.PP
flat_multiset
is similar to std::multiset but it\'s implemented like an ordered vector\&. This means that inserting a new element into a
flat_multiset
invalidates previous iterators and references
.PP
Erasing an element invalidates iterators and references pointing to elements that come after (their keys are bigger) the erased element\&.
.PP
This container provides random\-access iterators\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Key
.fi

.sp
is the type to be inserted in the multiset, which is also the key_type
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Compare = std::less<Key>
.fi

.sp
is the comparison functor used to order keys
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<Key>
.fi

.sp
is the allocator to be used to allocate memory for this container
.RE

.SS "flat_multiset public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit flat_multiset();
.fi

.sp
\fBEffects\fR: Default constructs an empty container\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit flat_multiset(const Compare & comp, 
                       const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty container using the specified comparison object and allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit flat_multiset(const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty container using the specified allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  flat_multiset(InputIterator first, InputIterator last, 
                const Compare & comp = Compare(), 
                const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  flat_multiset(InputIterator first, InputIterator last, 
                const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty container using the specified allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  flat_multiset(ordered_range_t, InputIterator first, InputIterator last, 
                const Compare & comp = Compare(), 
                const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty
flat_multiset
using the specified comparison object and allocator, and inserts elements from the ordered range [first ,last )\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [first ,last) must be ordered according to the predicate\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
flat_multiset(std::initializer_list< value_type > il, 
              const Compare & comp = Compare(), 
              const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is il\&.begin() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
flat_multiset(std::initializer_list< value_type > il, 
              const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty container using the specified allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is il\&.begin() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
flat_multiset(ordered_unique_range_t, std::initializer_list< value_type > il, 
              const Compare & comp = Compare(), 
              const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty container using the specified comparison object and allocator, and inserts elements from the ordered unique range [il\&.begin(), il\&.end())\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [il\&.begin(), il\&.end()) must be ordered according to the predicate and must be unique values\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
flat_multiset(const flat_multiset & x);
.fi

.sp
\fBEffects\fR: Copy constructs the container\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
flat_multiset(flat_multiset && x);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
flat_multiset(const flat_multiset & x, const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
flat_multiset(flat_multiset && x, const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
flat_multiset & operator=(const flat_multiset & x);
.fi

.sp
\fBEffects\fR: Makes *this a copy of x\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
flat_multiset & 
operator=(flat_multiset && x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
.fi

.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
flat_multiset & operator=(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Copy all elements from il to *this\&.
.sp
\fBComplexity\fR: Linear in il\&.size()\&.
.RE

.SS "flat_multiset public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a copy of the allocator that was passed to the object\'s constructor\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get_stored_allocator: Class template flat_multiset
.\" Class template flat_multiset: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get_stored_allocator: Class template flat_multiset
.\" Class template flat_multiset: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" begin: Class template flat_multiset
.\" Class template flat_multiset: begin

.sp

.nf
iterator begin() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" begin: Class template flat_multiset
.\" Class template flat_multiset: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const_iterator cbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rbegin: Class template flat_multiset
.\" Class template flat_multiset: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rbegin: Class template flat_multiset
.\" Class template flat_multiset: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rend: Class template flat_multiset
.\" Class template flat_multiset: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template flat_multiset
.\" Class template flat_multiset: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
bool empty() const noexcept;
.fi

.sp
\fBEffects\fR: Returns true if the container contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
size_type size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
size_type max_size() const noexcept;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
size_type capacity() const noexcept;
.fi

.sp
\fBEffects\fR: Number of elements for which memory has been allocated\&. capacity() is always greater than or equal to size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" reserve: Class template flat_multiset
.\" Class template flat_multiset: reserve

.sp

.nf
void reserve(size_type cnt);
.fi

.sp
\fBEffects\fR: If n is less than or equal to capacity(), this call has no effect\&. Otherwise, it is a request for allocation of additional memory\&. If the request is successful, then capacity() is greater than or equal to n; otherwise, capacity() is unchanged\&. In either case, size() is unchanged\&.
.sp
\fBThrows\fR: If memory allocation allocation throws or Key\'s copy constructor throws\&.
.sp
\fBNote\fR: If capacity() is less than "cnt", iterators and references to to values might be invalidated\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" shrink_to_fit: Class template flat_multiset
.\" Class template flat_multiset: shrink_to_fit

.sp

.nf
void shrink_to_fit();
.fi

\fBEffects\fR: Tries to deallocate the excess of memory created \fBThrows\fR: If memory allocation throws, or Key\'s copy constructor throws\&.
.sp
\fBComplexity\fR: Linear to size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" emplace: Class template flat_multiset
.\" Class template flat_multiset: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type Key constructed with std::forward<Args>(args)\&.\&.\&. and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic search time plus linear insertion to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> 
  iterator emplace_hint(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type Key constructed with std::forward<Args>(args)\&.\&.\&. in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
iterator insert(const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts x and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic search time plus linear insertion to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
iterator insert(value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value_type move constructed from x and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic search time plus linear insertion to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
iterator insert(const_iterator p, const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
iterator insert(const_iterator p, value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value move constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic search time (constant if x is inserted right before p) plus insertion linear to the elements with bigger keys than x\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
template<typename InputIterator> 
  void insert(InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: first, last are not iterators into *this\&.
.sp
\fBEffects\fR: inserts each element from the range [first,last) \&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
template<typename InputIterator> 
  void insert(ordered_range_t, InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: first, last are not iterators into *this and must be ordered according to the predicate\&.
.sp
\fBEffects\fR: inserts each element from the range [first,last) \&.This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: Non\-standard extension\&. If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
void insert(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: inserts each element from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" insert: Class template flat_multiset
.\" Class template flat_multiset: insert

.sp

.nf
void insert(ordered_range_t, std::initializer_list< value_type > il);
.fi

.sp
\fBRequires\fR: Range [il\&.begin(), il\&.end()) must be ordered according to the predicate\&.
.sp
\fBEffects\fR: inserts each element from the range [il\&.begin(), il\&.end())\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from il\&.begin() to il\&.end()) search time plus N*size() insertion time\&.
.sp
\fBNote\fR: Non\-standard extension\&. If an element is inserted it might invalidate elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" erase: Class template flat_multiset
.\" Class template flat_multiset: erase

.sp

.nf
iterator erase(const_iterator p);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by p\&.
.sp
\fBReturns\fR: Returns an iterator pointing to the element immediately following q prior to the element being erased\&. If no such element exists, returns end()\&.
.sp
\fBComplexity\fR: Linear to the elements with keys bigger than p
.sp
\fBNote\fR: Invalidates elements with keys not less than the erased element\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" erase: Class template flat_multiset
.\" Class template flat_multiset: erase

.sp

.nf
size_type erase(const key_type & x);
.fi

.sp
\fBEffects\fR: Erases all elements in the container with key equivalent to x\&.
.sp
\fBReturns\fR: Returns the number of erased elements\&.
.sp
\fBComplexity\fR: Logarithmic search time plus erasure time linear to the elements with bigger keys\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" erase: Class template flat_multiset
.\" Class template flat_multiset: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

.sp
\fBEffects\fR: Erases all the elements in the range [first, last)\&.
.sp
\fBReturns\fR: Returns last\&.
.sp
\fBComplexity\fR: size()*N where N is the distance from first to last\&.
.sp
\fBComplexity\fR: Logarithmic search time plus erasure time linear to the elements with bigger keys\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" swap: Class template flat_multiset
.\" Class template flat_multiset: swap

.sp

.nf
void swap(flat_multiset & x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" clear: Class template flat_multiset
.\" Class template flat_multiset: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: erase(a\&.begin(),a\&.end())\&.
.sp
\fBPostcondition\fR: size() == 0\&.
.sp
\fBComplexity\fR: linear in size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the comparison object out of which a was constructed\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns an object of value_compare constructed out of the comparison object\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" find: Class template flat_multiset
.\" Class template flat_multiset: find

.sp

.nf
iterator find(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" find: Class template flat_multiset
.\" Class template flat_multiset: find

.sp

.nf
const_iterator find(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" nth: Class template flat_multiset
.\" Class template flat_multiset: nth

.sp

.nf
iterator nth(size_type n) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" nth: Class template flat_multiset
.\" Class template flat_multiset: nth

.sp

.nf
const_iterator nth(size_type n) const noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns a const_iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" index_of: Class template flat_multiset
.\" Class template flat_multiset: index_of

.sp

.nf
size_type index_of(iterator p) noexcept;
.fi

.sp
\fBRequires\fR: size() >= n\&.
.sp
\fBEffects\fR: Returns an iterator to the nth element from the beginning of the container\&. Returns end() if n == size()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" index_of: Class template flat_multiset
.\" Class template flat_multiset: index_of

.sp

.nf
size_type index_of(const_iterator p) const noexcept;
.fi

.sp
\fBRequires\fR: begin() <= p <= end()\&.
.sp
\fBEffects\fR: Returns the index of the element pointed by p and size() if p == end()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" count: Class template flat_multiset
.\" Class template flat_multiset: count

.sp

.nf
size_type count(const key_type & x) const;
.fi

.sp
\fBReturns\fR: The number of elements with key equivalent to x\&.
.sp
\fBComplexity\fR: log(size())+count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" lower_bound: Class template flat_multiset
.\" Class template flat_multiset: lower_bound

.sp

.nf
iterator lower_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" lower_bound: Class template flat_multiset
.\" Class template flat_multiset: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" upper_bound: Class template flat_multiset
.\" Class template flat_multiset: upper_bound

.sp

.nf
iterator upper_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" end: Class template flat_multiset
.\" Class template flat_multiset: end
.\" upper_bound: Class template flat_multiset
.\" Class template flat_multiset: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & x) const;
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & x);
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE

.SS "flat_multiset friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const flat_multiset & x, const flat_multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const flat_multiset & x, const flat_multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const flat_multiset & x, const flat_multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const flat_multiset & x, const flat_multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const flat_multiset & x, const flat_multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const flat_multiset & x, const flat_multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template flat_multiset
.\" Class template flat_multiset: swap

.sp

.nf
friend void swap(flat_multiset & x, flat_multiset & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


