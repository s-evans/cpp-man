.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEM" 3 "" "" ""
.SH "NAME"
boost::intrusive::linear_slist_algorithms
.SH "SYNOPSIS"
.\" unlink_after: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: unlink_after
.\" unique: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: unique
.\" swap_trailing_nodes: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: swap_trailing_nodes
.\" reverse: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: reverse
.\" node_traits: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: node_traits
.\" node_ptr: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: node_ptr
.\" node: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: node
.\" link_after: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: link_after
.\" inited: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: inited
.\" init_header: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: init_header
.\" init: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: init
.\" get_previous_node: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: get_previous_node
.\" count: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: count
.\" const_node_ptr: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: const_node_ptr

.sp
.nf
// In header: <boost/intrusive/linear_slist_algorithms\&.hpp>

template<typename NodeTraits> 
class linear_slist_algorithms {
public:
  // types
  typedef NodeTraits::node           node;          
  typedef NodeTraits::node_ptr       node_ptr;      
  typedef NodeTraits::const_node_ptr const_node_ptr;
  typedef NodeTraits                 node_traits;   

  // public static functions
  static void init(const node_ptr &);
  static bool unique(const_node_ptr);
  static bool inited(const_node_ptr);
  static void unlink_after(const node_ptr &);
  static void unlink_after(const node_ptr &, const node_ptr &);
  static void link_after(const node_ptr &, const node_ptr &);
  static void transfer_after(const node_ptr &, const node_ptr &, 
                             const node_ptr &);
  static void init_header(const node_ptr &);
  static node_ptr get_previous_node(const node_ptr &, const node_ptr &);
  static std::size_t count(const const_node_ptr &);
  static void swap_trailing_nodes(const node_ptr &, const node_ptr &);
  static node_ptr reverse(const node_ptr &);
  static std::pair< node_ptr, node_ptr > 
  move_first_n_backwards(const node_ptr &, std::size_t);
  static std::pair< node_ptr, node_ptr > 
  move_first_n_forward(const node_ptr &, std::size_t);
};
.fi
.SH "DESCRIPTION"
.\" set_next: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: set_next
.\" get_next: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: get_next
.PP
linear_slist_algorithms
provides basic algorithms to manipulate nodes forming a linear singly linked list\&.
.PP
linear_slist_algorithms
is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated\&. NodeTraits must support the following interface:
.PP
\fBTypedefs\fR:
.PP
node: The type of the node that forms the linear list
.PP
node_ptr: A pointer to a node
.PP
const_node_ptr: A pointer to a const node
.PP
\fBStatic functions\fR:
.PP
static node_ptr get_next(const_node_ptr n);
.PP
static void set_next(node_ptr n, node_ptr next);
.SS "linear_slist_algorithms public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" init: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: init

.sp

.nf
static void init(const node_ptr & this_node);
.fi

.sp
\fBEffects\fR: Constructs an non\-used list element, putting the next pointer to null:
NodeTraits::get_next(this_node) == node_ptr()
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" node_ptr: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: node_ptr
.\" unique: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: unique

.sp

.nf
static bool unique(const_node_ptr this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Returns true is "this_node" is the only node of a circular list: or it\'s a not inserted node:
return node_ptr() == NodeTraits::get_next(this_node) || NodeTraits::get_next(this_node) == this_node
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" inited: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: inited

.sp

.nf
static bool inited(const_node_ptr this_node);
.fi

.sp
\fBEffects\fR: Returns true is "this_node" has the same state as if it was inited using "init(node_ptr)"
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlink_after: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: unlink_after

.sp

.nf
static void unlink_after(const node_ptr & prev_node);
.fi

.sp
\fBRequires\fR: prev_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Unlinks the next node of prev_node from the circular list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" range: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: range
.\" unlink_after: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: unlink_after

.sp

.nf
static void unlink_after(const node_ptr & prev_node, 
                         const node_ptr & last_node);
.fi

.sp
\fBRequires\fR: prev_node and last_node must be in a circular list or be an empty circular list\&.
.sp
\fBEffects\fR: Unlinks the range (prev_node, last_node) from the linear list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" link_after: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: link_after

.sp

.nf
static void link_after(const node_ptr & prev_node, const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: prev_node must be a node of a linear list\&.
.sp
\fBEffects\fR: Links this_node after prev_node in the linear list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
static void transfer_after(const node_ptr & p, const node_ptr & b, 
                           const node_ptr & e);
.fi

.sp
\fBRequires\fR: b and e must be nodes of the same linear list or an empty range\&. and p must be a node of a different linear list\&.
.sp
\fBEffects\fR: Removes the nodes from (b, e] range from their linear list and inserts them after p in p\'s linear list\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" init_header: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: init_header

.sp

.nf
static void init_header(const node_ptr & this_node);
.fi

.sp
\fBEffects\fR: Constructs an empty list, making this_node the only node of the circular list:
NodeTraits::get_next(this_node) == this_node\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" get_previous_node: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: get_previous_node

.sp

.nf
static node_ptr 
get_previous_node(const node_ptr & prev_init_node, const node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node and prev_init_node must be in the same linear list\&.
.sp
\fBEffects\fR: Returns the previous node of this_node in the linear list starting\&. the search from prev_init_node\&. The first node checked for equality is NodeTraits::get_next(prev_init_node)\&.
.sp
\fBComplexity\fR: Linear to the number of elements between prev_init_node and this_node\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" count: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: count

.sp

.nf
static std::size_t count(const const_node_ptr & this_node);
.fi

.sp
\fBRequires\fR: this_node must be in a linear list or be an empty linear list\&.
.sp
\fBEffects\fR: Returns the number of nodes in a linear list\&. If the linear list is empty, returns 1\&.
.sp
\fBComplexity\fR: Linear
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" swap_trailing_nodes: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: swap_trailing_nodes

.sp

.nf
static void swap_trailing_nodes(const node_ptr & this_node, 
                                const node_ptr & other_node);
.fi

.sp
\fBRequires\fR: this_node and other_node must be nodes inserted in linear lists or be empty linear lists\&.
.sp
\fBEffects\fR: Moves all the nodes previously chained after this_node after other_node and vice\-versa\&.
.sp
\fBComplexity\fR: Constant
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" reverse: Class template linear_slist_algorithms
.\" Class template linear_slist_algorithms: reverse

.sp

.nf
static node_ptr reverse(const node_ptr & p);
.fi

.sp
\fBEffects\fR: Reverses the order of elements in the list\&.
.sp
\fBReturns\fR: The new first node of the list\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: This function is linear to the contained elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
static std::pair< node_ptr, node_ptr > 
move_first_n_backwards(const node_ptr & p, std::size_t n);
.fi

.sp
\fBEffects\fR: Moves the first n nodes starting at p to the end of the list\&.
.sp
\fBReturns\fR: A pair containing the new first and last node of the list or if there has been any movement, a null pair if n leads to no movement\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements plus the number moved positions\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
static std::pair< node_ptr, node_ptr > 
move_first_n_forward(const node_ptr & p, std::size_t n);
.fi

.sp
\fBEffects\fR: Moves the first n nodes starting at p to the beginning of the list\&.
.sp
\fBReturns\fR: A pair containing the new first and last node of the list or if there has been any movement, a null pair if n leads to no movement\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the number of elements plus the number moved positions\&.
.RE


