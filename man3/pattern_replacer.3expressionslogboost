.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLAT" 3 "" "" ""
.SH "NAME"
boost::log::expressions::pattern_replacer
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/expressions/formatters/char_decorator\&.hpp>

template<typename CharT> 
class pattern_replacer {
public:
  // types
  typedef void                           result_type;  // Result type\&. 
  typedef CharT                          char_type;    // Character type\&. 
  typedef std::basic_string< char_type > string_type;  // String type\&. 

  // member classes/structs/unions

  // Lengths of source pattern and replacement\&.

  struct string_lengths {

    // public data members
    unsigned int from_len;
    unsigned int to_len;
  };

  // construct/copy/destruct
  template<typename RangeT> explicit pattern_replacer(RangeT const &);
  template<typename FromRangeT, typename ToRangeT> 
    pattern_replacer(FromRangeT const &, ToRangeT const &);
  pattern_replacer(pattern_replacer const &);

  // public member functions
  result_type operator()(string_type &, typename string_type::size_type = 0) const;

  // private static functions
  static char_type * string_begin(char_type *);
  static const char_type * string_begin(const char_type *);
  template<typename RangeT> 
    static range_const_iterator< RangeT >::type string_begin(RangeT const &);
  static char_type * string_end(char_type *);
  static const char_type * string_end(const char_type *);
  template<typename RangeT> 
    static range_const_iterator< RangeT >::type string_end(RangeT const &);
};
.fi
.SH "DESCRIPTION"
.PP
A simple character decorator implementation\&. This implementation replaces string patterns in the source string with the fixed replacements\&. Source patterns and replacements can be specified at the object construction\&.
.SS "pattern_replacer public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename RangeT> 
  explicit pattern_replacer(RangeT const & decorations);
.fi

.sp
Initializing constructor\&. Creates a pattern replacer with the specified
\fIdecorations\fR\&. The provided decorations must be a sequence of
std::pair
of strings\&. The first element of each pair is the source pattern, and the second one is the corresponding replacement\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename FromRangeT, typename ToRangeT> 
  pattern_replacer(FromRangeT const & from, ToRangeT const & to);
.fi

.sp
Initializing constructor\&. Creates a pattern replacer with decorations specified in form of two same\-sized string sequences\&. Each
i\'th decoration will be
from[i]
\->
to[i]\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
pattern_replacer(pattern_replacer const & that);
.fi

Copy constructor\&. .RE

.SS "pattern_replacer public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
result_type operator()(string_type & str, 
                       typename string_type::size_type start_pos = 0) const;
.fi

Applies string replacements starting from the specified position\&. .RE

.SS "pattern_replacer private static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static char_type * string_begin(char_type * p);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static const char_type * string_begin(const char_type * p);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename RangeT> 
  static range_const_iterator< RangeT >::type string_begin(RangeT const & r);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
static char_type * string_end(char_type * p);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
static const char_type * string_end(const char_type * p);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename RangeT> 
  static range_const_iterator< RangeT >::type string_end(RangeT const & r);
.fi

.RE


