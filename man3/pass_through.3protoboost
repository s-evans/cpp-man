.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLAT" 3 "" "" ""
.SH "NAME"
boost::proto::pass_through \- A PrimitiveTransform that transforms the child expressions of an expression node according to the corresponding children of a Grammar\&. The resulting expression is in the specified domain\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/transform/pass_through\&.hpp>

template<typename Grammar, typename Domain = proto::deduce_domain> 
struct pass_through :  proto::transform< pass_through<Grammar, Domain> > {
  // member classes/structs/unions
  template<typename Expr, typename State, typename Data> 
  struct impl :  proto::transform_impl<Expr, State, Data> {
    // types
    typedef typename proto::result_of::child_c<Grammar, N>::type       GN;           // For each N in [0,Expr arity), for exposition only
    typedef typename proto::result_of::child_c<Expr, N>::type          EN;           // For each N in [0,Expr arity), for exposition only
    typedef typename boost::result_of<GN(EN,State,Data)>::type         RN;           // For each N in [0,Expr arity), for exposition only
    typedef typename Expr::proto_tag                                   T;            // For exposition only
    typedef boost::is_same<Domain, deduce_domain>                      Deduce;       // For exposition only
    typedef typename Expr::proto_domain                                DD;           // For exposition only
    typedef typename mpl::if_<Deduce, DD, Domain>::type                D;            // For exposition only
    typedef typename D::proto_generator                                G;            // For exposition only
    typedef proto::listN<R0,\&.\&.\&.RN>                                     A;            // For exposition only
    typedef proto::expr<T, A>                                          E;            // For exposition only
    typedef proto::basic_expr<T, A>                                    BE;           // For exposition only
    typedef typename mpl::if_<proto::wants_basic_expr<G>, BE, E>::type expr_type;    // For exposition only
    typedef typename boost::result_of<D(expr_type)>::type              result_type;

    // public member functions
    result_type operator()(typename impl::expr_param, 
                           typename impl::state_param, 
                           typename impl::data_param) const;
  };
};
.fi
.SH "DESCRIPTION"
.PP
Given a Grammar such as
proto::plus<T0, T1>, an expression type that matches the grammar such as
proto::plus<E0, E1>::type, a state
S
and a data
D, the result of applying the
proto::pass_through<proto::plus<T0, T1> >
transform is:

.sp
.if n \{\
.RS 4
.\}
.nf
proto::plus<
  boost::result_of<T0(E0, S, D)>::type,
  boost::result_of<T1(E1, S, D)>::type
>::type
.fi
.if n \{\
.RE
.\}
.sp

.PP
The above demonstrates how child transforms and child expressions are applied pairwise, and how the results are reassembled into a new expression node with the same tag type as the original\&.
.PP
The
Domain
template parameter determines which domain the resulting expression should be in\&. If it is
proto::deduce_domain, which is the default, the resulting expression is in the same domain as the expression passed in\&. Otherwise, the resulting expression is in the specified domain\&. Practically, that means the specified domain\'s generator is used to post\-process the resulting expression\&.
.PP
The explicit use of
proto::pass_through<>
is not usually needed, since the expression generator metafunctions such as
proto::plus<>
have
proto::pass_through<>
as their default transform\&. So, for instance, these are equivalent:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                  proto::when< proto::plus<X, Y>, proto::pass_through< proto::plus<X, Y> > >
                .RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                  proto::when< proto::plus<X, Y>, proto::plus<X, Y> >
                .RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                  proto::when< proto::plus<X, Y> > // because of proto::when<class X, class Y=X>
                .RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                  proto::plus<X, Y>  // because plus<> is both a grammar and a transform
                .RE
.sp
.RE

.PP
For example, consider the following transform that promotes all
float
terminals in an expression to
double\&.

.sp
.if n \{\
.RS 4
.\}
.nf
// This transform finds all float terminals in an expression and promotes
// them to doubles\&.
struct Promote :
  proto::or_<
    proto::when<proto::terminal<float>, proto::terminal<double>::type(proto::_value) >,
    // terminal<>\'s default transform is a no\-op:
    proto::terminal<proto::_>,
    // nary_expr<> has a pass_through<> transform:
    proto::nary_expr<proto::_, proto::vararg<Promote> >
  >
{};
.fi
.if n \{\
.RE
.\}
.sp


