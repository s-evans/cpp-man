.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT _" 3 "" "" ""
.SH "NAME"
boost::proto::_ \- A wildcard grammar element that matches any expression, and a transform that returns the current expression unchanged\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/matches\&.hpp>


struct _ :  proto::transform<_> {
  // types
  typedef _ proto_grammar;

  // member classes/structs/unions
  template<typename Expr, typename State, typename Data> 
  struct impl :  proto::transform_impl<Expr, State, Data> {
    // types
    typedef Expr result_type;

    // public member functions
    Expr operator()(typename impl::expr_param, typename impl::state_param, 
                    typename impl::data_param) const;
  };
};
.fi
.SH "DESCRIPTION"
.PP
The wildcard type,
proto::_, is a grammar element such that
proto::matches<E, proto::_>::value
is
true
for any expression type
E\&.
.PP
The wildcard can also be used as a stand\-in for a template argument when matching terminals\&. For instance, the following is a grammar that will match any
std::complex<>
terminal:
.sp
.if n \{\
.RS 4
.\}
.nf
BOOST_MPL_ASSERT((
  proto::matches<
    proto::terminal<std::complex<double> >::type,
    \fBproto::terminal\fR\fB<\fR\fBstd\fR\fB::\fR\fBcomplex\fR\fB<\fR\fB \fR\fBproto\fR\fB::\fR\fB_\fR\fB \fR\fB>\fR\fB \fR\fB>\fR
  >
));
.fi
.if n \{\
.RE
.\}
.sp

.PP
When used as a transform,
proto::_
returns the current expression unchanged\&. For instance, in the following,
proto::_
is used with the
proto::fold<>
transform to fold the children of a node:
.sp
.if n \{\
.RS 4
.\}
.nf
struct CountChildren :
  proto::or_<
    // Terminals have no children
    proto::when<proto::terminal<proto::_>, mpl::int_<0>()>,
    // Use proto::fold<> to count the children of non\-terminals
    proto::otherwise<
      proto::fold<
        proto::_, // <\-\- fold the current expression
        mpl::int_<0>(),
        mpl::plus<proto::_state, mpl::int_<1> >()
      >
    >
  >
{};
.fi
.if n \{\
.RE
.\}
.sp


