.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE B" 3 "" "" ""
.SH "NAME"
boost::date_time::base_time \- Representation of a precise moment in time, including the date\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/time\&.hpp>

template<typename T, typename time_system> 
class base_time :
  private boost::less_than_comparable< T, boost::equality_comparable< T > >
{
public:
  // types
  typedef void                            _is_boost_date_time_time_point;
  typedef T                               time_type;                     
  typedef time_system::time_rep_type      time_rep_type;                 
  typedef time_system::date_type          date_type;                     
  typedef time_system::date_duration_type date_duration_type;            
  typedef time_system::time_duration_type time_duration_type;            

  // construct/copy/destruct
  base_time(const date_type &, const time_duration_type &, 
            dst_flags = not_dst);
  base_time(special_values);
  base_time(const time_rep_type &);

  // public member functions
  date_type date() const;
  time_duration_type time_of_day() const;
  std::string zone_name(bool = false) const;
  std::string zone_abbrev(bool = false) const;
  std::string zone_as_posix_string() const;
  bool is_not_a_date_time() const;
  bool is_infinity() const;
  bool is_pos_infinity() const;
  bool is_neg_infinity() const;
  bool is_special() const;
  bool operator==(const time_type &) const;
  bool operator<(const time_type &) const;
  time_duration_type operator\-(const time_type &) const;
  time_type operator+(const date_duration_type &) const;
  time_type operator+=(const date_duration_type &);
  time_type operator\-(const date_duration_type &) const;
  time_type operator\-=(const date_duration_type &);
  time_type operator+(const time_duration_type &) const;
  time_type operator+=(const time_duration_type &);
  time_type operator\-(const time_duration_type &) const;
  time_type operator\-=(const time_duration_type &);
};
.fi
.SH "DESCRIPTION"
.PP
This class is a skeleton for the interface of a temporal type with a resolution that is higher than a day\&. It is intended that this class be the base class and that the actual time class be derived using the BN pattern\&. In this way, the derived class can make decisions such as \'should there be a default constructor\' and what should it set its value to, should there be optional constructors say allowing only an time_durations that generate a time from a clock,etc\&. So, in fact multiple time types can be created for a time_system with different construction policies, and all of them can perform basic operations by only writing a copy constructor\&. Finally, compiler errors are also shorter\&.
.PP
The real behavior of the time class is provided by the time_system template parameter\&. This class must provide all the logic for addition, subtraction, as well as define all the interface types\&.
.SS "base_time public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
base_time(const date_type & day, const time_duration_type & td, 
          dst_flags dst = not_dst);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
base_time(special_values sv);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
base_time(const time_rep_type & rhs);
.fi

.RE

.SS "base_time public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
date_type date() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
time_duration_type time_of_day() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
std::string zone_name(bool = false) const;
.fi

.sp
Optional bool parameter will return time zone as an offset (ie "+07:00")\&. Empty string is returned for classes that do not use a time_zone
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
std::string zone_abbrev(bool = false) const;
.fi

.sp
Optional bool parameter will return time zone as an offset (ie "+07:00")\&. Empty string is returned for classes that do not use a time_zone
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
std::string zone_as_posix_string() const;
.fi

An empty string is returned for classes that do not use a time_zone\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
bool is_not_a_date_time() const;
.fi

check to see if date is not a value .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool is_infinity() const;
.fi

check to see if date is one of the infinity values .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
bool is_pos_infinity() const;
.fi

check to see if date is greater than all possible dates .RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
bool is_neg_infinity() const;
.fi

check to see if date is greater than all possible dates .RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool is_special() const;
.fi

check to see if time is a special value .RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
bool operator==(const time_type & rhs) const;
.fi

Equality operator <ndash></ndash> others generated by boost::equality_comparable\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool operator<(const time_type & rhs) const;
.fi

Equality operator <ndash></ndash> others generated by boost::less_than_comparable\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
time_duration_type operator\-(const time_type & rhs) const;
.fi

difference between two times .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
time_type operator+(const date_duration_type & dd) const;
.fi

add date durations .RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
time_type operator+=(const date_duration_type & dd);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
time_type operator\-(const date_duration_type & dd) const;
.fi

subtract date durations .RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
time_type operator\-=(const date_duration_type & dd);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
time_type operator+(const time_duration_type & td) const;
.fi

add time durations .RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
time_type operator+=(const time_duration_type & td);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
time_type operator\-(const time_duration_type & rhs) const;
.fi

subtract time durations .RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
time_type operator\-=(const time_duration_type & td);
.fi

.RE


