.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "FUNCTION CALL" 3 "" "" ""
.SH "NAME"
boost::type_erasure::call
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/type_erasure/call\&.hpp>


template<typename Concept, typename Op, class\&.\&.\&. U> 
  \fIunspecified\fR call(const binding< Concept > & binding, const Op &, 
                   U &&\&.\&.\&. args);
template<typename Op, class\&.\&.\&. U> \fIunspecified\fR call(const Op &, U &&\&.\&.\&. args);
.fi
.SH "DESCRIPTION"
.PP
Dispatches a type erased function\&.
.PP
Op
must be a primitive concept which is present in
Concept\&. Its signature determines how the arguments of
call
are handled\&. If the argument is a
placeholder,
call
expects an any using that
placeholder\&. This any is unwrapped by
call\&. The type that it stores must be the same type specified by
binding\&. Any arguments that are not placeholders in the signature of
Op
are passed through unchanged\&.
.PP
If
binding
is not specified, it will be deduced from the arguments\&. Naturally this requires at least one argument to be an any\&. In this case, all any arguments must have the same
binding\&.
.PP
Example:
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
typedef mpl::vector<
  copy_constructible<_b>,
  addable<_a, int, _b> > concept;
any<concept, _a> a = \&.\&.\&.;
any<concept, _b> b(call(addable<_a, int, _b>(), a, 10));

.fi
.if n \{\
.RE
.\}

.PP
The signature of
addable
is
_b(const _a&, const int&)
.PP
Returns:
.RS 4
The result of the operation\&. If the result type of the signature of
Op
is a placeholder, the result will be converted to the appropriate any type\&.
.RE
.PP
Throws:
.RS 4
bad_function_call
if
relaxed
is in
Concept
and there is a type mismatch\&.
.RE

