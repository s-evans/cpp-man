.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS GRAPH_COMM" 3 "" "" ""
.SH "NAME"
boost::mpi::graph_communicator \- An MPI communicator with a graph topology\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/mpi/graph_communicator\&.hpp>


class graph_communicator : public boost::mpi::communicator {
public:
  // construct/copy/destruct
  graph_communicator(const MPI_Comm &, comm_create_kind);
  template<typename Graph> 
    explicit graph_communicator(const communicator &, const Graph &, 
                                bool = false);
  template<typename Graph, typename RankMap> 
    explicit graph_communicator(const communicator &, const Graph &, RankMap, 
                                bool = false);
};
.fi
.SH "DESCRIPTION"
.PP
A
graph_communicator
is a communicator whose topology is expressed as a graph\&. Graph communicators have the same functionality as (intra)communicators, but also allow one to query the relationships among processes\&. Those relationships are expressed via a graph, using the interface defined by the Boost Graph Library\&. The
graph_communicator
class meets the requirements of the BGL Graph, Incidence Graph, Adjacency Graph, Vertex List Graph, and Edge List Graph concepts\&.
.SS "graph_communicator public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
graph_communicator(const MPI_Comm & comm, comm_create_kind kind);
.fi

.sp
Build a new Boost\&.MPI graph communicator based on the MPI communicator
comm
with graph topology\&.
.sp
comm
may be any valid MPI communicator\&. If
comm
is MPI_COMM_NULL, an empty communicator (that cannot be used for communication) is created and the
kind
parameter is ignored\&. Otherwise, the
kind
parameter determines how the Boost\&.MPI communicator will be related to
comm:
.sp

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If
kind
is
comm_duplicate, duplicate
comm
to create a new communicator\&. This new communicator will be freed when the Boost\&.MPI communicator (and all copies of it) is destroyed\&. This option is only permitted if the underlying MPI implementation supports MPI 2\&.0; duplication of intercommunicators is not available in MPI 1\&.x\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If
kind
is
comm_take_ownership, take ownership of
comm\&. It will be freed automatically when all of the Boost\&.MPI communicators go out of scope\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If
kind
is
comm_attach, this Boost\&.MPI communicator will reference the existing MPI communicator
comm
but will not free
comm
when the Boost\&.MPI communicator goes out of scope\&. This option should only be used when the communicator is managed by the user\&.
.RE
.RS 4

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Graph> 
  explicit graph_communicator(const communicator & comm, const Graph & graph, 
                              bool reorder = false);
.fi

.sp
Create a new communicator whose topology is described by the given graph\&. The indices of the vertices in the graph will be assumed to be the ranks of the processes within the communicator\&. There may be fewer vertices in the graph than there are processes in the communicator; in this case, the resulting communicator will be a NULL communicator\&.
.sp

.PP
Parameters:
.RS 4
.PP
comm
.RS 4
The communicator that the new, graph communicator will be based on\&.
.RE
.PP
graph
.RS 4
Any type that meets the requirements of the Incidence Graph and Vertex List Graph concepts from the Boost Graph Library\&. This structure of this graph will become the topology of the communicator that is returned\&.
.RE
.PP
reorder
.RS 4
Whether MPI is permitted to re\-order the process ranks within the returned communicator, to better optimize communication\&. If false, the ranks of each process in the returned process will match precisely the rank of that process within the original communicator\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename Graph, typename RankMap> 
  explicit graph_communicator(const communicator & comm, const Graph & graph, 
                              RankMap rank, bool reorder = false);
.fi

.sp
Create a new communicator whose topology is described by the given graph\&. The rank map (rank) gives the mapping from vertices in the graph to ranks within the communicator\&. There may be fewer vertices in the graph than there are processes in the communicator; in this case, the resulting communicator will be a NULL communicator\&.
.sp

.PP
Parameters:
.RS 4
.PP
comm
.RS 4
The communicator that the new, graph communicator will be based on\&. The ranks in
rank
refer to the processes in this communicator\&.
.RE
.PP
graph
.RS 4
Any type that meets the requirements of the Incidence Graph and Vertex List Graph concepts from the Boost Graph Library\&. This structure of this graph will become the topology of the communicator that is returned\&.
.RE
.PP
rank
.RS 4
This map translates vertices in the
graph
into ranks within the current communicator\&. It must be a Readable Property Map (see the Boost Property Map library) whose key type is the vertex type of the
graph
and whose value type is
int\&.
.RE
.PP
reorder
.RS 4
Whether MPI is permitted to re\-order the process ranks within the returned communicator, to better optimize communication\&. If false, the ranks of each process in the returned process will match precisely the rank of that process within the original communicator\&.
.RE
.RE
.RE


