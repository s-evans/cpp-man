.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS ATTRIBUTE_VA" 3 "" "" ""
.SH "NAME"
boost::log::attribute_value \- An attribute value class\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/attributes/attribute_value\&.hpp>


class attribute_value {
public:
  // member classes/structs/unions

  // A base class for an attribute value implementation\&.

  struct impl : public attribute::impl {

    // public member functions
    virtual bool dispatch(type_dispatcher &) = 0;
    virtual intrusive_ptr< impl > detach_from_thread();
    virtual attribute_value get_value();
    virtual typeindex::type_index get_type() const;
  };
  // construct/copy/destruct
  attribute_value() = default;
  attribute_value(attribute_value const &) noexcept;
  attribute_value(attribute_value &&) noexcept;
  explicit attribute_value(intrusive_ptr< impl >) noexcept;
  attribute_value & operator=(attribute_value const &) noexcept;
  attribute_value & operator=(attribute_value &&) noexcept;

  // public member functions
  explicit operator bool() const noexcept;
  bool operator!() const noexcept;
  typeindex::type_index get_type() const;
  void detach_from_thread();
  bool dispatch(type_dispatcher &) const;
  template<typename T, typename TagT = void> 
    result_of::extract< T, TagT >::type extract() const;
  template<typename T, typename TagT = void> 
    result_of::extract_or_throw< T, TagT >::type extract_or_throw() const;
  template<typename T, typename TagT = void> 
    result_of::extract_or_default< T, T, TagT >::type 
    extract_or_default(T const &) const;
  template<typename T, typename TagT = void, typename DefaultT> 
    result_of::extract_or_default< T, DefaultT, TagT >::type 
    extract_or_default(DefaultT const &) const;
  template<typename T, typename VisitorT> 
    visitation_result visit(VisitorT) const;
  void swap(attribute_value &) noexcept;
};
.fi
.SH "DESCRIPTION"
.PP
An attribute value is an object that contains a piece of data that represents an attribute state at the point of the value acquisition\&. All major operations with log records, such as filtering and formatting, involve attribute values contained in a single view\&. Most likely an attribute value is implemented as a simple holder of some typed value\&. This holder implements the
attribute_value::implementation
interface and acts as a pimpl for the
attribute_value
object\&. The
attribute_value
class provides type dispatching support in order to allow to extract the value from the holder\&.
.PP
Normally, attributes and their values shall be designed in order to exclude as much interference as reasonable\&. Such approach allows to have more than one attribute value simultaneously, which improves scalability and allows to implement generating attributes\&.
.PP
However, there are cases when this approach does not help to achieve the required level of independency of attribute values and attribute itself from each other at a reasonable performance tradeoff\&. For example, an attribute or its values may use thread\-specific data, which is global and shared between all the instances of the attribute/value\&. Passing such an attribute value to another thread would be a disaster\&. To solve this the library defines an additional method for attribute values, namely
detach_from_thread\&. The
attribute_value
class forwards the call to its pimpl, which is supposed to ensure that it no longer refers to any thread\-specific data after the call\&. The pimpl can create a new holder as a result of this method and return it to the
attribute_value
wrapper, which will keep the returned reference for any further calls\&. This method is called for all attribute values that are passed to another thread\&.
.SS "attribute_value public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
attribute_value() = default;
.fi

.sp
Default constructor\&. Creates an empty (absent) attribute value\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
attribute_value(attribute_value const & that) noexcept;
.fi

.sp
Copy constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
attribute_value(attribute_value && that) noexcept;
.fi

.sp
Move constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
explicit attribute_value(intrusive_ptr< impl > p) noexcept;
.fi

.sp
Initializing constructor\&. Creates an attribute value that refers to the specified holder\&.
.sp

.PP
Parameters:
.RS 4
.PP
p
.RS 4
A pointer to the attribute value holder\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
attribute_value & operator=(attribute_value const & that) noexcept;
.fi

.sp
Copy assignment
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
attribute_value & operator=(attribute_value && that) noexcept;
.fi

.sp
Move assignment
.RE

.SS "attribute_value public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit operator bool() const noexcept;
.fi

.sp
The operator checks if the attribute value is empty
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool operator!() const noexcept;
.fi

.sp
The operator checks if the attribute value is empty
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typeindex::type_index get_type() const;
.fi

.sp
The method returns the type information of the stored value of the attribute\&. The returned type info wrapper may be empty if the attribute value is empty or the information cannot be provided\&. If the returned value is not empty, the type can be used for value extraction\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void detach_from_thread();
.fi

.sp
The method is called when the attribute value is passed to another thread (e\&.g\&. in case of asynchronous logging)\&. The value should ensure it properly owns all thread\-specific data\&.
.sp

.PP
Postconditions:
.RS 4
The attribute value no longer refers to any thread\-specific resources\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool dispatch(type_dispatcher & dispatcher) const;
.fi

.sp
The method dispatches the value to the given object\&. This method is a low level interface for attribute value visitation and extraction\&. For typical usage these interfaces may be more convenient\&.
.sp

.PP
Parameters:
.RS 4
.PP
dispatcher
.RS 4
The object that attempts to dispatch the stored value\&.
.RE
.RE
.PP
Returns:
.RS 4
true
if the value is not empty and the
\fIdispatcher\fR
was capable to consume the real attribute value type and
false
otherwise\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename T, typename TagT = void> 
  result_of::extract< T, TagT >::type extract() const;
.fi

.sp
The method attempts to extract the stored value, assuming the value has the specified type\&. One can specify either a single type or an MPL type sequence, in which case the stored value is checked against every type in the sequence\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Include
value_extraction\&.hpp
prior to using this method\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
The extracted value, if the attribute value is not empty and the value is the same as specified\&. Otherwise returns an empty value\&. See description of the
result_of::extract
metafunction for information on the nature of the result value\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename T, typename TagT = void> 
  result_of::extract_or_throw< T, TagT >::type extract_or_throw() const;
.fi

.sp
The method attempts to extract the stored value, assuming the value has the specified type\&. One can specify either a single type or an MPL type sequence, in which case the stored value is checked against every type in the sequence\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Include
value_extraction\&.hpp
prior to using this method\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
The extracted value, if the attribute value is not empty and the value is the same as specified\&. Otherwise an exception is thrown\&. See description of the
result_of::extract_or_throw
metafunction for information on the nature of the result value\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename T, typename TagT = void> 
  result_of::extract_or_default< T, T, TagT >::type 
  extract_or_default(T const & def_value) const;
.fi

.sp
The method attempts to extract the stored value, assuming the value has the specified type\&. One can specify either a single type or an MPL type sequence, in which case the stored value is checked against every type in the sequence\&. If extraction fails, the default value is returned\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Include
value_extraction\&.hpp
prior to using this method\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
def_value
.RS 4
Default value\&.
.RE
.RE
.PP
Returns:
.RS 4
The extracted value, if the attribute value is not empty and the value is the same as specified\&. Otherwise returns the default value\&. See description of the
result_of::extract_or_default
metafunction for information on the nature of the result value\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename T, typename TagT = void, typename DefaultT> 
  result_of::extract_or_default< T, DefaultT, TagT >::type 
  extract_or_default(DefaultT const & def_value) const;
.fi

.sp
The method attempts to extract the stored value, assuming the value has the specified type\&. One can specify either a single type or an MPL type sequence, in which case the stored value is checked against every type in the sequence\&. If extraction fails, the default value is returned\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Include
value_extraction\&.hpp
prior to using this method\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
def_value
.RS 4
Default value\&.
.RE
.RE
.PP
Returns:
.RS 4
The extracted value, if the attribute value is not empty and the value is the same as specified\&. Otherwise returns the default value\&. See description of the
result_of::extract_or_default
metafunction for information on the nature of the result value\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename T, typename VisitorT> 
  visitation_result visit(VisitorT visitor) const;
.fi

.sp
The method attempts to extract the stored value, assuming the value has the specified type, and pass it to the
\fIvisitor\fR
function object\&. One can specify either a single type or an MPL type sequence, in which case the stored value is checked against every type in the sequence\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Include
value_visitation\&.hpp
prior to using this method\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
visitor
.RS 4
A function object that will be invoked on the extracted attribute value\&. The visitor should be capable to be called with a single argument of any type of the specified types in
T\&.
.RE
.RE
.PP
Returns:
.RS 4
The result of visitation\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
void swap(attribute_value & that) noexcept;
.fi

.sp
The method swaps two attribute values
.RE


