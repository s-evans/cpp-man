.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE M" 3 "" "" ""
.SH "NAME"
boost::proto::matches \- A Boolean metafunction that evaluates whether a given expression type matches a grammar\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/matches\&.hpp>

template<typename Expr, typename Grammar> 
struct matches :  mpl::bool_<\fItrue\-or\-false\fR> {
};
.fi
.SH "DESCRIPTION"
.PP

proto::matches<Expr, Grammar>
inherits from
mpl::true_
if
Expr::proto_grammar
matches
Grammar::proto_grammar, and from
mpl::false_
otherwise\&.
.PP
Non\-terminal expressions are matched against a grammar according to the following rules:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The wildcard pattern,
proto::_, matches any expression\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An expression
proto::basic_expr<AT, proto::listN <A0,\&.\&.\&.An> >
matches a grammar
proto::basic_expr<BT, proto::listN <B0,\&.\&.\&.Bn> >
if
BT
is
proto::_
or
AT, and if
Ax
matches
Bx
for each
x
in
[0,n]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An expression
proto::basic_expr<AT, proto::listN <A0,\&.\&.\&.An,U0,\&.\&.\&.Um> >
matches a grammar
proto::basic_expr<BT, proto::listM <B0,\&.\&.\&.Bn,proto::vararg<V> > >
if
BT
is
proto::_
or
AT, and if
Ax
matches
Bx
for each
x
in
[0,n]
and if
Ux
matches
V
for each
x
in
[0,m]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An expression
E
matches
proto::or_<B0,\&.\&.\&.Bn>
if
E
matches some
Bx
for
x
in
[0,n]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An expression
E
matches
proto::and_<B0,\&.\&.\&.Bn>
if
E
matches all
Bx
for
x
in
[0,n]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An expression
E
matches
proto::if_<T,U,V>
if:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                        boost::result_of<proto::when<proto::_,T>(E)>::type::value
                      
                      is true and
                      E matches
                      U, \fIor\fR.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

                        boost::result_of<proto::when<proto::_,T>(E)>::type::value
                      
                      is false and E matches
                      V\&.
                    .RE
.RS 4
Note:
U
defaults to
proto::_
and
V
defaults to
proto::not_<proto::_>\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An expression
E
matches
proto::not_<T>
if
E
does
\fInot\fR
match
T\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An expression
E
matches
proto::switch_<C, T>
if
E
matches
C::case_<boost::result_of<proto::when<proto::_,T>(E)>::type>\&. Note:
T
defaults to
proto::tag_of<proto::_>()
.RE
.sp
.RE

.PP
A terminal expression can trivially match the grammar
proto::_\&. In addition, a terminal expression
proto::basic_expr<AT, proto::term<A> >
matches a grammar
proto::basic_expr<BT, proto::term<B> >
if
BT
is
proto::_
or
AT
and one of the following is true:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

B
is the wildcard pattern,
proto::_
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A
is
B
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A
is
B &
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A
is
B const &
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

B
is
proto::exact<A>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

B
is
proto::convertible_to<X>
and
boost::is_convertible<A,X>::value
is
true\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A
is
X[M]
or
X(&)[M]
and
B
is
X[proto::N]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A
is
X(&)[M]
and
B
is
X(&)[proto::N]\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

A
is
X[M]
or
X(&)[M]
and
B
is
X*\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

B
\fIlambda\-matches\fR
A
(see below)\&.
.RE
.sp
.RE

.PP
A type
B
\fIlambda\-matches\fR
A
if one of the following is true:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

B
is
A
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

B
is the wildcard pattern,
proto::_
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

B
is
T<B0,\&.\&.\&.Bn>
and
A
is
T<A0,\&.\&.\&.An>
and for each
x
in
[0,n],
Ax
and
Bx
are types such that
Ax
\fIlambda\-matches\fR
Bx
.RE
.sp
.RE


