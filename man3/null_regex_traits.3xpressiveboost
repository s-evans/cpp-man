.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPL" 3 "" "" ""
.SH "NAME"
boost::xpressive::null_regex_traits \- stub regex_traits for non\-char data
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/xpressive/xpressive_fwd\&.hpp>

template<typename Elem> 
struct null_regex_traits {
  // construct/copy/destruct
  null_regex_traits(locale_type = locale_type());

  // public member functions
  bool operator==(null_regex_traits< char_type > const &) const;
  bool operator!=(null_regex_traits< char_type > const &) const;
  char_type widen(char) const;

  // public static functions
  static unsigned char hash(char_type);
  static char_type translate(char_type);
  static char_type translate_nocase(char_type);
  static bool in_range(char_type, char_type, char_type);
  static bool in_range_nocase(char_type, char_type, char_type);
  template<typename FwdIter> static string_type transform(FwdIter, FwdIter);
  template<typename FwdIter> 
    static string_type transform_primary(FwdIter, FwdIter);
  template<typename FwdIter> 
    static string_type lookup_collatename(FwdIter, FwdIter);
  template<typename FwdIter> 
    static char_class_type lookup_classname(FwdIter, FwdIter, bool);
  static bool isctype(char_type, char_class_type);
  static int value(char_type, int);
  static locale_type imbue(locale_type);
  static locale_type getloc();
};
.fi
.SH "DESCRIPTION"
.SS "null_regex_traits public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
null_regex_traits(locale_type = locale_type());
.fi

.sp
Initialize a
null_regex_traits
object\&.
.RE

.SS "null_regex_traits public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool operator==(null_regex_traits< char_type > const & that) const;
.fi

.sp
Checks two
null_regex_traits
objects for equality
.sp

.PP
Returns:
.RS 4
true\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool operator!=(null_regex_traits< char_type > const & that) const;
.fi

.sp
Checks two
null_regex_traits
objects for inequality
.sp

.PP
Returns:
.RS 4
false\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
char_type widen(char ch) const;
.fi

.sp
Convert a char to a Elem
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
Elem(ch)\&.
.RE
.RE

.SS "null_regex_traits public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static unsigned char hash(char_type ch);
.fi

.sp
Returns a hash value for a Elem in the range [0, UCHAR_MAX]
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
a value between 0 and UCHAR_MAX, inclusive\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
static char_type translate(char_type ch);
.fi

.sp
No\-op
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
ch
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
static char_type translate_nocase(char_type ch);
.fi

.sp
No\-op
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.RE
.PP
Returns:
.RS 4
ch
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
static bool in_range(char_type first, char_type last, char_type ch);
.fi

.sp
Checks to see if a character is within a character range\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.PP
first
.RS 4
The bottom of the range, inclusive\&.
.RE
.PP
last
.RS 4
The top of the range, inclusive\&.
.RE
.RE
.PP
Returns:
.RS 4
first <= ch && ch <= last\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
static bool in_range_nocase(char_type first, char_type last, char_type ch);
.fi

.sp
Checks to see if a character is within a character range\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Since the
null_regex_traits
does not do case\-folding, this function is equivalent to in_range()\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
The source character\&.
.RE
.PP
first
.RS 4
The bottom of the range, inclusive\&.
.RE
.PP
last
.RS 4
The top of the range, inclusive\&.
.RE
.RE
.PP
Returns:
.RS 4
first <= ch && ch <= last\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static string_type transform(FwdIter begin, FwdIter end);
.fi

.sp
Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) then v\&.transform(G1, G2) < v\&.transform(H1, H2)\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not currently used
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static string_type transform_primary(FwdIter begin, FwdIter end);
.fi

.sp
Returns a sort key for the character sequence designated by the iterator range [F1, F2) such that if the character sequence [G1, G2) sorts before the character sequence [H1, H2) when character case is not considered then v\&.transform_primary(G1, G2) < v\&.transform_primary(H1, H2)\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not currently used
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static string_type lookup_collatename(FwdIter begin, FwdIter end);
.fi

.sp
Returns a sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range [F1, F2)\&. Returns an empty string if the character sequence is not a valid collating element\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not currently used
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename FwdIter> 
  static char_class_type 
  lookup_classname(FwdIter begin, FwdIter end, bool icase);
.fi

.sp
The
null_regex_traits
does not have character classifications, so lookup_classname() is unused\&.
.sp

.PP
Parameters:
.RS 4
.PP
begin
.RS 4
not used
.RE
.PP
end
.RS 4
not used
.RE
.PP
icase
.RS 4
not used
.RE
.RE
.PP
Returns:
.RS 4
static_cast<char_class_type>(0)
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
static bool isctype(char_type ch, char_class_type mask);
.fi

.sp
The
null_regex_traits
does not have character classifications, so isctype() is unused\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
not used
.RE
.PP
mask
.RS 4
not used
.RE
.RE
.PP
Returns:
.RS 4
false
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
static int value(char_type ch, int radix);
.fi

.sp
The
null_regex_traits
recognizes no elements as digits, so value() is unused\&.
.sp

.PP
Parameters:
.RS 4
.PP
ch
.RS 4
not used
.RE
.PP
radix
.RS 4
not used
.RE
.RE
.PP
Returns:
.RS 4
\-1
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
static locale_type imbue(locale_type loc);
.fi

.sp
Not used
.sp

.PP
Parameters:
.RS 4
.PP
loc
.RS 4
not used
.RE
.RE
.PP
Returns:
.RS 4
loc
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
static locale_type getloc();
.fi

.sp
Returns locale_type()\&.
.sp

.PP
Returns:
.RS 4
locale_type()
.RE
.RE


