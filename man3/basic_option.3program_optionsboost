.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::program_options::basic_option
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/program_options/option\&.hpp>

template<typename charT> 
class basic_option {
public:
  // construct/copy/destruct
  basic_option();
  basic_option(const std::string &, const std::vector< std::string > &);

  // public data members
  std::string string_key;
  int position_key;
  std::vector< std::basic_string< charT > > value;
  std::vector< std::basic_string< charT > > original_tokens;
  bool unregistered;
  bool case_insensitive;
};
.fi
.SH "DESCRIPTION"
.PP
Option found in input source\&. Contains a key and a value\&. The key, in turn, can be a string (name of an option), or an integer (position in input source) \-\- in case no name is specified\&. The latter is only possible for command line\&. The template parameter specifies the type of char used for storing the option\'s value\&.
.SS "basic_option public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
basic_option();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
basic_option(const std::string & xstring_key, 
             const std::vector< std::string > & xvalue);
.fi

.RE

.SS "basic_option public public data members"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
std::string string_key;
.fi

.sp
String key of this option\&. Intentionally independent of the template parameter\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
int position_key;
.fi

.sp
Position key of this option\&. All options without an explicit name are sequentially numbered starting from 0\&. If an option has explicit name, \'position_key\' is equal to \-1\&. It is possible that both position_key and string_key is specified, in case name is implicitly added\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
std::vector< std::basic_string< charT > > value;
.fi

.sp
Option\'s value
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
std::vector< std::basic_string< charT > > original_tokens;
.fi

.sp
The original unchanged tokens this option was created from\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool unregistered;
.fi

.sp
True if option was not recognized\&. In that case, \'string_key\' and \'value\' are results of purely syntactic parsing of source\&. The original tokens can be recovered from the "original_tokens" member\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
bool case_insensitive;
.fi

.sp
True if string_key has to be handled case insensitive\&.
.RE


