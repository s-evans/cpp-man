.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE " 3 "" "" ""
.SH "NAME"
boost::proto::noinvoke \- A type annotation in an ObjectTransform which instructs Proto not to look for a nested ::type within T after type substitution\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/transform/make\&.hpp>

template<typename T> 
struct noinvoke {
};
.fi
.SH "DESCRIPTION"
.PP

ObjectTransforms are evaluated by
proto::make<>, which finds all nested transforms and replaces them with the result of their applications\&. If any substitutions are performed, the result is first assumed to be a metafunction to be applied; that is, Proto checks to see if the result has a nested
::type
typedef\&. If it does, that becomes the result\&. The purpose of
proto::noinvoke<>
is to prevent Proto from looking for a nested
::type
typedef in these situations\&.
.PP
Example:

.sp
.if n \{\
.RS 4
.\}
.nf
struct Test
  : proto::when<
        _
      , proto::noinvoke<
            // This remove_pointer invocation is bloked by noinvoke
            boost::remove_pointer<
                // This add_pointer invocation is *not* blocked by noinvoke
                boost::add_pointer<_>
            >
        >()
    >
{};

void test_noinvoke()
{
    typedef proto::terminal<int>::type Int;
    
    BOOST_MPL_ASSERT((
        boost::is_same<
            boost::result_of<Test(Int)>::type
          , boost::remove_pointer<Int *>
        >
    ));
    
    Int i = {42};
    boost::remove_pointer<Int *> t = Test()(i);
}
.fi
.if n \{\
.RE
.\}
.sp


