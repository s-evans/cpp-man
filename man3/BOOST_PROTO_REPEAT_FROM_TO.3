.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_" 3 "" "" ""
.SH "NAME"
BOOST_PROTO_REPEAT_FROM_TO \- Repeatedly invoke the specified macro\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/repeat\&.hpp>

BOOST_PROTO_REPEAT_FROM_TO(FROM, TO, MACRO)
.fi
.SH "DESCRIPTION"
.PP

BOOST_PROTO_REPEAT_FROM_TO()
is used to generate the kind of repetitive code that is typical of EDSLs built with Proto\&.
BOOST_PROTO_REPEAT_FROM_TO(\fIFROM\fR, \fITO\fR, \fIMACRO\fR)
is equivalent to:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
\fIMACRO\fR(\fIFROM\fR, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)
\fIMACRO\fR(\fIFROM\fR\fI+\fR\fI1\fR, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)
\&.\&.\&.
\fIMACRO\fR(\fITO\fR\fI\-\fR\fI1\fR, BOOST_PROTO_typename_A, BOOST_PROTO_A_const_ref, BOOST_PROTO_A_const_ref_a, BOOST_PROTO_ref_a)
.fi
.if n \{\
.RE
.\}
.sp

.PP

\fBExample:\fR
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
// Generate BOOST_PROTO_MAX_ARITY\-1 overloads of the
// following construct() function template\&.
#define M0(N, typename_A, A_const_ref, A_const_ref_a, ref_a)      \e
template<typename T, typename_A(N)>                               \e
typename proto::result_of::make_expr<                             \e
    proto::tag::function                                          \e
  , construct_helper<T>                                           \e
  , A_const_ref(N)                                                \e
>::type const                                                     \e
construct(A_const_ref_a(N))                                       \e
{                                                                 \e
    return proto::make_expr<                                      \e
        proto::tag::function                                      \e
    >(                                                            \e
        construct_helper<T>()                                     \e
      , ref_a(N)                                                  \e
    );                                                            \e
}
BOOST_PROTO_REPEAT_FROM_TO(1, BOOST_PROTO_MAX_ARITY, M0)
#undef M0
.fi
.if n \{\
.RE
.\}
.sp

.PP
The above invocation of
BOOST_PROTO_REPEAT_FROM_TO()
will generate the following code:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
template<typename T, typename A0>
typename proto::result_of::make_expr<
    proto::tag::function
  , construct_helper<T>
  , A0 const &
>::type const
construct(A0 const & a0)
{
    return proto::make_expr<
        proto::tag::function
    >(
        construct_helper<T>()
      , boost::ref(a0)
    );
}

template<typename T, typename A0, typename A1>
typename proto::result_of::make_expr<
    proto::tag::function
  , construct_helper<T>
  , A0 const &
  , A1 const &
>::type const
construct(A0 const & a0, A1 const & a1)
{
    return proto::make_expr<
        proto::tag::function
    >(
        construct_helper<T>()
      , boost::ref(a0)
      , boost::ref(a1)
    );
}

// \&.\&.\&. and so on, up to BOOST_PROTO_MAX_ARITY\-1 arguments \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp


