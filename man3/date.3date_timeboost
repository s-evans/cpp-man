.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE DATE" 3 "" "" ""
.SH "NAME"
boost::date_time::date \- Representation of timepoint at the one day level resolution\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/date\&.hpp>

template<typename T, typename calendar, typename duration_type_> 
class date :
  private boost::less_than_comparable< T, boost::equality_comparable< T > >
{
public:
  // types
  typedef T                          date_type;       
  typedef calendar                   calendar_type;   
  typedef calendar::date_traits_type traits_type;     
  typedef duration_type_             duration_type;   
  typedef calendar::year_type        year_type;       
  typedef calendar::month_type       month_type;      
  typedef calendar::day_type         day_type;        
  typedef calendar::ymd_type         ymd_type;        
  typedef calendar::date_rep_type    date_rep_type;   
  typedef calendar::date_int_type    date_int_type;   
  typedef calendar::day_of_week_type day_of_week_type;

  // construct/copy/destruct
  date(year_type, month_type, day_type);
  date(const ymd_type &);
  explicit date(date_int_type);
  explicit date(date_rep_type);

  // public member functions
  year_type year() const;
  month_type month() const;
  day_type day() const;
  day_of_week_type day_of_week() const;
  ymd_type year_month_day() const;
  bool operator<(const date_type &) const;
  bool operator==(const date_type &) const;
  bool is_special() const;
  bool is_not_a_date() const;
  bool is_infinity() const;
  bool is_pos_infinity() const;
  bool is_neg_infinity() const;
  special_values as_special() const;
  duration_type operator\-(const date_type &) const;
  date_type operator\-(const duration_type &) const;
  date_type operator\-=(const duration_type &);
  date_rep_type day_count() const;
  date_type operator+(const duration_type &) const;
  date_type operator+=(const duration_type &);
};
.fi
.SH "DESCRIPTION"
.PP
The date template represents an interface shell for a date class that is based on a year\-month\-day system such as the gregorian or iso systems\&. It provides basic operations to enable calculation and comparisons\&.
.PP
\fBTheory\fR
.PP
This date representation fundamentally departs from the C tm struct approach\&. The goal for this type is to provide efficient date operations (add, subtract) and storage (minimize space to represent) in a concrete class\&. Thus, the date uses a count internally to represent a particular date\&. The calendar parameter defines the policies for converting the the year\-month\-day and internal counted form here\&. Applications that need to perform heavy formatting of the same date repeatedly will perform better by using the year\-month\-day representation\&.
.PP
Internally the date uses a day number to represent the date\&. This is a monotonic time representation\&. This representation allows for fast comparison as well as simplifying the creation of writing numeric operations\&. Essentially, the internal day number is like adjusted julian day\&. The adjustment is determined by the Epoch date which is represented as day 1 of the calendar\&. Day 0 is reserved for negative infinity so that any actual date is automatically greater than negative infinity\&. When a date is constructed from a date or formatted for output, the appropriate conversions are applied to create the year, month, day representations\&.
.SS "date public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
date(year_type y, month_type m, day_type d);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
date(const ymd_type & ymd);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit date(date_int_type days);
.fi

.sp
This is a private constructor which allows for the creation of new dates\&. It is not exposed to users since that would require class users to understand the inner workings of the date class\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
explicit date(date_rep_type days);
.fi

.RE

.SS "date public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
year_type year() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
month_type month() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
day_type day() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
day_of_week_type day_of_week() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
ymd_type year_month_day() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
bool operator<(const date_type & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool operator==(const date_type & rhs) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
bool is_special() const;
.fi

check to see if date is a special value .RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
bool is_not_a_date() const;
.fi

check to see if date is not a value .RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool is_infinity() const;
.fi

check to see if date is one of the infinity values .RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
bool is_pos_infinity() const;
.fi

check to see if date is greater than all possible dates .RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool is_neg_infinity() const;
.fi

check to see if date is greater than all possible dates .RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
special_values as_special() const;
.fi

return as a special value or a not_special if a normal date .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
duration_type operator\-(const date_type & d) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
date_type operator\-(const duration_type & dd) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
date_type operator\-=(const duration_type & dd);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
date_rep_type day_count() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
date_type operator+(const duration_type & dd) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
date_type operator+=(const duration_type & dd);
.fi

.RE


