.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE MU" 3 "" "" ""
.SH "NAME"
boost::container::multiset
.SH "SYNOPSIS"
.\" value_type: Class template multiset
.\" Class template multiset: value_type
.\" value_compare: Class template multiset
.\" Class template multiset: value_compare
.\" upper_bound: Class template multiset
.\" Class template multiset: upper_bound
.\" swap: Class template multiset
.\" Class template multiset: swap
.\" stored_allocator_type: Class template multiset
.\" Class template multiset: stored_allocator_type
.\" size_type: Class template multiset
.\" Class template multiset: size_type
.\" reverse_iterator: Class template multiset
.\" Class template multiset: reverse_iterator
.\" rend: Class template multiset
.\" Class template multiset: rend
.\" reference: Class template multiset
.\" Class template multiset: reference
.\" rebalance: Class template multiset
.\" Class template multiset: rebalance
.\" rbegin: Class template multiset
.\" Class template multiset: rbegin
.\" pointer: Class template multiset
.\" Class template multiset: pointer
.\" lower_bound: Class template multiset
.\" Class template multiset: lower_bound
.\" key_type: Class template multiset
.\" Class template multiset: key_type
.\" key_compare: Class template multiset
.\" Class template multiset: key_compare
.\" iterator: Class template multiset
.\" Class template multiset: iterator
.\" insert: Class template multiset
.\" Class template multiset: insert
.\" get_stored_allocator: Class template multiset
.\" Class template multiset: get_stored_allocator
.\" find: Class template multiset
.\" Class template multiset: find
.\" erase: Class template multiset
.\" Class template multiset: erase
.\" end: Class template multiset
.\" Class template multiset: end
.\" emplace: Class template multiset
.\" Class template multiset: emplace
.\" difference_type: Class template multiset
.\" Class template multiset: difference_type
.\" count: Class template multiset
.\" Class template multiset: count
.\" const_reverse_iterator: Class template multiset
.\" Class template multiset: const_reverse_iterator
.\" const_reference: Class template multiset
.\" Class template multiset: const_reference
.\" const_pointer: Class template multiset
.\" Class template multiset: const_pointer
.\" const_iterator: Class template multiset
.\" Class template multiset: const_iterator
.\" clear: Class template multiset
.\" Class template multiset: clear
.\" begin: Class template multiset
.\" Class template multiset: begin
.\" allocator_type: Class template multiset
.\" Class template multiset: allocator_type
.\" allocator_traits_type: Class template multiset
.\" Class template multiset: allocator_traits_type

.sp
.nf
// In header: <boost/container/set\&.hpp>

template<typename Key, typename Compare = std::less<Key>, 
         typename Allocator = new_allocator<Key>, 
         typename MultiSetOptions = tree_assoc_defaults> 
class multiset {
public:
  // types
  typedef Key                                                                key_type;              
  typedef Key                                                                value_type;            
  typedef Compare                                                            key_compare;           
  typedef Compare                                                            value_compare;         
  typedef ::boost::container::allocator_traits< Allocator >                  allocator_traits_type; 
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef implementation_defined                                             stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  multiset();
  explicit multiset(const Compare &, 
                    const allocator_type & = allocator_type());
  explicit multiset(const allocator_type &);
  template<typename InputIterator> 
    multiset(InputIterator, InputIterator, const Compare & = Compare(), 
             const allocator_type & = allocator_type());
  template<typename InputIterator> 
    multiset(InputIterator, InputIterator, const allocator_type &);
  template<typename InputIterator> 
    multiset(ordered_range_t, InputIterator, InputIterator, 
             const Compare & = Compare(), 
             const allocator_type & = allocator_type());
  multiset(std::initializer_list< value_type >, const Compare & = Compare(), 
           const allocator_type & = allocator_type());
  multiset(std::initializer_list< value_type >, const allocator_type &);
  multiset(ordered_unique_range_t, std::initializer_list< value_type >, 
           const Compare & = Compare(), 
           const allocator_type & = allocator_type());
  multiset(const multiset &);
  multiset(multiset &&);
  multiset(const multiset &, const allocator_type &);
  multiset(multiset &&, const allocator_type &);
  multiset & operator=(const multiset &);
  multiset & operator=(multiset &&) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
  multiset & operator=(std::initializer_list< value_type >);

  // public member functions
  allocator_type get_allocator() const;
  stored_allocator_type & get_stored_allocator();
  const stored_allocator_type & get_stored_allocator() const;
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  const_iterator cend() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  template<class\&.\&.\&. Args> iterator emplace(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace_hint(const_iterator, Args &&\&.\&.\&.);
  iterator insert(const value_type &);
  iterator insert(value_type &&);
  iterator insert(const_iterator, const value_type &);
  iterator insert(const_iterator, value_type &&);
  template<typename InputIterator> void insert(InputIterator, InputIterator);
  void insert(std::initializer_list< value_type >);
  iterator erase(const_iterator);
  size_type erase(const key_type &);
  iterator erase(const_iterator, const_iterator);
  void swap(multiset &) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
  void clear() noexcept;
  key_compare key_comp() const;
  value_compare value_comp() const;
  iterator find(const key_type &);
  const_iterator find(const key_type &) const;
  size_type count(const key_type &) const;
  iterator lower_bound(const key_type &);
  const_iterator lower_bound(const key_type &) const;
  iterator upper_bound(const key_type &);
  const_iterator upper_bound(const key_type &) const;
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  void rebalance();

  // friend functions
  friend bool operator==(const multiset &, const multiset &);
  friend bool operator!=(const multiset &, const multiset &);
  friend bool operator<(const multiset &, const multiset &);
  friend bool operator>(const multiset &, const multiset &);
  friend bool operator<=(const multiset &, const multiset &);
  friend bool operator>=(const multiset &, const multiset &);
  friend void swap(multiset &, multiset &);
};
.fi
.SH "DESCRIPTION"
.PP
A multiset is a kind of associative container that supports equivalent keys (possibly contains multiple copies of the same key value) and provides for fast retrieval of the keys themselves\&. Class multiset supports bidirectional iterators\&.
.PP
A multiset satisfies all of the requirements of a container and of a reversible container, and of an associative container)\&. multiset also provides most operations described for duplicate keys\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Key
.fi

.sp
is the type to be inserted in the set, which is also the key_type
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Compare = std::less<Key>
.fi

.sp
is the comparison functor used to order keys
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<Key>
.fi

.sp
is the allocator to be used to allocate memory for this container
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
typename MultiSetOptions = tree_assoc_defaults
.fi

.sp
is an packed option type generated using using boost::container::tree_assoc_options\&.
.RE

.SS "multiset public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
multiset();
.fi

.sp
\fBEffects\fR: Default constructs an empty set\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit multiset(const Compare & comp, 
                  const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit multiset(const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified allocator object\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  multiset(InputIterator first, InputIterator last, 
           const Compare & comp = Compare(), 
           const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  multiset(InputIterator first, InputIterator last, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  multiset(ordered_range_t, InputIterator first, InputIterator last, 
           const Compare & comp = Compare(), 
           const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty multiset using the specified comparison object and allocator, and inserts elements from the ordered range [first ,last )\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [first ,last) must be ordered according to the predicate\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
multiset(std::initializer_list< value_type > il, 
         const Compare & comp = Compare(), 
         const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is il\&.begin() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
multiset(std::initializer_list< value_type > il, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is il\&.begin() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
multiset(ordered_unique_range_t, std::initializer_list< value_type > il, 
         const Compare & comp = Compare(), 
         const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the ordered unique range [il\&.begin(), il\&.end())\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [il\&.begin(), il\&.end()) must be ordered according to the predicate and must be unique values\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
multiset(const multiset & x);
.fi

.sp
\fBEffects\fR: Copy constructs a set\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
multiset(multiset && x);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
multiset(const multiset & x, const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
multiset(multiset && x, const allocator_type & a);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
multiset & operator=(const multiset & x);
.fi

.sp
\fBEffects\fR: Makes *this a copy of x\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
multiset & operator=(multiset && x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
.fi

.sp
\fBEffects\fR: this\->swap(x\&.get())\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
multiset & operator=(std::initializer_list< value_type > il);
.fi

.RE

.SS "multiset public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const;
.fi

.sp
\fBEffects\fR: Returns a copy of the allocator that was passed to the object\'s constructor\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get_stored_allocator: Class template multiset
.\" Class template multiset: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator();
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get_stored_allocator: Class template multiset
.\" Class template multiset: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" begin: Class template multiset
.\" Class template multiset: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" begin: Class template multiset
.\" Class template multiset: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" end: Class template multiset
.\" Class template multiset: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" end: Class template multiset
.\" Class template multiset: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rbegin: Class template multiset
.\" Class template multiset: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rbegin: Class template multiset
.\" Class template multiset: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rend: Class template multiset
.\" Class template multiset: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template multiset
.\" Class template multiset: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
size_type max_size() const;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" emplace: Class template multiset
.\" Class template multiset: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type Key constructed with std::forward<Args>(args)\&.\&.\&. and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> 
  iterator emplace_hint(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type Key constructed with std::forward<Args>(args)\&.\&.\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" insert: Class template multiset
.\" Class template multiset: insert

.sp

.nf
iterator insert(const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts x and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" insert: Class template multiset
.\" Class template multiset: insert

.sp

.nf
iterator insert(value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x in the container\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" insert: Class template multiset
.\" Class template multiset: insert

.sp

.nf
iterator insert(const_iterator p, const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" insert: Class template multiset
.\" Class template multiset: insert

.sp

.nf
iterator insert(const_iterator p, value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a value move constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" insert: Class template multiset
.\" Class template multiset: insert

.sp

.nf
template<typename InputIterator> 
  void insert(InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: first, last are not iterators into *this\&.
.sp
\fBEffects\fR: inserts each element from the range [first,last) \&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" insert: Class template multiset
.\" Class template multiset: insert

.sp

.nf
void insert(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: inserts each element from the range [il\&.begin(),il\&.end()) if and only if there is no element with key equivalent to the key of that element\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from il\&.begin() to il\&.end())
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" end: Class template multiset
.\" Class template multiset: end
.\" erase: Class template multiset
.\" Class template multiset: erase

.sp

.nf
iterator erase(const_iterator p);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by p\&.
.sp
\fBReturns\fR: Returns an iterator pointing to the element immediately following q prior to the element being erased\&. If no such element exists, returns end()\&.
.sp
\fBComplexity\fR: Amortized constant time
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" erase: Class template multiset
.\" Class template multiset: erase

.sp

.nf
size_type erase(const key_type & x);
.fi

.sp
\fBEffects\fR: Erases all elements in the container with key equivalent to x\&.
.sp
\fBReturns\fR: Returns the number of erased elements\&.
.sp
\fBComplexity\fR: log(size()) + count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" erase: Class template multiset
.\" Class template multiset: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

.sp
\fBEffects\fR: Erases all the elements in the range [first, last)\&.
.sp
\fBReturns\fR: Returns last\&.
.sp
\fBComplexity\fR: log(size())+N where N is the distance from first to last\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" swap: Class template multiset
.\" Class template multiset: swap

.sp

.nf
void swap(multiset & x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" clear: Class template multiset
.\" Class template multiset: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: erase(a\&.begin(),a\&.end())\&.
.sp
\fBPostcondition\fR: size() == 0\&.
.sp
\fBComplexity\fR: linear in size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the comparison object out of which a was constructed\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns an object of value_compare constructed out of the comparison object\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" end: Class template multiset
.\" Class template multiset: end
.\" find: Class template multiset
.\" Class template multiset: find

.sp

.nf
iterator find(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template multiset
.\" Class template multiset: end
.\" find: Class template multiset
.\" Class template multiset: find

.sp

.nf
const_iterator find(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" count: Class template multiset
.\" Class template multiset: count

.sp

.nf
size_type count(const key_type & x) const;
.fi

.sp
\fBReturns\fR: The number of elements with key equivalent to x\&.
.sp
\fBComplexity\fR: log(size())+count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" lower_bound: Class template multiset
.\" Class template multiset: lower_bound

.sp

.nf
iterator lower_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" lower_bound: Class template multiset
.\" Class template multiset: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" end: Class template multiset
.\" Class template multiset: end
.\" upper_bound: Class template multiset
.\" Class template multiset: upper_bound

.sp

.nf
iterator upper_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" end: Class template multiset
.\" Class template multiset: end
.\" upper_bound: Class template multiset
.\" Class template multiset: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & x) const;
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & x);
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" rebalance: Class template multiset
.\" Class template multiset: rebalance

.sp

.nf
void rebalance();
.fi

.sp
\fBEffects\fR: Rebalances the tree\&. It\'s a no\-op for Red\-Black and AVL trees\&.
.sp
\fBComplexity\fR: Linear
.RE

.SS "multiset friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const multiset & x, const multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const multiset & x, const multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const multiset & x, const multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const multiset & x, const multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const multiset & x, const multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const multiset & x, const multiset & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template multiset
.\" Class template multiset: swap

.sp

.nf
friend void swap(multiset & x, multiset & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


