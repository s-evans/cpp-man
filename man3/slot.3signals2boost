.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE SLOT" 3 "" "" ""
.SH "NAME"
boost::signals2::slot \- Pass slots as function arguments, and associate tracked objects with a slot\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/signals2/slot\&.hpp>

template<typename Signature, 
         typename SlotFunction = boost::function<R (T1, T2, \&.\&.\&., TN)> > 
class slot : public boost::signals2::slot_base {
public:
  // types
  typedef R            result_type;         
  typedef T1           argument_type;         // Exists iff arity == 1
  typedef T1           first_argument_type;   // Exists iff arity == 2
  typedef T2           second_argument_type;  // Exists iff arity == 2
  typedef Signature    signature_type;      
  typedef SlotFunction slot_function_type;  

  // static constants
  static const int arity = N;  // The number of arguments taken by the slot\&.

  // member classes/structs/unions
  template<unsigned n> 
  class arg {
  public:
    // types
    typedef Tn type;  // The type of the slot\'s (n+1)th argument
  };

  // construct/copy/destruct
  template<typename Slot> slot(const Slot &);
  template<typename OtherSignature, typename OtherSlotFunction> 
    slot(const slot<OtherSignature, OtherSlotFunction> &);
  template<typename Func, typename Arg1, typename Arg2, \&.\&.\&., typename ArgN> 
    slot(const Func &, const Arg1 &, const Arg2 &, \&.\&.\&., const ArgN &);

  // invocation
  result_type operator()(arg<0>::type, arg<1>::_type, \&.\&.\&., arg<N\-1>::type);
  result_type operator()(arg<0>::type, arg<1>::_type, \&.\&.\&., arg<N\-1>::type) const;

  // tracking
  slot & track(const weak_ptr<void> &);
  slot & track(const signals2::signal_base &);
  slot & track(const signals2::slot_base &);
  template<typename ForeignWeakPtr> 
    slot & track_foreign(const ForeignWeakPtr &, 
                         typename weak_ptr_traits<ForeignWeakPtr>::shared_type * = 0);
  template<typename ForeignSharedPtr> 
    slot & track_foreign(const ForeignSharedPtr &, 
                         typename shared_ptr_traits<ForeignSharedPtr>::weak_type * = 0);

  // slot function access
  slot_function_type & slot_function();
  const slot_function_type & slot_function() const;
};
.fi
.SH "DESCRIPTION"
.PP
A slot consists of a polymorphic function wrapper (boost::function by default) plus a container of
weak_ptrs which identify the slot\'s "tracked objects"\&. If any of the tracked objects expire, the slot will automatically disable itself\&. That is, the slot\'s function call operator will throw an exception instead of forwarding the function call to the slot\'s polymorphic function wrapper\&. Additionally, a slot will automatically lock all the tracked objects as
shared_ptr
during invocation, to prevent any of them from expiring while the polymorphic function wrapper is being run\&.
.PP
The slot constructor will search for
signals2::signal
and
signals2::trackable
inside incoming function objects and automatically track them\&. It does so by applying a visitor to the incoming functors with boost::visit_each\&.
.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Signature
.fi

.sp

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename SlotFunction = boost::function<R (T1, T2, \&.\&.\&., TN)>
.fi

.RE

.SS "slot public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Slot> slot(const Slot & target);
.fi

.PP
Effects:
.RS 4
Initializes the
SlotFunction
object in
this
with
target, which may be any function object with which a
SlotFunction
can be constructed\&.
.sp
In this special case where the template type parameter
Slot
is a compatible
signals2::signal
type, the signal will automatically be added to the slot\'s tracked object list\&. Otherwise, the slot\'s tracked object list is initially empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename OtherSignature, typename OtherSlotFunction> 
  slot(const slot<OtherSignature, OtherSlotFunction> & other_slot);
.fi

.PP
Effects:
.RS 4
Initializes
this
with a copy of
other_slot\'s
OtherSlotFunction
object and tracked object list\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename Func, typename Arg1, typename Arg2, \&.\&.\&., typename ArgN> 
  slot(const Func & f, const Arg1 & a1, const Arg2 & a2, \&.\&.\&., const ArgN & aN);
.fi

.PP
Effects:
.RS 4
Syntactic sugar for
bind()
when the constructor is passed more than one argument\&. As if:
slot(boost::bind(f, a1, a2, \&.\&.\&., aN))
.RE
.RE

.SS "slot invocation"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
result_type operator()(arg<0>::type a1, arg<1>::_type a2, \&.\&.\&., 
                       arg<N\-1>::type aN);
result_type operator()(arg<0>::type a1, arg<1>::_type a2, \&.\&.\&., 
                       arg<N\-1>::type aN) const;
.fi

.PP
Effects:
.RS 4
Calls the slot\'s
SlotFunction
object\&.
.RE
.PP
Returns:
.RS 4
The result returned by the slot\'s
SlotFunction
object\&.
.RE
.PP
Throws:
.RS 4
Any exceptions thrown by the slot\'s
SlotFunction
object\&.
boost::signals2::expired_slot
if any object in the tracked object list has expired\&.
.RE
.PP
Notes:
.RS 4
If you have already used
lock
to insure the tracked objects are valid, it is slightly more efficient to use the
slot_function() method and call the slot\'s
SlotFunction
directly\&.
.RE
.RE

.SS "slot tracking"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
slot & track(const weak_ptr<void> & tracked_object);
slot & track(const signals2::signal_base & tracked_signal);
slot & track(const signals2::slot_base & tracked_slot);
.fi

.PP
Effects:
.RS 4
Adds object(s) to the slot\'s tracked object list\&. Should any of the tracked objects expire, then subsequent attempts to call the slot\'s
operator()
or
lock()
methods will throw an
signals2::expired_slot
exception\&.
.sp
When tracking a signal, a shared_ptr internal to the signal class is used for tracking\&. The signal does not need to be owned by an external
shared_ptr\&.
.sp
In the case of passing another slot as the argument to
track(), only the objects currently in the other slot\'s tracked object list are added to the tracked object list of
this\&. The other slot object itself is not tracked\&.
.RE
.PP
Returns:
.RS 4
*this
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename ForeignWeakPtr> 
  slot & track_foreign(const ForeignWeakPtr & tracked_object, 
                       typename weak_ptr_traits<ForeignWeakPtr>::shared_type * SFINAE = 0);
template<typename ForeignSharedPtr> 
  slot & track_foreign(const ForeignSharedPtr & tracked_object, 
                       typename shared_ptr_traits<ForeignSharedPtr>::weak_type * SFINAE = 0);
.fi

.PP
Effects:
.RS 4
The
track_foreign() method behaves similarly to calling the
track() method with a boost::shared_ptr or boost::weak_ptr argument\&. However,
track_foreign
is more flexible in that it will accept
shared_ptr
or
weak_ptr
classes from outside of boost (most significantly
std::shared_ptr
or
std::weak_ptr)\&.
.sp
In order to use a particular
shared_ptr
class with this function, a specialization of boost::signals2::shared_ptr_traits must exist for it\&. Also, a specialization of boost::signals2::weak_ptr_traits must be provided for its corresponding
weak_ptr
class\&. The
shared_ptr_traits
specialization must include a
weak_type
member typedef which specifies the corresponding
weak_ptr
type of the
shared_ptr
class\&. Similarly, the
weak_ptr_traits
specialization must include a
shared_type
member typedef which specifies the corresponding
shared_ptr
type of the
weak_ptr
class\&. Specializations for
std::shared_ptr
and
std::weak_ptr
are already provided by the signals2 library\&. For other
shared_ptr
classes, you must provide the specializations\&.
.sp
The second argument "SFINAE" may be ignored, it is used to resolve the overload between either
shared_ptr
or
weak_ptr
objects passed in as the first argument\&.
.RE
.PP
Returns:
.RS 4
*this
.RE
.RE

.SS "slot slot function access"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
slot_function_type & slot_function();
const slot_function_type & slot_function() const;
.fi

.PP
Returns:
.RS 4
A reference to the slot\'s underlying SlotFunction object\&.
.RE
.RE


