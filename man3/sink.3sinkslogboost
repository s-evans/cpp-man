.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS SINK" 3 "" "" ""
.SH "NAME"
boost::log::sinks::sink \- A base class for a logging sink frontend\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/sinks/sink\&.hpp>


class sink {
public:
  // types
  typedef \fIunspecified\fR exception_handler_type;  // An exception handler type\&. 

  // construct/copy/destruct
  explicit sink(bool);
  sink(sink const &) = delete;
  sink & operator=(sink const &) = delete;
  ~sink();

  // public member functions
  virtual bool will_consume(attribute_value_set const &) = 0;
  virtual void consume(record_view const &) = 0;
  virtual bool try_consume(record_view const &);
  virtual void flush() = 0;
  bool is_cross_thread() const noexcept;
};
.fi
.SH "DESCRIPTION"
.SS "sink public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit sink(bool cross_thread);
.fi

.sp
Default constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
sink(sink const &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
sink & operator=(sink const &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
~sink();
.fi

.sp
Virtual destructor
.RE

.SS "sink public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
virtual bool will_consume(attribute_value_set const & attributes) = 0;
.fi

.sp
The method returns
true
if no filter is set or the attribute values pass the filter
.sp

.PP
Parameters:
.RS 4
.PP
attributes
.RS 4
A set of attribute values of a logging record
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
virtual void consume(record_view const & rec) = 0;
.fi

.sp
The method puts logging record to the sink
.sp

.PP
Parameters:
.RS 4
.PP
rec
.RS 4
Logging record to consume
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
virtual bool try_consume(record_view const & rec);
.fi

.sp
The method attempts to put logging record to the sink\&. The method may be used by the core in order to determine the most efficient order of sinks to feed records to in case of heavy contention\&. Sink implementations may implement try/backoff logic in order to improve overall logging throughput\&.
.sp

.PP
Parameters:
.RS 4
.PP
rec
.RS 4
Logging record to consume
.RE
.RE
.PP
Returns:
.RS 4
true, if the record was consumed,
false, if not\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
virtual void flush() = 0;
.fi

.sp
The method performs flushing of any internal buffers that may hold log records\&. The method may take considerable time to complete and may block both the calling thread and threads attempting to put new records into the sink while this call is in progress\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool is_cross_thread() const noexcept;
.fi

.sp
The method indicates that the sink passes log records between different threads\&. This information is needed by the logging core to detach log records from all thread\-specific resources before passing it to the sink\&.
.RE


