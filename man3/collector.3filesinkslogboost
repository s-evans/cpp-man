.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT COLLECTOR" 3 "" "" ""
.SH "NAME"
boost::log::sinks::file::collector \- Base class for file collectors\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/sinks/text_file_backend\&.hpp>


struct collector {
  // construct/copy/destruct
  collector() = default;
  collector(collector const &) = delete;
  collector & operator=(collector const &) = delete;
  ~collector();

  // public member functions
  virtual void store_file(filesystem::path const &) = 0;
  virtual uintmax_t 
  scan_for_files(scan_method, filesystem::path const & = filesystem::path(), 
                 unsigned int * = 0) = 0;
};
.fi
.SH "DESCRIPTION"
.PP
All file collectors, supported by file sink backends, should inherit this class\&.
.SS "collector public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
collector() = default;
.fi

.sp
Default constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
collector(collector const &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
collector & operator=(collector const &) = delete;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
~collector();
.fi

.sp
Virtual destructor
.RE

.SS "collector public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
virtual void store_file(filesystem::path const & src_path) = 0;
.fi

.sp
The function stores the specified file in the storage\&. May lead to an older file deletion and a long file moving\&.
.sp

.PP
Parameters:
.RS 4
.PP
src_path
.RS 4
The name of the file to be stored
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
virtual uintmax_t 
scan_for_files(scan_method method, 
               filesystem::path const & pattern = filesystem::path(), 
               unsigned int * counter = 0) = 0;
.fi

.sp
Scans the target directory for the files that have already been stored\&. The found files are added to the collector in order to be tracked and erased, if needed\&.
.sp
The function may scan the directory in two ways: it will either consider every file in the directory a log file, or will only consider files with names that match the specified pattern\&. The pattern may contain the following placeholders:
.sp

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
y, Y, m, d \- date components, in Boost\&.DateTime meaning\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
H, M, S, f \- time components, in Boost\&.DateTime meaning\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
N \- numeric file counter\&. May also contain width specification in printf\-compatible form (e\&.g\&. %5N)\&. The resulting number will always be zero\-filled\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
%% \- a percent sign
.RE
.RS 4
All other placeholders are not supported\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
In case if
\fImethod\fR
is
scan_matching
the effect of this function is highly dependent on the
\fIpattern\fR
definition\&. It is recommended to choose patterns with easily distinguished placeholders (i\&.e\&. having delimiters between them)\&. Otherwise either some files can be mistakenly found or not found, which in turn may lead to an incorrect file deletion\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
counter
.RS 4
If not
NULL
and
\fImethod\fR
is
scan_matching, the method suggests initial value of a file counter that may be used in the file name pattern\&. The parameter is not used otherwise\&.
.RE
.PP
method
.RS 4
The method of scanning\&. If
no_scan
is specified, the call has no effect\&.
.RE
.PP
pattern
.RS 4
The file name pattern if
\fImethod\fR
is
scan_matching\&. Otherwise the parameter is not used\&.
.RE
.RE
.PP
Returns:
.RS 4
The number of found files\&.
.RE
.RE


