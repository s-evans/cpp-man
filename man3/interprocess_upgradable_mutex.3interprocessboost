.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS INTER" 3 "" "" ""
.SH "NAME"
boost::interprocess::interprocess_upgradable_mutex
.SH "SYNOPSIS"
.\" unlock_upgradable_and_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_upgradable_and_lock_sharable
.\" unlock_upgradable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_upgradable_and_lock
.\" unlock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_upgradable
.\" unlock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_sharable
.\" unlock_and_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_and_lock_upgradable
.\" unlock_and_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_and_lock_sharable
.\" unlock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock
.\" try_unlock_upgradable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_unlock_upgradable_and_lock
.\" try_unlock_sharable_and_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_unlock_sharable_and_lock_upgradable
.\" try_unlock_sharable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_unlock_sharable_and_lock
.\" try_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_lock_upgradable
.\" try_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_lock_sharable
.\" try_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_lock
.\" timed_unlock_upgradable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_unlock_upgradable_and_lock
.\" timed_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_lock_upgradable
.\" timed_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_lock_sharable
.\" timed_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_lock
.\" lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: lock_upgradable
.\" lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: lock_sharable
.\" lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: lock
.\" interprocess_upgradable_mutex: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: interprocess_upgradable_mutex
.\" interprocess_upgradable_mutex: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: interprocess_upgradable_mutex

.sp
.nf
// In header: <boost/interprocess/sync/interprocess_upgradable_mutex\&.hpp>


class interprocess_upgradable_mutex {
public:
  // construct/copy/destruct
  interprocess_upgradable_mutex(const interprocess_upgradable_mutex &);
  interprocess_upgradable_mutex();
  interprocess_upgradable_mutex & 
  operator=(const interprocess_upgradable_mutex &);
  ~interprocess_upgradable_mutex();

  // public member functions
  void lock();
  bool try_lock();
  bool timed_lock(const boost::posix_time::ptime &);
  void unlock();
  void lock_sharable();
  bool try_lock_sharable();
  bool timed_lock_sharable(const boost::posix_time::ptime &);
  void unlock_sharable();
  void lock_upgradable();
  bool try_lock_upgradable();
  bool timed_lock_upgradable(const boost::posix_time::ptime &);
  void unlock_upgradable();
  void unlock_and_lock_upgradable();
  void unlock_and_lock_sharable();
  void unlock_upgradable_and_lock_sharable();
  void unlock_upgradable_and_lock();
  bool try_unlock_upgradable_and_lock();
  *bool timed_unlock_upgradable_and_lock(const boost::posix_time::ptime &);
  bool try_unlock_sharable_and_lock();
  bool try_unlock_sharable_and_lock_upgradable();
};
.fi
.SH "DESCRIPTION"
.PP
Wraps a
interprocess_upgradable_mutex
that can be placed in shared memory and can be shared between processes\&. Allows timed lock tries
.SS "interprocess_upgradable_mutex public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
interprocess_upgradable_mutex(const interprocess_upgradable_mutex &);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
interprocess_upgradable_mutex();
.fi

.sp
Constructs the upgradable lock\&. Throws
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
interprocess_upgradable_mutex & 
operator=(const interprocess_upgradable_mutex &);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
~interprocess_upgradable_mutex();
.fi

.sp
Destroys the upgradable lock\&. Does not throw\&.
.RE

.SS "interprocess_upgradable_mutex public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: lock

.sp

.nf
void lock();
.fi

.sp
Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, sharable or upgradable ownership of the mutex, it waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" try_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_lock

.sp

.nf
bool try_lock();
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting\&. If no other thread has exclusive, sharable or upgradable ownership of the mutex this succeeds\&. Returns: If it can acquire exclusive ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" timed_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_lock

.sp

.nf
bool timed_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, sharable or upgradable ownership of the mutex or abs_time is reached\&. Returns: If acquires exclusive ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock

.sp

.nf
void unlock();
.fi

.sp
Precondition: The thread must have exclusive ownership of the mutex\&. Effects: The calling thread releases the exclusive ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: lock_sharable

.sp

.nf
void lock_sharable();
.fi

.sp
Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" try_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_lock_sharable

.sp

.nf
bool try_lock_sharable();
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting\&. If no other thread has exclusive ownership of the mutex this succeeds\&. Returns: If it can acquire sharable ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" timed_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_lock_sharable

.sp

.nf
bool timed_lock_sharable(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached\&. Returns: If acquires sharable ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" unlock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_sharable

.sp

.nf
void unlock_sharable();
.fi

.sp
Precondition: The thread must have sharable ownership of the mutex\&. Effects: The calling thread releases the sharable ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: lock_upgradable

.sp

.nf
void lock_upgradable();
.fi

.sp
Effects: The calling thread tries to obtain upgradable ownership of the mutex, and if another thread has exclusive or upgradable ownership of the mutex, waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" try_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_lock_upgradable

.sp

.nf
bool try_lock_upgradable();
.fi

.sp
Effects: The calling thread tries to acquire upgradable ownership of the mutex without waiting\&. If no other thread has exclusive or upgradable ownership of the mutex this succeeds\&. Returns: If it can acquire upgradable ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" timed_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_lock_upgradable

.sp

.nf
bool timed_lock_upgradable(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire upgradable ownership of the mutex waiting if necessary until no other thread has exclusive or upgradable ownership of the mutex or abs_time is reached\&. Returns: If acquires upgradable ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" unlock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_upgradable

.sp

.nf
void unlock_upgradable();
.fi

.sp
Precondition: The thread must have upgradable ownership of the mutex\&. Effects: The calling thread releases the upgradable ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" unlock_and_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_and_lock_upgradable

.sp

.nf
void unlock_and_lock_upgradable();
.fi

.sp
Precondition: The thread must have exclusive ownership of the mutex\&. Effects: The thread atomically releases exclusive ownership and acquires upgradable ownership\&. This operation is non\-blocking\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" unlock_and_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_and_lock_sharable

.sp

.nf
void unlock_and_lock_sharable();
.fi

.sp
Precondition: The thread must have exclusive ownership of the mutex\&. Effects: The thread atomically releases exclusive ownership and acquires sharable ownership\&. This operation is non\-blocking\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" unlock_upgradable_and_lock_sharable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_upgradable_and_lock_sharable

.sp

.nf
void unlock_upgradable_and_lock_sharable();
.fi

.sp
Precondition: The thread must have upgradable ownership of the mutex\&. Effects: The thread atomically releases upgradable ownership and acquires sharable ownership\&. This operation is non\-blocking\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" unlock_upgradable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: unlock_upgradable_and_lock

.sp

.nf
void unlock_upgradable_and_lock();
.fi

.sp
Precondition: The thread must have upgradable ownership of the mutex\&. Effects: The thread atomically releases upgradable ownership and acquires exclusive ownership\&. This operation will block until all threads with sharable ownership release their sharable lock\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" try_unlock_upgradable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_unlock_upgradable_and_lock

.sp

.nf
bool try_unlock_upgradable_and_lock();
.fi

.sp
Precondition: The thread must have upgradable ownership of the mutex\&. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership\&. This operation will fail if there are threads with sharable ownership, but it will maintain upgradable ownership\&. Returns: If acquires exclusive ownership, returns true\&. Otherwise returns false\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" timed_unlock_upgradable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: timed_unlock_upgradable_and_lock

.sp

.nf
*bool timed_unlock_upgradable_and_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Precondition: The thread must have upgradable ownership of the mutex\&. Effects: The thread atomically releases upgradable ownership and tries to acquire exclusive ownership, waiting if necessary until abs_time\&. This operation will fail if there are threads with sharable ownership or timeout reaches, but it will maintain upgradable ownership\&. Returns: If acquires exclusive ownership, returns true\&. Otherwise returns false\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" try_unlock_sharable_and_lock: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_unlock_sharable_and_lock

.sp

.nf
bool try_unlock_sharable_and_lock();
.fi

.sp
Precondition: The thread must have sharable ownership of the mutex\&. Effects: The thread atomically releases sharable ownership and tries to acquire exclusive ownership\&. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership\&. Returns: If acquires exclusive ownership, returns true\&. Otherwise returns false\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" try_unlock_sharable_and_lock_upgradable: Class interprocess_upgradable_mutex
.\" Class interprocess_upgradable_mutex: try_unlock_sharable_and_lock_upgradable

.sp

.nf
bool try_unlock_sharable_and_lock_upgradable();
.fi

.sp
Precondition: The thread must have sharable ownership of the mutex\&. Effects: The thread atomically releases sharable ownership and tries to acquire upgradable ownership\&. This operation will fail if there are threads with sharable or upgradable ownership, but it will maintain sharable ownership\&. Returns: If acquires upgradable ownership, returns true\&. Otherwise returns false\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


