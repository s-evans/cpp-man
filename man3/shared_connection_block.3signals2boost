.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS SHARED_C" 3 "" "" ""
.SH "NAME"
boost::signals2::shared_connection_block \- Blocks a connection between a signal and a slot\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/signals2/shared_connection_block\&.hpp>


class shared_connection_block {
public:
  // construct/copy/destruct
  shared_connection_block(const boost::signals2::connection & = connection(), 
                          bool = true);
  shared_connection_block(const boost::signals2::shared_connection_block &);
  shared_connection_block& 
  operator=(const boost::signals2::shared_connection_block &);
  ~shared_connection_block();

  // connection blocking
  void unblock();
  void block();
  bool blocking() const;

  // miscellaneous methods
  boost::signals2::connection connection() const;
};
.fi
.SH "DESCRIPTION"
.PP
A
shared_connection_block
object blocks a connection, preventing the associated slot from executing when the associated signal is invoked\&. The connection will remain blocked until every
shared_connection_block
that references the connection releases its block\&. A
shared_connection_block
releases its block when it is destroyed or its
unblock
method is called\&.
.PP
A
shared_connection_block
is safe to use even after the
signals2::connection
object it was constructed from has been destroyed, or the connection it references has been disconnected\&.
.PP
Note, blocking a connection does not guarantee the associated slot has finished execution if it is already in the process of being run when the connection block goes into effect\&. This is similar to the behaviour of disconnect, in that blocking a connection will not wait for the connection\'s associated slot to complete execution\&. This situation may arise in a multi\-threaded environment if the connection block goes into effect concurrently with signal invocation, or in a single\-threaded environment if a slot blocks its own connection\&.
.SS "shared_connection_block public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
shared_connection_block(const boost::signals2::connection & conn = connection(), 
                        bool initially_blocking = true);
.fi

.PP
Effects:
.RS 4
Creates a
shared_connection_block
which can block the connection referenced by
conn\&. The
shared_connection_block
will initially block the connection if and only if the
initially_blocking
parameter is
true\&. The block on the connection may be released by calling the
unblock
method, or destroying the
shared_connection_block
object\&.
.sp
Default construction of a
shared_connection_block
results in a
shared_connection_block
which references the NULL connection\&. Such a
shared_connection_block
is safe to use, though not particularly useful until it is assigned another
shared_connection_block
which references a real connection\&.
.RE
.PP
Postconditions:
.RS 4
this\->blocking() == initially_blocking
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
shared_connection_block(const boost::signals2::shared_connection_block & other);
.fi

.PP
Effects:
.RS 4
Copy constructs a
shared_connection_block
which references the same connection as
other\&.
.RE
.PP
Postconditions:
.RS 4
this\->connection() == other\&.connection()
.sp
this\->blocking() == other\&.blocking()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
shared_connection_block& 
operator=(const boost::signals2::shared_connection_block & rhs);
.fi

.PP
Effects:
.RS 4
Makes
this
reference the same connection as
rhs\&.
.RE
.PP
Postconditions:
.RS 4
this\->connection() == rhs\&.connection()
.sp
this\->blocking() == rhs\&.blocking()
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
~shared_connection_block();
.fi

.PP
Effects:
.RS 4
If
blocking() is true, releases the connection block\&.
.RE
.RE

.SS "shared_connection_block connection blocking"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void unblock();
.fi

.PP
Effects:
.RS 4
If
blocking() is true, releases the connection block\&. Note, the connection may remain blocked due to other
shared_connection_block
objects\&.
.RE
.PP
Postconditions:
.RS 4
this\->blocking() == false\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void block();
.fi

.PP
Effects:
.RS 4
If
blocking() is false, reasserts a block on the connection\&.
.RE
.PP
Postconditions:
.RS 4
this\->blocking() == true\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool blocking() const;
.fi

.PP
Returns:
.RS 4
true
if
this
is asserting a block on the connection\&.
.RE
.PP
Notes:
.RS 4
this\->blocking() == true
implies
connection::blocked() == true
for the connection\&. However,
this\->blocking() == false
does not necessarily imply
connection::blocked() == false, since the connection may be blocked by another
shared_connection_block
object\&.
.RE
.RE

.SS "shared_connection_block miscellaneous methods"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
boost::signals2::connection connection() const;
.fi

.PP
Returns:
.RS 4
A connection object for the connection referenced by
this\&.
.RE
.RE


