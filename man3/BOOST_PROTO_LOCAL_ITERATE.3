.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_P" 3 "" "" ""
.SH "NAME"
BOOST_PROTO_LOCAL_ITERATE \- Vertical repetition of a user\-supplied macro\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/repeat\&.hpp>

BOOST_PROTO_LOCAL_ITERATE()
.fi
.SH "DESCRIPTION"
.PP

BOOST_PROTO_LOCAL_ITERATE()
is used generate the kind of repetitive code that is typical of EDSLs built with Proto\&. This macro causes the user\-defined macro
BOOST_PROTO_LOCAL_MACRO()
to be expanded with values in the range specified by
BOOST_PROTO_LOCAL_LIMITS\&.
.PP

\fBUsage:\fR
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
#include BOOST_PROTO_LOCAL_ITERATE()
.fi
.if n \{\
.RE
.\}
.sp

.PP

\fBExample:\fR
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
// Generate BOOST_PROTO_MAX_ARITY\-1 overloads of the
// following construct() function template\&.
#define BOOST_PROTO_LOCAL_MACRO(N, typename_A, A_const_ref, A_const_ref_a, ref_a)\e
template<typename T, typename_A(N)>                               \e
typename proto::result_of::make_expr<                             \e
    proto::tag::function                                          \e
  , construct_helper<T>                                           \e
  , A_const_ref(N)                                                \e
>::type const                                                     \e
construct(A_const_ref_a(N))                                       \e
{                                                                 \e
    return proto::make_expr<                                      \e
        proto::tag::function                                      \e
    >(                                                            \e
        construct_helper<T>()                                     \e
      , ref_a(N)                                                  \e
    );                                                            \e
}
#define BOOST_PROTO_LOCAL_LIMITS (1, BOOST_PP_DEC(BOOST_PROTO_MAX_ARITY))
#include BOOST_PROTO_LOCAL_ITERATE()
.fi
.if n \{\
.RE
.\}
.sp

.PP
The above inclusion of
BOOST_PROTO_LOCAL_ITERATE()
will generate the following code:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
template<typename T, typename A0>
typename proto::result_of::make_expr<
    proto::tag::function
  , construct_helper<T>
  , A0 const &
>::type const
construct(A0 const & a0)
{
    return proto::make_expr<
        proto::tag::function
    >(
        construct_helper<T>()
      , boost::ref(a0)
    );
}

template<typename T, typename A0, typename A1>
typename proto::result_of::make_expr<
    proto::tag::function
  , construct_helper<T>
  , A0 const &
  , A1 const &
>::type const
construct(A0 const & a0, A1 const & a1)
{
    return proto::make_expr<
        proto::tag::function
    >(
        construct_helper<T>()
      , boost::ref(a0)
      , boost::ref(a1)
    );
}

// \&.\&.\&. and so on, up to BOOST_PROTO_MAX_ARITY\-1 arguments \&.\&.\&.
.fi
.if n \{\
.RE
.\}
.sp

.PP
If
BOOST_PROTO_LOCAL_LIMITS
is not defined by the user, it defaults to
(1, BOOST_PROTO_MAX_ARITY)\&.
.PP
At each iteration,
BOOST_PROTO_LOCAL_MACRO()
is invoked with the current iteration number and the following 4 macro parameters:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_typename_A.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_A.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_A_a.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_a.RE
.sp
.RE
If these macros are not defined by the user, they default respectively to:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_typename_A.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_A_const_ref.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_A_const_ref_a.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_ref_a.RE
.sp
.RE

.PP
After including
BOOST_PROTO_LOCAL_ITERATE(), the following macros are automatically undefined:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_MACRO.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_LIMITS.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_typename_A.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_A.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_A_a.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
BOOST_PROTO_LOCAL_a.RE
.sp
.RE


