.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE WH" 3 "" "" ""
.SH "NAME"
boost::proto::when \- A grammar element and a PrimitiveTransform that associates a transform with the grammar\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/transform/when\&.hpp>

template<typename Grammar, typename PrimitiveTransform = Grammar> 
struct when :  PrimitiveTransform {
  // types
  typedef typename Grammar::proto_grammar proto_grammar;
};
.fi
.SH "DESCRIPTION"
.PP
Use
proto::when<>
to override a grammar\'s default transform with a custom transform\&. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression\&.

.sp
.if n \{\
.RS 4
.\}
.nf
// Count the terminals in an expression tree\&.
// Must be invoked with initial state == mpl::int_<0>()\&.
struct CountLeaves :
  proto::or_<
    proto::when<proto::terminal<proto::_>, mpl::next<proto::_state>()>,
    proto::otherwise<proto::fold<proto::_, proto::_state, CountLeaves> >
  >
{};
.fi
.if n \{\
.RE
.\}
.sp

.PP
In
proto::when<G, T>, when
T
is a class type it is a
PrimitiveTransform
and the following equivalencies hold:

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

boost::result_of<proto::when<G,T>(E,S,V)>::type
is the same as
boost::result_of<T(E,S,V)>::type\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}

proto::when<G,T>()(e,s,d)
is the same as
T()(e,s,d)\&.
.RE

