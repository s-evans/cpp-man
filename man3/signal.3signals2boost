.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE SIG" 3 "" "" ""
.SH "NAME"
boost::signals2::signal \- Safe multicast callback\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/signals2/signal\&.hpp>

template<typename Signature, 
         typename Combiner = boost::signals2::optional_last_value<R>, 
         typename Group = int, typename GroupCompare = std::less<Group>, 
         typename SlotFunction = boost::function<Signature>, 
         typename ExtendedSlotFunction = boost::function<R (const connection &, T1, T2, \&.\&.\&., TN)>, 
         typename Mutex = boost::signals2::mutex> 
class signal : public boost::signals2::signal_base {
public:
  // types
  typedef Signature                                                                          signature_type;             
  typedef typename Combiner::result_type                                                     result_type;                
  typedef Combiner                                                                           combiner_type;              
  typedef Group                                                                              group_type;                 
  typedef GroupCompare                                                                       group_compare_type;         
  typedef SlotFunction                                                                       slot_function_type;         
  typedef typename signals2::slot<Signature, SlotFunction>                                   slot_type;                  
  typedef ExtendedSlotFunction                                                               extended_slot_function_type;
  typedef typename signals2::slot<R (const connection &, T1, \&.\&.\&., TN), ExtendedSlotFunction> extended_slot_type;         
  typedef typename SlotFunction::result_type                                                 slot_result_type;           
  typedef \fIunspecified\fR                                                                        slot_call_iterator;         
  typedef T1                                                                                 argument_type;                // Exists iff arity == 1
  typedef T1                                                                                 first_argument_type;          // Exists iff arity == 2
  typedef T2                                                                                 second_argument_type;         // Exists iff arity == 2

  // static constants
  static const int arity = N;  // The number of arguments taken by the signal\&.

  // member classes/structs/unions
  template<unsigned n> 
  class arg {
  public:
    // types
    typedef Tn type;  // The type of the signal\'s (n+1)th argument
  };

  // construct/copy/destruct
  signal(const combiner_type& = combiner_type(), 
         const group_compare_type& = group_compare_type());
  signal(signal &&);
  signal& operator=(signal &&);

  // connection management
  connection connect(const slot_type&, connect_position = at_back);
  connection connect(const group_type&, const slot_type&, 
                     connect_position = at_back);
  connection connect_extended(const extended_slot_type&, 
                              connect_position = at_back);
  connection connect_extended(const group_type&, const extended_slot_type&, 
                              connect_position = at_back);
  void disconnect(const group_type&);
  template<typename S> void disconnect(const S&);
  void disconnect_all_slots();
  bool empty() const;
  std::size_t num_slots() const;

  // invocation
  result_type operator()(arg<0>::type, arg<1>::type, \&.\&.\&., arg<N\-1>::type);
  result_type operator()(arg<0>::type, arg<1>::type, \&.\&.\&., arg<N\-1>::type) const;

  // combiner access
  combiner_type combiner() const;
  void set_combiner(const combiner_type&);

  // modifiers
  void swap(signal&);
};

// specialized algorithms
template<typename Signature, typename Combiner, typename Group, 
         typename GroupCompare, typename SlotFunction, 
         typename ExtendedSlotFunction, typename Mutex> 
  void swap(signal<Signature, Combiner, Group, GroupCompare, SlotFunction, ExtendedSlotFunction, Mutex>&, 
            signal<Signature, Combiner, Group, GroupCompare, SlotFunction, ExtendedSlotFunction, Mutex>&);
.fi
.SH "DESCRIPTION"
.PP
See the
tutorial
for more information on how to use the signal class\&.
.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Signature
.fi

.sp

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Combiner = boost::signals2::optional_last_value<R>
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Group = int
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
typename GroupCompare = std::less<Group>
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
typename SlotFunction = boost::function<Signature>
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
typename ExtendedSlotFunction = boost::function<R (const connection &, T1, T2, \&.\&.\&., TN)>
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
typename Mutex = boost::signals2::mutex
.fi

.RE

.SS "signal public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

typedef
typename
signals2::slot<R
(const
connection
&,
T1,
\&.\&.\&.,
TN),
ExtendedSlotFunction>
extended_slot_type;
.sp
Slots of the
extended_slot_type
may be connected to the signal using the
connect_extended
methods\&. The
extended_slot_type
has an additional
signals2::connection
argument in its signature, which gives slot functions access to their connection to the signal invoking them\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

typedef
typename
SlotFunction::result_type
slot_result_type;
.sp
This is the type returned when dereferencing the input iterators passed to the signal\'s combiner\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

typedef
\fIunspecified\fR
slot_call_iterator;
.sp
The input iterator type passed to the combiner when the signal is invoked\&.
.RE

.SS "signal public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
signal(const combiner_type& combiner = combiner_type(), 
       const group_compare_type& compare = group_compare_type());
.fi

.PP
Effects:
.RS 4
Initializes the signal to contain no slots, copies the given combiner into internal storage, and stores the given group comparison function object to compare groups\&.
.RE
.PP
Postconditions:
.RS 4
this\->empty()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
signal(signal && other);
.fi

.sp
Move constructor\&.
.PP
Postconditions:
.RS 4
The signal
other
is in a "moved\-from" state where it may only be destroyed, swapped, or move assigned\&. Any other operation on a "moved\-from" signal is invalid\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
signal& operator=(signal && rhs);
.fi

.sp
Move assignment\&.
.PP
Postconditions:
.RS 4
The signal
rhs
is in a "moved\-from" state where it may only be destroyed, swapped, or move assigned\&. Any other operation on a "moved\-from" signal is invalid\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "signal connection management"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
connection connect(const slot_type& slot, connect_position at = at_back);
connection connect(const group_type& group, const slot_type& slot, 
                   connect_position at = at_back);
.fi

.PP
Effects:
.RS 4
Connects the signal this to the incoming slot\&. If the slot is inactive, i\&.e\&., any of the slots\'s tracked objects have been destroyed, then the call to connect is a no\-op\&. If the second version of
connect
is invoked, the slot is associated with the given group\&. The
at
parameter specifies where the slot should be connected:
at_front
indicates that the slot will be connected at the front of the list or group of slots and
at_back
indicates that the slot will be connected at the back of the list or group of slots\&.
.RE
.PP
Returns:
.RS 4
A
signals2::connection
object that references the newly\-created connection between the signal and the slot; if the slot is inactive, returns a disconnected connection\&.
.RE
.PP
Throws:
.RS 4
This routine meets the strong exception guarantee, where any exception thrown will cause the slot to not be connected to the signal\&.
.RE
.PP
Complexity:
.RS 4
Constant time when connecting a slot without a group name or logarithmic in the number of groups when connecting to a particular group\&.
.RE
.PP
Notes:
.RS 4
It is unspecified whether connecting a slot while the signal is calling will result in the slot being called immediately\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
connection connect_extended(const extended_slot_type& slot, 
                            connect_position at = at_back);
connection connect_extended(const group_type& group, 
                            const extended_slot_type& slot, 
                            connect_position at = at_back);
.fi

.sp
The
connect_extended
methods work the same as the
connect
methods, except they take slots of type
extended_slot_type\&. This is useful if a slot needs to access the connection between it and the signal invoking it, for example if it wishes to disconnect or block its own connection\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void disconnect(const group_type& group);
template<typename S> void disconnect(const S& slot_func);
.fi

.PP
Effects:
.RS 4
If the parameter is (convertible to) a group name, any slots in the given group are disconnected\&. Otherwise, any slots equal to the given slot function are disconnected\&.
.sp
Note, the
slot_func
argument should not be an actual
signals2::slot
object (which does not even support
operator==), but rather the functor you wrapped inside a
signals2::slot
when you initially made the connection\&.
.RE
.PP
Throws:
.RS 4
Will not throw unless a user destructor or equality operator
==
throws\&. If either throws, not all slots may be disconnected\&.
.RE
.PP
Complexity:
.RS 4
If a group is given, O(lg g) + k where g is the number of groups in the signal and k is the number of slots in the group\&. Otherwise, linear in the number of slots connected to the signal\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void disconnect_all_slots();
.fi

.PP
Effects:
.RS 4
Disconnects all slots connected to the signal\&.
.RE
.PP
Postconditions:
.RS 4
this\->empty()\&.
.RE
.PP
Throws:
.RS 4
If disconnecting a slot causes an exception to be thrown, not all slots may be disconnected\&.
.RE
.PP
Complexity:
.RS 4
Linear in the number of slots known to the signal\&.
.RE
.PP
Notes:
.RS 4
May be called at any time within the lifetime of the signal, including during calls to the signal\'s slots\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.PP
Returns:
.RS 4
true
if no slots are connected to the signal, and
false
otherwise\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.PP
Complexity:
.RS 4
Linear in the number of slots known to the signal\&.
.RE
.PP
Rationale:
.RS 4
Slots can disconnect at any point in time, including while those same slots are being invoked\&. It is therefore possible that the implementation must search through a list of disconnected slots to determine if any slots are still connected\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
std::size_t num_slots() const;
.fi

.PP
Returns:
.RS 4
The number of slots connected to the signal
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.PP
Complexity:
.RS 4
Linear in the number of slots known to the signal\&.
.RE
.PP
Rationale:
.RS 4
Slots can disconnect at any point in time, including while those same slots are being invoked\&. It is therefore possible that the implementation must search through a list of disconnected slots to determine how many slots are still connected\&.
.RE
.RE

.SS "signal invocation"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
result_type operator()(arg<0>::type a1, arg<1>::type a2, \&.\&.\&., 
                       arg<N\-1>::type aN);
result_type operator()(arg<0>::type a1, arg<1>::type a2, \&.\&.\&., 
                       arg<N\-1>::type aN) const;
.fi

.PP
Effects:
.RS 4
Invokes the combiner with a
slot_call_iterator
range [first, last) corresponding to the sequence of calls to the slots connected to signal
*this\&. Dereferencing an iterator in this range causes a slot call with the given set of parameters
(a1, a2, \&.\&.\&., aN), the result of which is returned from the iterator dereference operation\&.
.RE
.PP
Returns:
.RS 4
The result returned by the combiner\&.
.RE
.PP
Throws:
.RS 4
If an exception is thrown by a slot call, or if the combiner does not dereference any slot past some given slot, all slots after that slot in the internal list of connected slots will not be invoked\&.
.RE
.PP
Notes:
.RS 4
Only the slots associated with iterators that are actually dereferenced will be invoked\&. Multiple dereferences of the same iterator will not result in multiple slot invocations, because the return value of the slot will be cached\&.
.sp
The
const
version of the function call operator will invoke the combiner as
const, whereas the non\-const
version will invoke the combiner as non\-const\&.
.RE
.RE

.SS "signal combiner access"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
combiner_type combiner() const;
.fi

.PP
Returns:
.RS 4
A copy of the stored combiner\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void set_combiner(const combiner_type& combiner);
.fi

.PP
Effects:
.RS 4
Copies a new combiner into the signal for use with future signal invocations\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "signal modifiers"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void swap(signal& other);
.fi

.PP
Effects:
.RS 4
Swaps the signal referenced in
this
and
other\&.
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE

.SS "signal specialized algorithms"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Signature, typename Combiner, typename Group, 
         typename GroupCompare, typename SlotFunction, 
         typename ExtendedSlotFunction, typename Mutex> 
  void swap(signal<Signature, Combiner, Group, GroupCompare, SlotFunction, ExtendedSlotFunction, Mutex>& x, 
            signal<Signature, Combiner, Group, GroupCompare, SlotFunction, ExtendedSlotFunction, Mutex>& y);
.fi

.PP
Effects:
.RS 4
x\&.swap(y)
.RE
.PP
Throws:
.RS 4
Will not throw\&.
.RE
.RE


