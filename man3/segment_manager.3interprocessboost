.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLAT" 3 "" "" ""
.SH "NAME"
boost::interprocess::segment_manager
.SH "SYNOPSIS"
.\" void_pointer: Class template segment_manager
.\" Class template segment_manager: void_pointer
.\" type: Class template segment_manager
.\" Class template segment_manager: type
.\" try_atomic_func: Class template segment_manager
.\" Class template segment_manager: try_atomic_func
.\" size_type: Class template segment_manager
.\" Class template segment_manager: size_type
.\" shrink_to_fit_indexes: Class template segment_manager
.\" Class template segment_manager: shrink_to_fit_indexes
.\" segment_manager_base_type: Class template segment_manager
.\" Class template segment_manager: segment_manager_base_type
.\" segment_manager_base: Class template segment_manager
.\" Class template segment_manager: segment_manager_base
.\" segment_manager: Class template segment_manager
.\" Class template segment_manager: segment_manager
.\" segment_manager: Class template segment_manager
.\" Class template segment_manager: segment_manager
.\" reserve_unique_objects: Class template segment_manager
.\" Class template segment_manager: reserve_unique_objects
.\" reserve_named_objects: Class template segment_manager
.\" Class template segment_manager: reserve_named_objects
.\" mutex_family: Class template segment_manager
.\" Class template segment_manager: mutex_family
.\" memory_algorithm: Class template segment_manager
.\" Class template segment_manager: memory_algorithm
.\" get_num_unique_objects: Class template segment_manager
.\" Class template segment_manager: get_num_unique_objects
.\" get_num_named_objects: Class template segment_manager
.\" Class template segment_manager: get_num_named_objects
.\" get_min_size: Class template segment_manager
.\" Class template segment_manager: get_min_size
.\" get_instance_type: Class template segment_manager
.\" Class template segment_manager: get_instance_type
.\" get_instance_name: Class template segment_manager
.\" Class template segment_manager: get_instance_name
.\" get_instance_length: Class template segment_manager
.\" Class template segment_manager: get_instance_length
.\" get_deleter: Class template segment_manager
.\" Class template segment_manager: get_deleter
.\" get_allocator: Class template segment_manager
.\" Class template segment_manager: get_allocator
.\" find_or_construct_it: Class template segment_manager
.\" Class template segment_manager: find_or_construct_it
.\" find_or_construct: Class template segment_manager
.\" Class template segment_manager: find_or_construct
.\" find: Class template segment_manager
.\" Class template segment_manager: find
.\" difference_type: Class template segment_manager
.\" Class template segment_manager: difference_type
.\" destroy_ptr: Class template segment_manager
.\" Class template segment_manager: destroy_ptr
.\" destroy: Class template segment_manager
.\" Class template segment_manager: destroy
.\" deleter: Class template segment_manager
.\" Class template segment_manager: deleter
.\" construct_it: Class template segment_manager
.\" Class template segment_manager: construct_it
.\" construct: Class template segment_manager
.\" Class template segment_manager: construct
.\" const_unique_iterator: Class template segment_manager
.\" Class template segment_manager: const_unique_iterator
.\" const_named_iterator: Class template segment_manager
.\" Class template segment_manager: const_named_iterator
.\" char_type: Class template segment_manager
.\" Class template segment_manager: char_type
.\" atomic_func: Class template segment_manager
.\" Class template segment_manager: atomic_func
.\" allocator: Class template segment_manager
.\" Class template segment_manager: allocator

.sp
.nf
// In header: <boost/interprocess/segment_manager\&.hpp>

template<typename CharType, typename MemoryAlgorithm, 
         template< class IndexConfig > class IndexType> 
class segment_manager :
  public boost::interprocess::segment_manager_base< MemoryAlgorithm >
{
public:
  // types
  typedef MemoryAlgorithm                                                                 memory_algorithm;         
  typedef segment_manager_base_t::void_pointer                                            void_pointer;             
  typedef segment_manager_base_t::size_type                                               size_type;                
  typedef segment_manager_base_t::difference_type                                         difference_type;          
  typedef CharType                                                                        char_type;                
  typedef segment_manager_base< MemoryAlgorithm >                                         segment_manager_base_type;
  typedef segment_manager_base_t::mutex_family                                            mutex_family;             
  typedef transform_iterator< typename named_index_t::const_iterator, named_transform >   const_named_iterator;     
  typedef transform_iterator< typename unique_index_t::const_iterator, unique_transform > const_unique_iterator;    

  // member classes/structs/unions
  template<typename T> 
  struct allocator {
    // types
    typedef boost::interprocess::allocator< T, segment_manager > type;
  };
  template<typename T> 
  struct deleter {
    // types
    typedef boost::interprocess::deleter< T, segment_manager > type;
  };

  // construct/copy/destruct
  explicit segment_manager(size_type);

  // public member functions
  template<typename T> std::pair< T *, size_type > find(char_ptr_holder_t);
  template<typename T> 
    std::pair< T *, size_type > find_no_lock(char_ptr_holder_t);
  template<typename T> construct_proxy< T >::type construct(char_ptr_holder_t);
  template<typename T> 
    construct_proxy< T >::type find_or_construct(char_ptr_holder_t);
  template<typename T> 
    construct_proxy< T >::type 
    construct(char_ptr_holder_t, const std::nothrow_t &);
  template<typename T> 
    construct_proxy< T >::type 
    find_or_construct(char_ptr_holder_t, const std::nothrow_t &);
  template<typename T> 
    construct_iter_proxy< T >::type construct_it(char_ptr_holder_t);
  template<typename T> 
    construct_iter_proxy< T >::type find_or_construct_it(char_ptr_holder_t);
  template<typename T> 
    construct_iter_proxy< T >::type 
    construct_it(char_ptr_holder_t, const std::nothrow_t &);
  template<typename T> 
    construct_iter_proxy< T >::type 
    find_or_construct_it(char_ptr_holder_t, const std::nothrow_t &);
  template<typename Func> void atomic_func(Func &);
  template<typename Func> bool try_atomic_func(Func &);
  template<typename T> bool destroy(char_ptr_holder_t);
  template<typename T> void destroy_ptr(const T *);
  void reserve_named_objects(size_type);
  void reserve_unique_objects(size_type);
  void shrink_to_fit_indexes();
  size_type get_num_named_objects();
  size_type get_num_unique_objects();
  const_named_iterator named_begin() const;
  const_named_iterator named_end() const;
  const_unique_iterator unique_begin() const;
  const_unique_iterator unique_end() const;
  template<typename T> allocator< T >::type get_allocator();
  template<typename T> deleter< T >::type get_deleter();

  // public static functions
  template<typename T> static const CharType * get_instance_name(const T *);
  template<typename T> static size_type get_instance_length(const T *);
  template<typename T> static instance_type get_instance_type(const T *);
  static size_type get_min_size();

  // public data members
  static const size_type PayloadPerAllocation;
};
.fi
.SH "DESCRIPTION"
.PP
This object is placed in the beginning of memory segment and implements the allocation (named or anonymous) of portions of the segment\&. This object contains two indexes that maintain an association between a name and a portion of the segment\&.
.PP
The first index contains the mappings for normal named objects using the char type specified in the template parameter\&.
.PP
The second index contains the association for unique instances\&. The key will be the const char * returned from type_info\&.name() function for the unique type to be constructed\&.
.PP
segment_manager<CharType, MemoryAlgorithm, IndexType> inherits publicly from segment_manager_base<MemoryAlgorithm> and inherits from it many public functions related to anonymous object and raw memory allocation\&. See
segment_manager_base
reference to know about those functions\&.
.SS "segment_manager public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" segment_manager: Class template segment_manager
.\" Class template segment_manager: segment_manager

.sp

.nf
explicit segment_manager(size_type segment_size);
.fi

.sp
Constructor of the segment manager "size" is the size of the memory segment where the segment manager is being constructed\&. Can throw
.RE

.SS "segment_manager public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" find: Class template segment_manager
.\" Class template segment_manager: find

.sp

.nf
template<typename T> std::pair< T *, size_type > find(char_ptr_holder_t name);
.fi

.sp
Tries to find a previous named/unique allocation\&. Returns the address and the object count\&. On failure the first member of the returned pair is 0\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" atomic_func: Class template segment_manager
.\" Class template segment_manager: atomic_func

.sp

.nf
template<typename T> 
  std::pair< T *, size_type > find_no_lock(char_ptr_holder_t name);
.fi

.sp
Tries to find a previous named/unique allocation\&. Returns the address and the object count\&. On failure the first member of the returned pair is 0\&. This search is not mutex\-protected! Use it only inside atomic_func() calls, where the internal mutex is guaranteed to be locked\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" construct: Class template segment_manager
.\" Class template segment_manager: construct

.sp

.nf
template<typename T> 
  construct_proxy< T >::type construct(char_ptr_holder_t name);
.fi

.sp
Returns throwing "construct" proxy object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" find_or_construct: Class template segment_manager
.\" Class template segment_manager: find_or_construct

.sp

.nf
template<typename T> 
  construct_proxy< T >::type find_or_construct(char_ptr_holder_t name);
.fi

.sp
Returns throwing "search or construct" proxy object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" construct: Class template segment_manager
.\" Class template segment_manager: construct

.sp

.nf
template<typename T> 
  construct_proxy< T >::type 
  construct(char_ptr_holder_t name, const std::nothrow_t &);
.fi

.sp
Returns no throwing "construct" proxy object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" find_or_construct: Class template segment_manager
.\" Class template segment_manager: find_or_construct

.sp

.nf
template<typename T> 
  construct_proxy< T >::type 
  find_or_construct(char_ptr_holder_t name, const std::nothrow_t &);
.fi

.sp
Returns no throwing "search or construct" proxy object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" construct_it: Class template segment_manager
.\" Class template segment_manager: construct_it

.sp

.nf
template<typename T> 
  construct_iter_proxy< T >::type construct_it(char_ptr_holder_t name);
.fi

Returns throwing "construct from iterators" proxy object\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" find_or_construct_it: Class template segment_manager
.\" Class template segment_manager: find_or_construct_it

.sp

.nf
template<typename T> 
  construct_iter_proxy< T >::type find_or_construct_it(char_ptr_holder_t name);
.fi

.sp
Returns throwing "search or construct from iterators" proxy object
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" construct_it: Class template segment_manager
.\" Class template segment_manager: construct_it

.sp

.nf
template<typename T> 
  construct_iter_proxy< T >::type 
  construct_it(char_ptr_holder_t name, const std::nothrow_t &);
.fi

.sp
Returns no throwing "construct from iterators" proxy object
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" find_or_construct_it: Class template segment_manager
.\" Class template segment_manager: find_or_construct_it

.sp

.nf
template<typename T> 
  construct_iter_proxy< T >::type 
  find_or_construct_it(char_ptr_holder_t name, const std::nothrow_t &);
.fi

.sp
Returns no throwing "search or construct from iterators" proxy object
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" atomic_func: Class template segment_manager
.\" Class template segment_manager: atomic_func

.sp

.nf
template<typename Func> void atomic_func(Func & f);
.fi

.sp
Calls object function blocking recursive
interprocess_mutex
and guarantees that no new named_alloc or destroy will be executed by any process while executing the object function call
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" try_atomic_func: Class template segment_manager
.\" Class template segment_manager: try_atomic_func

.sp

.nf
template<typename Func> bool try_atomic_func(Func & f);
.fi

.sp
Tries to calls a functor guaranteeing that no new construction, search or destruction will be executed by any process while executing the object function call\&. If the atomic function can\'t be immediatelly executed because the internal mutex is already locked, returns false\&. If the functor throws, this function throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" destroy: Class template segment_manager
.\" Class template segment_manager: destroy

.sp

.nf
template<typename T> bool destroy(char_ptr_holder_t name);
.fi

.sp
Destroys a previously created named/unique instance\&. Returns false if the object was not present\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" destroy_ptr: Class template segment_manager
.\" Class template segment_manager: destroy_ptr

.sp

.nf
template<typename T> void destroy_ptr(const T * p);
.fi

.sp
Destroys an anonymous, unique or named object using its address
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" reserve_named_objects: Class template segment_manager
.\" Class template segment_manager: reserve_named_objects

.sp

.nf
void reserve_named_objects(size_type num);
.fi

.sp
Preallocates needed index resources to optimize the creation of "num" named objects in the managed memory segment\&. Can throw
boost::interprocess::bad_alloc
if there is no enough memory\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" reserve_unique_objects: Class template segment_manager
.\" Class template segment_manager: reserve_unique_objects

.sp

.nf
void reserve_unique_objects(size_type num);
.fi

.sp
Preallocates needed index resources to optimize the creation of "num" unique objects in the managed memory segment\&. Can throw
boost::interprocess::bad_alloc
if there is no enough memory\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" shrink_to_fit_indexes: Class template segment_manager
.\" Class template segment_manager: shrink_to_fit_indexes

.sp

.nf
void shrink_to_fit_indexes();
.fi

.sp
Calls shrink_to_fit in both named and unique object indexes to try to free unused memory from those indexes\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" get_num_named_objects: Class template segment_manager
.\" Class template segment_manager: get_num_named_objects

.sp

.nf
size_type get_num_named_objects();
.fi

.sp
Returns the number of named objects stored in the segment\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" get_num_unique_objects: Class template segment_manager
.\" Class template segment_manager: get_num_unique_objects

.sp

.nf
size_type get_num_unique_objects();
.fi

.sp
Returns the number of unique objects stored in the segment\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
const_named_iterator named_begin() const;
.fi

.sp
Returns a constant iterator to the beginning of the information about the named allocations performed in this segment manager
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
const_named_iterator named_end() const;
.fi

.sp
Returns a constant iterator to the end of the information about the named allocations performed in this segment manager
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
const_unique_iterator unique_begin() const;
.fi

.sp
Returns a constant iterator to the beginning of the information about the unique allocations performed in this segment manager
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
const_unique_iterator unique_end() const;
.fi

.sp
Returns a constant iterator to the end of the information about the unique allocations performed in this segment manager
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" get_allocator: Class template segment_manager
.\" Class template segment_manager: get_allocator

.sp

.nf
template<typename T> allocator< T >::type get_allocator();
.fi

.sp
Returns an instance of the default allocator for type T initialized that allocates memory from this segment manager\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" get_deleter: Class template segment_manager
.\" Class template segment_manager: get_deleter

.sp

.nf
template<typename T> deleter< T >::type get_deleter();
.fi

.sp
Returns an instance of the default deleter for type T that will delete an object constructed in this segment manager\&.
.RE

.SS "segment_manager public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" get_instance_name: Class template segment_manager
.\" Class template segment_manager: get_instance_name

.sp

.nf
template<typename T> static const CharType * get_instance_name(const T * ptr);
.fi

.sp
Returns the name of an object created with construct/find_or_construct functions\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get_instance_length: Class template segment_manager
.\" Class template segment_manager: get_instance_length

.sp

.nf
template<typename T> static size_type get_instance_length(const T * ptr);
.fi

.sp
Returns the length of an object created with construct/find_or_construct functions\&. Does not throw\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get_instance_type: Class template segment_manager
.\" Class template segment_manager: get_instance_type

.sp

.nf
template<typename T> static instance_type get_instance_type(const T * ptr);
.fi

.sp
Returns is the the name of an object created with construct/find_or_construct functions\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" get_min_size: Class template segment_manager
.\" Class template segment_manager: get_min_size

.sp

.nf
static size_type get_min_size();
.fi

.sp
Obtains the minimum size needed by the segment manager
.RE


