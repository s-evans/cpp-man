.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::interprocess::sharable_lock
.SH "SYNOPSIS"
.\" unlock: Class template sharable_lock
.\" Class template sharable_lock: unlock
.\" try_lock: Class template sharable_lock
.\" Class template sharable_lock: try_lock
.\" timed_lock: Class template sharable_lock
.\" Class template sharable_lock: timed_lock
.\" swap: Class template sharable_lock
.\" Class template sharable_lock: swap
.\" sharable_lock: Class template sharable_lock
.\" Class template sharable_lock: sharable_lock
.\" sharable_lock: Class template sharable_lock
.\" Class template sharable_lock: sharable_lock
.\" release: Class template sharable_lock
.\" Class template sharable_lock: release
.\" mutex_type: Class template sharable_lock
.\" Class template sharable_lock: mutex_type
.\" lock: Class template sharable_lock
.\" Class template sharable_lock: lock

.sp
.nf
// In header: <boost/interprocess/sync/sharable_lock\&.hpp>

template<typename SharableMutex> 
class sharable_lock {
public:
  // types
  typedef SharableMutex mutex_type;

  // construct/copy/destruct
  sharable_lock();
  explicit sharable_lock(mutex_type &);
  sharable_lock(mutex_type &, defer_lock_type);
  sharable_lock(mutex_type &, accept_ownership_type);
  sharable_lock(mutex_type &, try_to_lock_type);
  sharable_lock(mutex_type &, const boost::posix_time::ptime &);
  sharable_lock(sharable_lock< mutex_type > &&);
  template<typename T> sharable_lock(upgradable_lock< T > &&, \fIunspecified\fR = 0);
  template<typename T> sharable_lock(scoped_lock< T > &&, \fIunspecified\fR = 0);
  sharable_lock & operator=(sharable_lock< mutex_type > &&);
  ~sharable_lock();

  // public member functions
  void lock();
  bool try_lock();
  bool timed_lock(const boost::posix_time::ptime &);
  void unlock();
  bool owns() const;
  operator unspecified_bool_type() const;
  mutex_type * mutex() const;
  mutex_type * release();
  void swap(sharable_lock< mutex_type > &);
};
.fi
.SH "DESCRIPTION"
.PP
sharable_lock
is meant to carry out the tasks for sharable\-locking (such as read\-locking), unlocking, try\-sharable\-locking and timed\-sharable\-locking (recursive or not) for the Mutex\&. The Mutex need not supply all of this functionality\&. If the client of sharable_lock<Mutex> does not use functionality which the Mutex does not supply, no harm is done\&. Mutex ownership can be shared among sharable_locks, and a single
upgradable_lock\&.
sharable_lock
does not support copy semantics\&. But
sharable_lock
supports ownership transfer from an
sharable_lock,
upgradable_lock
and
scoped_lock
via transfer_lock syntax\&.
.SS "sharable_lock public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
sharable_lock();
.fi

.sp
Effects: Default constructs a
sharable_lock\&. Postconditions: owns() == false and mutex() == 0\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" sharable_lock: Class template sharable_lock
.\" Class template sharable_lock: sharable_lock

.sp

.nf
explicit sharable_lock(mutex_type & m);
.fi

.sp
Effects: m\&.lock_sharable()\&. Postconditions: owns() == true and mutex() == &m\&. Notes: The constructor will take sharable\-ownership of the mutex\&. If another thread already owns the mutex with exclusive ownership (scoped_lock), this thread will block until the mutex is released\&. If another thread owns the mutex with sharable or upgradable ownership, then no blocking will occur\&. Whether or not this constructor handles recursive locking depends upon the mutex\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
sharable_lock(mutex_type & m, defer_lock_type);
.fi

.sp
Postconditions: owns() == false, and mutex() == &m\&. Notes: The constructor will not take ownership of the mutex\&. There is no effect required on the referenced mutex\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
sharable_lock(mutex_type & m, accept_ownership_type);
.fi

.sp
Postconditions: owns() == true, and mutex() == &m\&. Notes: The constructor will suppose that the mutex is already sharable locked\&. There is no effect required on the referenced mutex\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
sharable_lock(mutex_type & m, try_to_lock_type);
.fi

.sp
Effects: m\&.try_lock_sharable() Postconditions: mutex() == &m\&. owns() == the return value of the m\&.try_lock_sharable() executed within the constructor\&. Notes: The constructor will take sharable\-ownership of the mutex if it can do so without waiting\&. Whether or not this constructor handles recursive locking depends upon the mutex\&. If the mutex_type does not support try_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
sharable_lock(mutex_type & m, const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: m\&.timed_lock_sharable(abs_time) Postconditions: mutex() == &m\&. owns() == the return value of the m\&.timed_lock_sharable() executed within the constructor\&. Notes: The constructor will take sharable\-ownership of the mutex if it can do so within the time specified\&. Whether or not this constructor handles recursive locking depends upon the mutex\&. If the mutex_type does not support timed_lock_sharable, this constructor will fail at compile time if instantiated, but otherwise have no effect\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
sharable_lock(sharable_lock< mutex_type > && upgr);
.fi

.sp
Postconditions: mutex() == upgr\&.mutex()\&. owns() == the value of upgr\&.owns() before the construction\&. upgr\&.owns() == false after the construction\&. Notes: If the upgr
sharable_lock
owns the mutex, ownership is moved to this
sharable_lock
with no blocking\&. If the upgr
sharable_lock
does not own the mutex, then neither will this
sharable_lock\&. Only a moved
sharable_lock\'s will match this signature\&. An non\-moved
sharable_lock
can be moved with the expression: "boost::move(lock);"\&. This constructor does not alter the state of the mutex, only potentially who owns it\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" unlock_upgradable_and_lock_sharable: Class template sharable_lock
.\" Class template sharable_lock: unlock_upgradable_and_lock_sharable
.\" sharable_lock: Class template sharable_lock
.\" Class template sharable_lock: sharable_lock

.sp

.nf
template<typename T> 
  sharable_lock(upgradable_lock< T > && upgr, \fIunspecified\fR = 0);
.fi

.sp
Effects: If upgr\&.owns() then calls unlock_upgradable_and_lock_sharable() on the referenced mutex\&. Postconditions: mutex() == the value upgr\&.mutex() had before the construction\&. upgr\&.mutex() == 0 owns() == the value of upgr\&.owns() before construction\&. upgr\&.owns() == false after the construction\&. Notes: If upgr is locked, this constructor will lock this
sharable_lock
while unlocking upgr\&. Only a moved
sharable_lock\'s will match this signature\&. An non\-moved
upgradable_lock
can be moved with the expression: "boost::move(lock);"\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" unlock_and_lock_sharable: Class template sharable_lock
.\" Class template sharable_lock: unlock_and_lock_sharable
.\" sharable_lock: Class template sharable_lock
.\" Class template sharable_lock: sharable_lock

.sp

.nf
template<typename T> sharable_lock(scoped_lock< T > && scop, \fIunspecified\fR = 0);
.fi

.sp
Effects: If scop\&.owns() then calls unlock_and_lock_sharable() on the referenced mutex\&. Postconditions: mutex() == the value scop\&.mutex() had before the construction\&. scop\&.mutex() == 0 owns() == scop\&.owns() before the constructor\&. After the construction, scop\&.owns() == false\&. Notes: If scop is locked, this constructor will transfer the exclusive ownership to a sharable\-ownership of this
sharable_lock\&. Only a moved
scoped_lock\'s will match this signature\&. An non\-moved
scoped_lock
can be moved with the expression: "boost::move(lock);"\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" unlock_sharable: Class template sharable_lock
.\" Class template sharable_lock: unlock_sharable

.sp

.nf
sharable_lock & operator=(sharable_lock< mutex_type > && upgr);
.fi

.sp
Effects: If owns() before the call, then unlock_sharable() is called on mutex()\&. *this gets the state of upgr and upgr gets set to a default constructed state\&. Notes: With a recursive mutex it is possible that both this and upgr own the mutex before the assignment\&. In this case, this will own the mutex after the assignment (and upgr will not), but the mutex\'s lock count will be decremented by one\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
~sharable_lock();
.fi

.sp
Effects: if (owns()) mp_mutex\->unlock_sharable()\&. Notes: The destructor behavior ensures that the mutex lock is not leaked\&.
.RE

.SS "sharable_lock public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" lock_sharable: Class template sharable_lock
.\" Class template sharable_lock: lock_sharable
.\" lock_exception: Class template sharable_lock
.\" Class template sharable_lock: lock_exception
.\" lock: Class template sharable_lock
.\" Class template sharable_lock: lock

.sp

.nf
void lock();
.fi

.sp
Effects: If mutex() == 0 or already locked, throws a lock_exception() exception\&. Calls lock_sharable() on the referenced mutex\&. Postconditions: owns() == true\&. Notes: The
sharable_lock
changes from a state of not owning the mutex, to owning the mutex, blocking if necessary\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" try_lock_sharable: Class template sharable_lock
.\" Class template sharable_lock: try_lock_sharable
.\" lock_exception: Class template sharable_lock
.\" Class template sharable_lock: lock_exception
.\" try_lock: Class template sharable_lock
.\" Class template sharable_lock: try_lock

.sp

.nf
bool try_lock();
.fi

.sp
Effects: If mutex() == 0 or already locked, throws a lock_exception() exception\&. Calls try_lock_sharable() on the referenced mutex\&. Postconditions: owns() == the value returned from mutex()\->try_lock_sharable()\&. Notes: The
sharable_lock
changes from a state of not owning the mutex, to owning the mutex, but only if blocking was not required\&. If the mutex_type does not support try_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" timed_lock_sharable: Class template sharable_lock
.\" Class template sharable_lock: timed_lock_sharable
.\" lock_exception: Class template sharable_lock
.\" Class template sharable_lock: lock_exception
.\" timed_lock: Class template sharable_lock
.\" Class template sharable_lock: timed_lock

.sp

.nf
bool timed_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: If mutex() == 0 or already locked, throws a lock_exception() exception\&. Calls timed_lock_sharable(abs_time) on the referenced mutex\&. Postconditions: owns() == the value returned from mutex()\->timed_lock_sharable(elps_time)\&. Notes: The
sharable_lock
changes from a state of not owning the mutex, to owning the mutex, but only if it can obtain ownership within the specified time interval\&. If the mutex_type does not support timed_lock_sharable(), this function will fail at compile time if instantiated, but otherwise have no effect\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" unlock_sharable: Class template sharable_lock
.\" Class template sharable_lock: unlock_sharable
.\" lock_exception: Class template sharable_lock
.\" Class template sharable_lock: lock_exception
.\" unlock: Class template sharable_lock
.\" Class template sharable_lock: unlock

.sp

.nf
void unlock();
.fi

.sp
Effects: If mutex() == 0 or not locked, throws a lock_exception() exception\&. Calls unlock_sharable() on the referenced mutex\&. Postconditions: owns() == false\&. Notes: The
sharable_lock
changes from a state of owning the mutex, to not owning the mutex\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool owns() const;
.fi

.sp
Effects: Returns true if this
scoped_lock
has acquired the referenced mutex\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
operator unspecified_bool_type() const;
.fi

.sp
Conversion to bool\&. Returns owns()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
mutex_type * mutex() const;
.fi

.sp
Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" release: Class template sharable_lock
.\" Class template sharable_lock: release

.sp

.nf
mutex_type * release();
.fi

.sp
Effects: Returns a pointer to the referenced mutex, or 0 if there is no mutex to reference\&. Postconditions: mutex() == 0 and owns() == false\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" swap: Class template sharable_lock
.\" Class template sharable_lock: swap

.sp

.nf
void swap(sharable_lock< mutex_type > & other);
.fi

.sp
Effects: Swaps state with moved lock\&. Throws: Nothing\&.
.RE


