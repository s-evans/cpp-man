.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS FILE_LOCK" 3 "" "" ""
.SH "NAME"
boost::interprocess::file_lock
.SH "SYNOPSIS"
.\" unlock_sharable: Class file_lock
.\" Class file_lock: unlock_sharable
.\" unlock: Class file_lock
.\" Class file_lock: unlock
.\" try_lock_sharable: Class file_lock
.\" Class file_lock: try_lock_sharable
.\" try_lock: Class file_lock
.\" Class file_lock: try_lock
.\" timed_lock_sharable: Class file_lock
.\" Class file_lock: timed_lock_sharable
.\" timed_lock: Class file_lock
.\" Class file_lock: timed_lock
.\" swap: Class file_lock
.\" Class file_lock: swap
.\" lock_sharable: Class file_lock
.\" Class file_lock: lock_sharable
.\" lock: Class file_lock
.\" Class file_lock: lock
.\" file_lock: Class file_lock
.\" Class file_lock: file_lock

.sp
.nf
// In header: <boost/interprocess/sync/file_lock\&.hpp>


class file_lock {
public:
  // construct/copy/destruct
  file_lock();
  file_lock(const char *);
  file_lock(file_lock &&);
  file_lock & operator=(file_lock &&);
  ~file_lock();

  // public member functions
  void swap(file_lock &);
  void lock();
  bool try_lock();
  bool timed_lock(const boost::posix_time::ptime &);
  void unlock();
  void lock_sharable();
  bool try_lock_sharable();
  bool timed_lock_sharable(const boost::posix_time::ptime &);
  void unlock_sharable();
};
.fi
.SH "DESCRIPTION"
.PP
A file lock, is a mutual exclusion utility similar to a mutex using a file\&. A file lock has sharable and exclusive locking capabilities and can be used with
scoped_lock
and
sharable_lock
classes\&. A file lock can\'t guarantee synchronization between threads of the same process so just use file locks to synchronize threads from different processes\&.
.SS "file_lock public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
file_lock();
.fi

.sp
Constructs an empty file mapping\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
file_lock(const char * name);
.fi

.sp
Opens a file lock\&. Throws
interprocess_exception
if the file does not exist or there are no operating system resources\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
file_lock(file_lock && moved);
.fi

.sp
Moves the ownership of "moved"\'s file mapping object to *this\&. After the call, "moved" does not represent any file mapping object\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
file_lock & operator=(file_lock && moved);
.fi

.sp
Moves the ownership of "moved"\'s file mapping to *this\&. After the call, "moved" does not represent any file mapping\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~file_lock();
.fi

Closes a file lock\&. Does not throw\&. .RE

.SS "file_lock public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" swap: Class file_lock
.\" Class file_lock: swap

.sp

.nf
void swap(file_lock & other);
.fi

.sp
Swaps two file_locks\&. Does not throw\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" lock: Class file_lock
.\" Class file_lock: lock

.sp

.nf
void lock();
.fi

.sp
Effects: The calling thread tries to obtain exclusive ownership of the mutex, and if another thread has exclusive, or sharable ownership of the mutex, it waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" try_lock: Class file_lock
.\" Class file_lock: try_lock

.sp

.nf
bool try_lock();
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex without waiting\&. If no other thread has exclusive, or sharable ownership of the mutex this succeeds\&. Returns: If it can acquire exclusive ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" timed_lock: Class file_lock
.\" Class file_lock: timed_lock

.sp

.nf
bool timed_lock(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire exclusive ownership of the mutex waiting if necessary until no other thread has exclusive, or sharable ownership of the mutex or abs_time is reached\&. Returns: If acquires exclusive ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" unlock: Class file_lock
.\" Class file_lock: unlock

.sp

.nf
void unlock();
.fi

.sp
Precondition: The thread must have exclusive ownership of the mutex\&. Effects: The calling thread releases the exclusive ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" lock_sharable: Class file_lock
.\" Class file_lock: lock_sharable

.sp

.nf
void lock_sharable();
.fi

.sp
Effects: The calling thread tries to obtain sharable ownership of the mutex, and if another thread has exclusive ownership of the mutex, waits until it can obtain the ownership\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" try_lock_sharable: Class file_lock
.\" Class file_lock: try_lock_sharable

.sp

.nf
bool try_lock_sharable();
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex without waiting\&. If no other thread has exclusive ownership of the mutex this succeeds\&. Returns: If it can acquire sharable ownership immediately returns true\&. If it has to wait, returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" timed_lock_sharable: Class file_lock
.\" Class file_lock: timed_lock_sharable

.sp

.nf
bool timed_lock_sharable(const boost::posix_time::ptime & abs_time);
.fi

.sp
Effects: The calling thread tries to acquire sharable ownership of the mutex waiting if necessary until no other thread has exclusive ownership of the mutex or abs_time is reached\&. Returns: If acquires sharable ownership, returns true\&. Otherwise returns false\&. Throws:
interprocess_exception
on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" unlock_sharable: Class file_lock
.\" Class file_lock: unlock_sharable

.sp

.nf
void unlock_sharable();
.fi

.sp
Precondition: The thread must have sharable ownership of the mutex\&. Effects: The calling thread releases the sharable ownership of the mutex\&. Throws: An exception derived from
interprocess_exception
on error\&.
.RE


