.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::log::sinks::asynchronous_sink \- Asynchronous logging sink frontend\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/sinks/async_frontend\&.hpp>

template<typename SinkBackendT, 
         typename QueueingStrategyT = unbounded_fifo_queue> 
class asynchronous_sink :
  public basic_sink_frontend, public QueueingStrategyT
{
public:
  // types
  typedef SinkBackendT           sink_backend_type;   // Sink implementation type\&. 
  typedef implementation_defined locked_backend_ptr;  // A pointer type that locks the backend until it\'s destroyed\&. 

  // member classes/structs/unions

  // A scope guard that resets a flag on destructor\&.

  class scoped_flag {
  public:
    // construct/copy/destruct
    explicit scoped_flag(frontend_mutex_type &, condition_variable_any &, 
                         volatile bool &);
    scoped_flag(scoped_flag const &);
    scoped_flag & operator=(scoped_flag const &);
    ~scoped_flag();
  };

  // A scope guard that implements thread ID management\&.

  class scoped_thread_id {
  public:
    // construct/copy/destruct
    scoped_thread_id(frontend_mutex_type &, condition_variable_any &, 
                     thread::id &, bool volatile &);
    scoped_thread_id(unique_lock< frontend_mutex_type > &, 
                     condition_variable_any &, thread::id &, bool volatile &);
    scoped_thread_id(scoped_thread_id const &);
    scoped_thread_id & operator=(scoped_thread_id const &);
    ~scoped_thread_id();
  };

  // construct/copy/destruct
  asynchronous_sink(bool = true);
  explicit asynchronous_sink(shared_ptr< sink_backend_type > const &, 
                             bool = true);
  ~asynchronous_sink();

  // public member functions
  locked_backend_ptr locked_backend();
  virtual void consume(record_view const &);
  virtual bool try_consume(record_view const &);
  void run();
  void stop();
  void feed_records();
  virtual void flush();
};
.fi
.SH "DESCRIPTION"
.PP
The frontend starts a separate thread on construction\&. All logging records are passed to the backend in this dedicated thread only\&.
.SS "asynchronous_sink public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
asynchronous_sink(bool start_thread = true);
.fi

.sp
Default constructor\&. Constructs the sink backend instance\&. Requires the backend to be default\-constructible\&.
.sp

.PP
Parameters:
.RS 4
.PP
start_thread
.RS 4
If
true, the frontend creates a thread to feed log records to the backend\&. Otherwise no thread is started and it is assumed that the user will call either
run
or
feed_records
himself\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit asynchronous_sink(shared_ptr< sink_backend_type > const & backend, 
                           bool start_thread = true);
.fi

.sp
Constructor attaches user\-constructed backend instance
.sp

.PP
Parameters:
.RS 4
.PP
backend
.RS 4
Pointer to the backend instance\&.
.RE
.PP
start_thread
.RS 4
If
true, the frontend creates a thread to feed log records to the backend\&. Otherwise no thread is started and it is assumed that the user will call either
run
or
feed_records
himself\&.
.RE
.RE
.PP
Requires:
.RS 4
\fIbackend\fR
is not
NULL\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
~asynchronous_sink();
.fi

.sp
Destructor\&. Implicitly stops the dedicated feeding thread, if one is running\&.
.RE

.SS "asynchronous_sink public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
locked_backend_ptr locked_backend();
.fi

.sp
Locking accessor to the attached backend
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
virtual void consume(record_view const & rec);
.fi

.sp
Enqueues the log record to the backend
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
virtual bool try_consume(record_view const & rec);
.fi

.sp
The method attempts to pass logging record to the backend
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void run();
.fi

.sp
The method starts record feeding loop and effectively blocks until either of this happens:
.sp

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the thread is interrupted due to either standard thread interruption or a call to
stop
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
an exception is thrown while processing a log record in the backend, and the exception is not terminated by the exception handler, if one is installed
.RE
.RS 4

.PP
Requires:
.RS 4
The sink frontend must be constructed without spawning a dedicated thread
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void stop();
.fi

.sp
The method softly interrupts record feeding loop\&. This method must be called when the
run
method execution has to be interrupted\&. Unlike regular thread interruption, calling
stop
will not interrupt the record processing in the middle\&. Instead, the sink frontend will attempt to finish its business with the record in progress and return afterwards\&. This method can be called either if the sink was created with a dedicated thread, or if the feeding loop was initiated by user\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Returning from this method does not guarantee that there are no records left buffered in the sink frontend\&. It is possible that log records keep coming during and after this method is called\&. At some point of execution of this method log records stop being processed, and all records that come after this point are put into the queue\&. These records will be processed upon further calls to
run
or
feed_records\&.
.sp .5v
.RE

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void feed_records();
.fi

.sp
The method feeds log records that may have been buffered to the backend and returns
.sp

.PP
Requires:
.RS 4
The sink frontend must be constructed without spawning a dedicated thread
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
virtual void flush();
.fi

.sp
The method feeds all log records that may have been buffered to the backend and returns\&. Unlike
feed_records, in case of ordering queueing the method also feeds records that were enqueued during the ordering window, attempting to empty the queue completely\&.
.sp

.PP
Requires:
.RS 4
The sink frontend must be constructed without spawning a dedicated thread
.RE
.RE


