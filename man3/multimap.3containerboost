.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE MU" 3 "" "" ""
.SH "NAME"
boost::container::multimap
.SH "SYNOPSIS"
.\" value_type: Class template multimap
.\" Class template multimap: value_type
.\" value_compare: Class template multimap
.\" Class template multimap: value_compare
.\" upper_bound: Class template multimap
.\" Class template multimap: upper_bound
.\" swap: Class template multimap
.\" Class template multimap: swap
.\" stored_allocator_type: Class template multimap
.\" Class template multimap: stored_allocator_type
.\" size_type: Class template multimap
.\" Class template multimap: size_type
.\" reverse_iterator: Class template multimap
.\" Class template multimap: reverse_iterator
.\" rend: Class template multimap
.\" Class template multimap: rend
.\" reference: Class template multimap
.\" Class template multimap: reference
.\" rebalance: Class template multimap
.\" Class template multimap: rebalance
.\" rbegin: Class template multimap
.\" Class template multimap: rbegin
.\" pointer: Class template multimap
.\" Class template multimap: pointer
.\" nonconst_value_type: Class template multimap
.\" Class template multimap: nonconst_value_type
.\" movable_value_type: Class template multimap
.\" Class template multimap: movable_value_type
.\" mapped_type: Class template multimap
.\" Class template multimap: mapped_type
.\" lower_bound: Class template multimap
.\" Class template multimap: lower_bound
.\" key_type: Class template multimap
.\" Class template multimap: key_type
.\" key_compare: Class template multimap
.\" Class template multimap: key_compare
.\" iterator: Class template multimap
.\" Class template multimap: iterator
.\" insert: Class template multimap
.\" Class template multimap: insert
.\" get_stored_allocator: Class template multimap
.\" Class template multimap: get_stored_allocator
.\" find: Class template multimap
.\" Class template multimap: find
.\" erase: Class template multimap
.\" Class template multimap: erase
.\" end: Class template multimap
.\" Class template multimap: end
.\" emplace: Class template multimap
.\" Class template multimap: emplace
.\" difference_type: Class template multimap
.\" Class template multimap: difference_type
.\" count: Class template multimap
.\" Class template multimap: count
.\" const_reverse_iterator: Class template multimap
.\" Class template multimap: const_reverse_iterator
.\" const_reference: Class template multimap
.\" Class template multimap: const_reference
.\" const_pointer: Class template multimap
.\" Class template multimap: const_pointer
.\" const_iterator: Class template multimap
.\" Class template multimap: const_iterator
.\" clear: Class template multimap
.\" Class template multimap: clear
.\" begin: Class template multimap
.\" Class template multimap: begin
.\" allocator_type: Class template multimap
.\" Class template multimap: allocator_type

.sp
.nf
// In header: <boost/container/map\&.hpp>

template<typename Key, typename T, typename Compare = std::less<Key>, 
         typename Allocator = new_allocator< std::pair< const Key, T> >, 
         typename MultiMapOptions = tree_assoc_defaults> 
class multimap {
public:
  // types
  typedef Key                                                              key_type;              
  typedef T                                                                mapped_type;           
  typedef std::pair< const Key, T >                                        value_type;            
  typedef boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                        allocator_type;        
  typedef implementation_defined                                           stored_allocator_type; 
  typedef implementation_defined                                           value_compare;         
  typedef Compare                                                          key_compare;           
  typedef implementation_defined                                           iterator;              
  typedef implementation_defined                                           const_iterator;        
  typedef implementation_defined                                           reverse_iterator;      
  typedef implementation_defined                                           const_reverse_iterator;
  typedef std::pair< key_type, mapped_type >                               nonconst_value_type;   
  typedef implementation_defined                                           movable_value_type;    

  // construct/copy/destruct
  multimap();
  explicit multimap(const Compare &, 
                    const allocator_type & = allocator_type());
  explicit multimap(const allocator_type &);
  template<typename InputIterator> 
    multimap(InputIterator, InputIterator, const Compare & = Compare(), 
             const allocator_type & = allocator_type());
  template<typename InputIterator> 
    multimap(InputIterator, InputIterator, const allocator_type &);
  template<typename InputIterator> 
    multimap(ordered_range_t, InputIterator, InputIterator, 
             const Compare & = Compare(), 
             const allocator_type & = allocator_type());
  multimap(std::initializer_list< value_type >, const Compare & = Compare(), 
           const allocator_type & = allocator_type());
  multimap(std::initializer_list< value_type >, const allocator_type &);
  multimap(ordered_range_t, std::initializer_list< value_type >, 
           const Compare & = Compare(), 
           const allocator_type & = allocator_type());
  multimap(const multimap &);
  multimap(multimap &&);
  multimap(const multimap &, const allocator_type &);
  multimap(multimap &&, const allocator_type &);
  multimap & operator=(const multimap &);
  multimap & operator=(multimap &&) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
  multimap & operator=(std::initializer_list< value_type >);

  // public member functions
  allocator_type get_allocator() const;
  stored_allocator_type & get_stored_allocator();
  const stored_allocator_type & get_stored_allocator() const;
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end() noexcept;
  const_iterator end() const noexcept;
  const_iterator cend() const noexcept;
  reverse_iterator rbegin() noexcept;
  const_reverse_iterator rbegin() const noexcept;
  const_reverse_iterator crbegin() const noexcept;
  reverse_iterator rend() noexcept;
  const_reverse_iterator rend() const noexcept;
  const_reverse_iterator crend() const noexcept;
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  template<class\&.\&.\&. Args> iterator emplace(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace_hint(const_iterator, Args &&\&.\&.\&.);
  iterator insert(const value_type &);
  iterator insert(const nonconst_value_type &);
  iterator insert(nonconst_value_type &&);
  iterator insert(movable_value_type &&);
  iterator insert(const_iterator, const value_type &);
  iterator insert(const_iterator, const nonconst_value_type &);
  iterator insert(const_iterator, nonconst_value_type &&);
  iterator insert(const_iterator, movable_value_type &&);
  template<typename InputIterator> void insert(InputIterator, InputIterator);
  void insert(std::initializer_list< value_type >);
  iterator erase(const_iterator);
  size_type erase(const key_type &);
  iterator erase(const_iterator, const_iterator);
  void swap(multiset &) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
  void clear() noexcept;
  key_compare key_comp() const;
  value_compare value_comp() const;
  iterator find(const key_type &);
  const_iterator find(const key_type &) const;
  size_type count(const key_type &) const;
  iterator lower_bound(const key_type &);
  const_iterator lower_bound(const key_type &) const;
  iterator upper_bound(const key_type &);
  const_iterator upper_bound(const key_type &) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  void rebalance();

  // friend functions
  friend bool operator==(const multimap &, const multimap &);
  friend bool operator!=(const multimap &, const multimap &);
  friend bool operator<(const multimap &, const multimap &);
  friend bool operator>(const multimap &, const multimap &);
  friend bool operator<=(const multimap &, const multimap &);
  friend bool operator>=(const multimap &, const multimap &);
  friend void swap(multimap &, multimap &);
};
.fi
.SH "DESCRIPTION"
.PP
A multimap is a kind of associative container that supports equivalent keys (possibly containing multiple copies of the same key value) and provides for fast retrieval of values of another type T based on the keys\&. The multimap class supports bidirectional iterators\&.
.PP
A multimap satisfies all of the requirements of a container and of a reversible container and of an associative container\&. The
value_type
stored by this container is the value_type is std::pair<const Key, T>\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Key
.fi

.sp
is the key_type of the map
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename T
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Compare = std::less<Key>
.fi

.sp
is the ordering function for Keys (e\&.g\&. \fIstd::less<Key>\fR)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator< std::pair< const Key, T> >
.fi

.sp
is the allocator to allocate the value_types (e\&.g\&. \fIallocator< std::pair<const Key, T> > \fR)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
typename MultiMapOptions = tree_assoc_defaults
.fi

.sp
is an packed option type generated using using boost::container::tree_assoc_options\&.
.RE

.SS "multimap public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
multimap();
.fi

.sp
\fBEffects\fR: Default constructs an empty multimap\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit multimap(const Compare & comp, 
                  const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty multimap using the specified allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit multimap(const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty multimap using the specified comparison object and allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  multimap(InputIterator first, InputIterator last, 
           const Compare & comp = Compare(), 
           const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  multimap(InputIterator first, InputIterator last, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty multimap using the specified allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  multimap(ordered_range_t, InputIterator first, InputIterator last, 
           const Compare & comp = Compare(), 
           const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements from the ordered range [first ,last)\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [first ,last) must be ordered according to the predicate\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
multimap(std::initializer_list< value_type > il, 
         const Compare & comp = Compare(), 
         const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty multimap using the specified comparison object and allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is il\&.first() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
multimap(std::initializer_list< value_type > il, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty multimap using the specified allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is il\&.first() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
multimap(ordered_range_t, std::initializer_list< value_type > il, 
         const Compare & comp = Compare(), 
         const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the ordered range [il\&.begin(), il\&.end())\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [il\&.begin(), il\&.end()) must be ordered according to the predicate\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
multimap(const multimap & x);
.fi

.sp
\fBEffects\fR: Copy constructs a multimap\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
multimap(multimap && x);
.fi

.sp
\fBEffects\fR: Move constructs a multimap\&. Constructs *this using x\'s resources\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBPostcondition\fR: x is emptied\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
multimap(const multimap & x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a multimap\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
multimap(multimap && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructs a multimap using the specified allocator\&. Constructs *this using x\'s resources\&.
\fBComplexity\fR: Constant if a == x\&.get_allocator(), linear otherwise\&.
.sp
\fBPostcondition\fR: x is emptied\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
multimap & operator=(const multimap & x);
.fi

.sp
\fBEffects\fR: Makes *this a copy of x\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
multimap & operator=(multimap && x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
.fi

.sp
\fBEffects\fR: this\->swap(x\&.get())\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
multimap & operator=(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: Assign content of il to *this\&.
.RE

.SS "multimap public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const;
.fi

.sp
\fBEffects\fR: Returns a copy of the allocator that was passed to the object\'s constructor\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get_stored_allocator: Class template multimap
.\" Class template multimap: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator();
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get_stored_allocator: Class template multimap
.\" Class template multimap: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" begin: Class template multimap
.\" Class template multimap: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" begin: Class template multimap
.\" Class template multimap: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" end: Class template multimap
.\" Class template multimap: end

.sp

.nf
iterator end() noexcept;
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" end: Class template multimap
.\" Class template multimap: end

.sp

.nf
const_iterator end() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_iterator cend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rbegin: Class template multimap
.\" Class template multimap: rbegin

.sp

.nf
reverse_iterator rbegin() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rbegin: Class template multimap
.\" Class template multimap: rbegin

.sp

.nf
const_reverse_iterator rbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rend: Class template multimap
.\" Class template multimap: rend

.sp

.nf
reverse_iterator rend() noexcept;
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template multimap
.\" Class template multimap: rend

.sp

.nf
const_reverse_iterator rend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const noexcept;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
size_type max_size() const;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" emplace: Class template multimap
.\" Class template multimap: emplace

.sp

.nf
template<class\&.\&.\&. Args> iterator emplace(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> 
  iterator emplace_hint(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type T constructed with std::forward<Args>(args)\&.\&.\&. in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts x and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(const nonconst_value_type & x);
.fi

.sp
\fBEffects\fR: Inserts a new value constructed from x and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(nonconst_value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value move\-constructed from x and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(movable_value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value move\-constructed from x and returns the iterator pointing to the newly inserted element\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(const_iterator p, const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(const_iterator p, const nonconst_value_type & x);
.fi

.sp
\fBEffects\fR: Inserts a new value constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(const_iterator p, nonconst_value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value move constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
iterator insert(const_iterator p, movable_value_type && x);
.fi

.sp
\fBEffects\fR: Inserts a new value move constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
template<typename InputIterator> 
  void insert(InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: first, last are not iterators into *this\&.
.sp
\fBEffects\fR: inserts each element from the range [first,last) \&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" insert: Class template multimap
.\" Class template multimap: insert

.sp

.nf
void insert(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: inserts each element from the range [il\&.begin(), il\&.end()\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from il\&.begin() to il\&.end())
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" end: Class template multimap
.\" Class template multimap: end
.\" erase: Class template multimap
.\" Class template multimap: erase

.sp

.nf
iterator erase(const_iterator p);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by p\&.
.sp
\fBReturns\fR: Returns an iterator pointing to the element immediately following q prior to the element being erased\&. If no such element exists, returns end()\&.
.sp
\fBComplexity\fR: Amortized constant time
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" erase: Class template multimap
.\" Class template multimap: erase

.sp

.nf
size_type erase(const key_type & x);
.fi

.sp
\fBEffects\fR: Erases all elements in the container with key equivalent to x\&.
.sp
\fBReturns\fR: Returns the number of erased elements\&.
.sp
\fBComplexity\fR: log(size()) + count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" erase: Class template multimap
.\" Class template multimap: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

.sp
\fBEffects\fR: Erases all the elements in the range [first, last)\&.
.sp
\fBReturns\fR: Returns last\&.
.sp
\fBComplexity\fR: log(size())+N where N is the distance from first to last\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" swap: Class template multimap
.\" Class template multimap: swap

.sp

.nf
void swap(multiset & x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" clear: Class template multimap
.\" Class template multimap: clear

.sp

.nf
void clear() noexcept;
.fi

.sp
\fBEffects\fR: erase(a\&.begin(),a\&.end())\&.
.sp
\fBPostcondition\fR: size() == 0\&.
.sp
\fBComplexity\fR: linear in size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the comparison object out of which a was constructed\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns an object of value_compare constructed out of the comparison object\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" end: Class template multimap
.\" Class template multimap: end
.\" find: Class template multimap
.\" Class template multimap: find

.sp

.nf
iterator find(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" end: Class template multimap
.\" Class template multimap: end
.\" find: Class template multimap
.\" Class template multimap: find

.sp

.nf
const_iterator find(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" count: Class template multimap
.\" Class template multimap: count

.sp

.nf
size_type count(const key_type & x) const;
.fi

.sp
\fBReturns\fR: The number of elements with key equivalent to x\&.
.sp
\fBComplexity\fR: log(size())+count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" lower_bound: Class template multimap
.\" Class template multimap: lower_bound

.sp

.nf
iterator lower_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" lower_bound: Class template multimap
.\" Class template multimap: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" end: Class template multimap
.\" Class template multimap: end
.\" upper_bound: Class template multimap
.\" Class template multimap: upper_bound

.sp

.nf
iterator upper_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" end: Class template multimap
.\" Class template multimap: end
.\" upper_bound: Class template multimap
.\" Class template multimap: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & x);
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & x) const;
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" rebalance: Class template multimap
.\" Class template multimap: rebalance

.sp

.nf
void rebalance();
.fi

.sp
\fBEffects\fR: Rebalances the tree\&. It\'s a no\-op for Red\-Black and AVL trees\&.
.sp
\fBComplexity\fR: Linear
.RE

.SS "multimap friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const multimap & x, const multimap & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const multimap & x, const multimap & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const multimap & x, const multimap & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const multimap & x, const multimap & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const multimap & x, const multimap & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const multimap & x, const multimap & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template multimap
.\" Class template multimap: swap

.sp

.nf
friend void swap(multimap & x, multimap & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


