.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST_SCO" 3 "" "" ""
.SH "NAME"
BOOST_SCOPE_EXIT_ALL \- This macro declares a scope exit that captures all variables in scope (C++11 only)\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/scope_exit\&.hpp>

BOOST_SCOPE_EXIT_ALL(capture_list)
.fi
.SH "DESCRIPTION"
.PP
This macro accepts a capture list starting with either
&
or
=
to capture all variables in scope by reference or value respectively (following the same syntax of C++11 lambdas)\&. A part from that, this macro works like
BOOST_SCOPE_EXIT
(see
BOOST_SCOPE_EXIT
for more information):
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
{ // Some local scope\&.
    \&.\&.\&.
    BOOST_SCOPE_EXIT_ALL(capture_list) { // C++11 only\&.
        \&.\&.\&. // Body code\&.
    }; // Use `;` instead of `BOOST_SCOPE_EXIT_END` (C++11 only)\&.
    \&.\&.\&.
}

.fi
.if n \{\
.RE
.\}

.PP
Note how the end of the scope exit body declared by this macro must be marked by a semi\-column
;
(and not by
BOOST_SCOPE_EXIT_END)\&.
.PP
\fBWarning:\fR
This macro is only available on C++11 compilers (specifically, on C++11 compilers that do not define the Boost\&.Config
BOOST_NO_CXX11_LAMBDAS
macro)\&. It is not defined on non\-C++11 compilers so its use on non\-C++11 compilers will generate a compiler error\&.
.PP
\fBParameters:\fR
.TS
allbox tab(:);
l l.
T{
\fBcapture_list\fR
T}:T{
On compilers that support variadic macros (see also Boost\&.Config BOOST_NO_CXX11_VARIADIC_MACROS), the capture list syntax is defined by the following grammar: .if n \{\
.RS 4
.\}
.nf
capture_list:
        capture_tuple | capture_sequence
capture_tuple:
        {& | =} [, capture, capture, \&.\&.\&.]
capture_sequence:
        {(&) | (=)} [(capture) (capture) \&.\&.\&.]
capture:
        [&]variable | this_

.fi
.if n \{\
.RE
.\}
.sp
 On compilers that do not support variadic macros, capture_tuple cannot be used: .if n \{\
.RS 4
.\}
.nf
capture_list:
        void | capture_sequence

.fi
.if n \{\
.RE
.\}
.sp
 Furthermore, on C++11 compilers that support the use of typename outside templates, also this can be used to capture the object at member function scope: .if n \{\
.RS 4
.\}
.nf
capture:
        [&]variable | this_ | this

.fi
.if n \{\
.RE
.\}
.sp
(Lexical conventions: token1 | token2 means either token1 or token2; [token] means either token or nothing; {expression} means the token resulting from the expression\&.)
T}
.TE
.sp 1

.PP
Note that on compilers with variadic macro support (which should be all C++11 compilers), the capture list can be specified as a comma\-separated list\&. On all compilers, the same macro
BOOST_SCOPE_EXIT_ALL
also allows to specify the capture list as a Boost\&.Preprocessor sequence\&.
.PP
The capture list must always contain at least the leading
&
or
=
so it can never be
void
(BOOST_SCOPE_EXIT(void)
should be used to program scope exits with an empty capture list)\&.
.PP
In general, the special macro
BOOST_SCOPE_EXIT_ALL_ID
must be used instead of
BOOST_SCOPE_EXIT_ALL
when it is necessary to expand multiple scope exit declarations on the same line\&.
.PP
\fBWarning:\fR
This macro capture list follows the exact same syntax of C++11 lambda captures which is unfortunately different from the syntax of
BOOST_SCOPE_EXIT
captures (unless programmers define the
BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS
macro)\&. For example, like C++11 lambda functions,
BOOST_SCOPE_EXIT_ALL
requires to capture data members by capturing the object
this
while
BOOST_SCOPE_EXIT
allows to capture data members directly and without capturing the object\&.
.PP
\fBWarning:\fR
The implementation executes the scope exit body within a destructor thus the scope exit body must never throw in order to comply with STL exception safety requirements\&.
.PP
\fBNote:\fR
This macro can always be used also within templates (so there is no need for a
BOOST_SCOPE_EXIT_ALL_TPL
macro)\&.
.PP
\fBSee:\fR
Tutorial
section,
No Variadic Macros
section,
BOOST_SCOPE_EXIT,
BOOST_SCOPE_EXIT_ALL_ID\&.

