.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE P" 3 "" "" ""
.SH "NAME"
boost::proto::protect \- A PrimitiveTransform which prevents another PrimitiveTransform from being applied in an ObjectTransform\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/transform/make\&.hpp>

template<typename PrimitiveTransform> 
struct protect :  proto::transform< protect<PrimitiveTransform> > {
  // member classes/structs/unions
  template<typename , typename , typename > 
  struct impl {
    // types
    typedef PrimitiveTransform result_type;
  };
};
.fi
.SH "DESCRIPTION"
.PP
When building higher order transforms with
proto::make<>
or
proto::lazy<>, you sometimes would like to build types that are parameterized with Proto transforms\&. In such lambda\-style transforms, Proto will unhelpfully find all nested transforms and apply them, even if you don\'t want them to be applied\&. Consider the following transform, which will replace the
proto::_
in
Bar<proto::_>()
with
proto::terminal<int>::type:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
template<typename T>
struct Bar
{};

struct Foo :
  proto::when<proto::_, Bar<proto::_>() >
{};

proto::terminal<int>::type i = {0};

int main() {
  Foo()(i);
  std::cout << typeid(Foo()(i))\&.name() << std::endl;
}
.fi
.if n \{\
.RE
.\}
.sp

.PP
If you actually wanted to default\-construct an object of type
Bar<proto::_>, you would have to protect the
_
to prevent it from being applied\&. You can use
proto::protect<>
as follows:
.PP


.sp
.if n \{\
.RS 4
.\}
.nf
// OK: replace anything with Bar<_>()
struct Foo :
  proto::when<proto::_, Bar<proto::protect<proto::_> >() >
{};
.fi
.if n \{\
.RE
.\}
.sp


