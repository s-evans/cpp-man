.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::interprocess::intrusive_ptr
.SH "SYNOPSIS"
.\" swap: Class template intrusive_ptr
.\" Class template intrusive_ptr: swap
.\" pointer: Class template intrusive_ptr
.\" Class template intrusive_ptr: pointer
.\" intrusive_ptr: Class template intrusive_ptr
.\" Class template intrusive_ptr: intrusive_ptr
.\" get: Class template intrusive_ptr
.\" Class template intrusive_ptr: get
.\" element_type: Class template intrusive_ptr
.\" Class template intrusive_ptr: element_type

.sp
.nf
// In header: <boost/interprocess/smart_ptr/intrusive_ptr\&.hpp>

template<typename T, typename VoidPointer> 
class intrusive_ptr {
public:
  // types
  typedef boost::intrusive::pointer_traits< VoidPointer >::template rebind_pointer< T >::type pointer;       // Provides the type of the internal stored pointer\&. 
  typedef T                                                                                   element_type;  // Provides the type of the stored pointer\&. 

  // construct/copy/destruct
  intrusive_ptr();
  intrusive_ptr(const pointer &, bool = true);
  intrusive_ptr(intrusive_ptr const &);
  template<typename U> intrusive_ptr(intrusive_ptr< U, VP > const &);
  intrusive_ptr & operator=(intrusive_ptr const &);
  template<typename U> 
    intrusive_ptr & operator=(intrusive_ptr< U, VP > const &);
  intrusive_ptr & operator=(pointer);
  ~intrusive_ptr();

  // public member functions
  pointer & get();
  const pointer & get() const;
  T & operator*() const;
  const pointer & operator\->() const;
  pointer & operator\->();
  operator unspecified_bool_type() const;
  bool operator!() const;
  void swap(intrusive_ptr &);
};
.fi
.SH "DESCRIPTION"
.\" intrusive_ptr_release: Class template intrusive_ptr
.\" Class template intrusive_ptr: intrusive_ptr_release
.\" intrusive_ptr_add_ref: Class template intrusive_ptr
.\" Class template intrusive_ptr: intrusive_ptr_add_ref
.PP
The
intrusive_ptr
class template stores a pointer to an object with an embedded reference count\&.
intrusive_ptr
is parameterized on T (the type of the object pointed to) and VoidPointer(a void pointer type that defines the type of pointer that
intrusive_ptr
will store)\&. intrusive_ptr<T, void *> defines a class with a T* member whereas
intrusive_ptr<T, offset_ptr<void> > defines a class with a offset_ptr<T> member\&. Relies on unqualified calls to:
.PP
void intrusive_ptr_add_ref(T * p); void intrusive_ptr_release(T * p);
.PP
with (p != 0)
.PP
The object is responsible for destroying itself\&.
.SS "intrusive_ptr public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
intrusive_ptr();
.fi

.sp
Constructor\&. Initializes internal pointer to 0\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" intrusive_ptr_add_ref: Class template intrusive_ptr
.\" Class template intrusive_ptr: intrusive_ptr_add_ref

.sp

.nf
intrusive_ptr(const pointer & p, bool add_ref = true);
.fi

.sp
Constructor\&. Copies pointer and if "p" is not zero and "add_ref" is true calls intrusive_ptr_add_ref(to_raw_pointer(p))\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" intrusive_ptr_add_ref: Class template intrusive_ptr
.\" Class template intrusive_ptr: intrusive_ptr_add_ref

.sp

.nf
intrusive_ptr(intrusive_ptr const & rhs);
.fi

.sp
Copy constructor\&. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(to_raw_pointer(p))\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" intrusive_ptr_add_ref: Class template intrusive_ptr
.\" Class template intrusive_ptr: intrusive_ptr_add_ref

.sp

.nf
template<typename U> intrusive_ptr(intrusive_ptr< U, VP > const & rhs);
.fi

.sp
Constructor from related\&. Copies the internal pointer and if "p" is not zero calls intrusive_ptr_add_ref(to_raw_pointer(p))\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
intrusive_ptr & operator=(intrusive_ptr const & rhs);
.fi

.sp
Assignment operator\&. Equivalent to intrusive_ptr(r)\&.swap(*this)\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename U> 
  intrusive_ptr & operator=(intrusive_ptr< U, VP > const & rhs);
.fi

.sp
Assignment from related\&. Equivalent to intrusive_ptr(r)\&.swap(*this)\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
intrusive_ptr & operator=(pointer rhs);
.fi

.sp
Assignment from pointer\&. Equivalent to intrusive_ptr(r)\&.swap(*this)\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" intrusive_ptr_release: Class template intrusive_ptr
.\" Class template intrusive_ptr: intrusive_ptr_release

.sp

.nf
~intrusive_ptr();
.fi

.sp
Destructor\&. If internal pointer is not 0, calls intrusive_ptr_release(to_raw_pointer(m_ptr))\&. Does not throw
.RE

.SS "intrusive_ptr public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" get: Class template intrusive_ptr
.\" Class template intrusive_ptr: get

.sp

.nf
pointer & get();
.fi

.sp
Returns a reference to the internal pointer\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get: Class template intrusive_ptr
.\" Class template intrusive_ptr: get

.sp

.nf
const pointer & get() const;
.fi

.sp
Returns a reference to the internal pointer\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get: Class template intrusive_ptr
.\" Class template intrusive_ptr: get

.sp

.nf
T & operator*() const;
.fi

.sp
Returns *get()\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" get: Class template intrusive_ptr
.\" Class template intrusive_ptr: get

.sp

.nf
const pointer & operator\->() const;
.fi

.sp
Returns *get()\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" get: Class template intrusive_ptr
.\" Class template intrusive_ptr: get

.sp

.nf
pointer & operator\->();
.fi

.sp
Returns get()\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
operator unspecified_bool_type() const;
.fi

.sp
Conversion to boolean\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool operator!() const;
.fi

.sp
Not operator\&. Does not throw
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" swap: Class template intrusive_ptr
.\" Class template intrusive_ptr: swap

.sp

.nf
void swap(intrusive_ptr & rhs);
.fi

.sp
Exchanges the contents of the two smart pointers\&. Does not throw
.RE


