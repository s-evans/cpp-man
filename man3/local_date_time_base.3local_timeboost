.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPL" 3 "" "" ""
.SH "NAME"
boost::local_time::local_date_time_base \- Representation of "wall\-clock" time in a particular time zone\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/local_time/local_date_time\&.hpp>

template<typename utc_time_ = posix_time::ptime, 
         typename tz_type = date_time::time_zone_base<utc_time_,char> > 
class local_date_time_base : public date_time::base_time< utc_time_, boost::posix_time::posix_time_system >
{
public:
  // types
  typedef utc_time_                         utc_time_type;     
  typedef utc_time_type::time_duration_type time_duration_type;
  typedef utc_time_type::date_type          date_type;         
  typedef date_type::duration_type          date_duration_type;
  typedef utc_time_type::time_system_type   time_system_type;  

  enum DST_CALC_OPTIONS { EXCEPTION_ON_ERROR, NOT_DATE_TIME_ON_ERROR };

  // construct/copy/destruct
  local_date_time_base(utc_time_type, boost::shared_ptr< tz_type >);
  local_date_time_base(date_type, time_duration_type, 
                       boost::shared_ptr< tz_type >, bool);
  local_date_time_base(date_type, time_duration_type, 
                       boost::shared_ptr< tz_type >, DST_CALC_OPTIONS);
  local_date_time_base(const local_date_time_base &);
  explicit local_date_time_base(const boost::date_time::special_values, 
                                boost::shared_ptr< tz_type > = boost::shared_ptr< tz_type >());
  ~local_date_time_base();

  // public member functions
  boost::shared_ptr< tz_type > zone() const;
  bool is_dst() const;
  utc_time_type utc_time() const;
  utc_time_type local_time() const;
  std::string to_string() const;
  local_date_time_base 
  local_time_in(boost::shared_ptr< tz_type >, 
                time_duration_type = time_duration_type(0, 0, 0)) const;
  std::string zone_name(bool = false) const;
  std::string zone_abbrev(bool = false) const;
  std::string zone_as_posix_string() const;
  bool operator==(const local_date_time_base &) const;
  bool operator!=(const local_date_time_base &) const;
  bool operator<(const local_date_time_base &) const;
  bool operator<=(const local_date_time_base &) const;
  bool operator>(const local_date_time_base &) const;
  bool operator>=(const local_date_time_base &) const;
  local_date_time_base operator+(const date_duration_type &) const;
  local_date_time_base operator+=(const date_duration_type &);
  local_date_time_base operator\-(const date_duration_type &) const;
  local_date_time_base operator\-=(const date_duration_type &);
  local_date_time_base operator+(const time_duration_type &) const;
  local_date_time_base operator+=(const time_duration_type &);
  local_date_time_base operator\-(const time_duration_type &) const;
  local_date_time_base operator\-=(const time_duration_type &);
  time_duration_type operator\-(const local_date_time_base &) const;

  // public static functions
  static time_is_dst_result 
  check_dst(date_type, time_duration_type, boost::shared_ptr< tz_type >);

  // private member functions
  utc_time_type 
  construction_adjustment(utc_time_type, boost::shared_ptr< tz_type >, bool);
  std::string zone_as_offset(const time_duration_type &, const std::string &) const;
};
.fi
.SH "DESCRIPTION"
.PP
Representation of "wall\-clock" time in a particular time zone Local_date_time_base holds a time value (date and time offset from 00:00) along with a time zone\&. The time value is stored as UTC and conversions to wall clock time are made as needed\&. This approach allows for operations between wall\-clock times in different time zones, and daylight savings time considerations, to be made\&. Time zones are required to be in the form of a boost::shared_ptr<time_zone_base>\&.
.SS "local_date_time_base public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
local_date_time_base(utc_time_type t, boost::shared_ptr< tz_type > tz);
.fi

.sp
This constructor interprets the passed time as a UTC time\&. So, for example, if the passed timezone is UTC\-5 then the time will be adjusted back 5 hours\&. The time zone allows for automatic calculation of whether the particular time is adjusted for daylight savings, etc\&. If the time zone shared pointer is null then time stays unadjusted\&.
.PP
Parameters:
.RS 4
.PP
t
.RS 4
A UTC time
.RE
.PP
tz
.RS 4
Timezone for to adjust the UTC time to\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
local_date_time_base(date_type d, time_duration_type td, 
                     boost::shared_ptr< tz_type > tz, bool dst_flag);
.fi

.sp
This constructs a local time
<ndash></ndash>
the passed time information understood to be in the passed tz\&. The DST flag must be passed to indicate whether the time is in daylight savings or not\&.
.PP
Throws:
.RS 4
&ndash;
time_label_invalid
if the time passed does not exist in the given locale\&. The non\-existent case occurs typically during the shift\-back from daylight savings time\&. When the clock is shifted forward a range of times (2 am to 3 am in the US) is skipped and hence is invalid\&.
dst_not_valid
if the DST flag is passed for a period where DST is not active\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
local_date_time_base(date_type d, time_duration_type td, 
                     boost::shared_ptr< tz_type > tz, 
                     DST_CALC_OPTIONS calc_option);
.fi

.sp
This constructs a local time
<ndash></ndash>
the passed time information understood to be in the passed tz\&. The DST flag is calculated according to the specified rule\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
local_date_time_base(const local_date_time_base & rhs);
.fi

Copy constructor\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
explicit local_date_time_base(const boost::date_time::special_values sv, 
                              boost::shared_ptr< tz_type > tz = boost::shared_ptr< tz_type >());
.fi

Special values constructor\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
~local_date_time_base();
.fi

Simple destructor, releases time zone if last referrer\&. .RE

.SS "local_date_time_base public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
boost::shared_ptr< tz_type > zone() const;
.fi

returns time zone associated with calling instance .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool is_dst() const;
.fi

returns false is time_zone is NULL and if time value is a special_value .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
utc_time_type utc_time() const;
.fi

Returns object\'s time value as a utc representation\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
utc_time_type local_time() const;
.fi

Returns object\'s time value as a local representation\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
std::string to_string() const;
.fi

.sp
Returns string in the form "2003\-Aug\-20 05:00:00 EDT"\&. Returns string in the form "2003\-Aug\-20 05:00:00 EDT"\&. If time_zone is NULL the time zone abbreviation will be "UTC"\&. The time zone abbrev will not be included if calling object is a special_value
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
local_date_time_base 
local_time_in(boost::shared_ptr< tz_type > new_tz, 
              time_duration_type td = time_duration_type(0, 0, 0)) const;
.fi

.sp
returns a
local_date_time_base
in the given time zone with the optional time_duration added\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
std::string zone_name(bool as_offset = false) const;
.fi

.sp
Returns name of associated time zone or "Coordinated Universal Time"\&. Optional bool parameter will return time zone as an offset (ie "+07:00" extended iso format)\&. Empty string is returned for classes that do not use a time_zone
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
std::string zone_abbrev(bool as_offset = false) const;
.fi

.sp
Returns abbreviation of associated time zone or "UTC"\&. Optional bool parameter will return time zone as an offset (ie "+0700" iso format)\&. Empty string is returned for classes that do not use a time_zone
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
std::string zone_as_posix_string() const;
.fi

returns a posix_time_zone string for the associated time_zone\&. If no time_zone, "UTC+00" is returned\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool operator==(const local_date_time_base & rhs) const;
.fi

.sp
Equality comparison operator\&. Equality comparison operator
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
bool operator!=(const local_date_time_base & rhs) const;
.fi

Non\-Equality comparison operator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool operator<(const local_date_time_base & rhs) const;
.fi

Less than comparison operator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
bool operator<=(const local_date_time_base & rhs) const;
.fi

Less than or equal to comparison operator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
bool operator>(const local_date_time_base & rhs) const;
.fi

Greater than comparison operator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
bool operator>=(const local_date_time_base & rhs) const;
.fi

Greater than or equal to comparison operator\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
local_date_time_base operator+(const date_duration_type & dd) const;
.fi

Local_date_time + date_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
local_date_time_base operator+=(const date_duration_type & dd);
.fi

Local_date_time += date_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
local_date_time_base operator\-(const date_duration_type & dd) const;
.fi

Local_date_time \- date_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
local_date_time_base operator\-=(const date_duration_type & dd);
.fi

Local_date_time \-= date_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
local_date_time_base operator+(const time_duration_type & td) const;
.fi

Local_date_time + time_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
local_date_time_base operator+=(const time_duration_type & td);
.fi

Local_date_time += time_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
local_date_time_base operator\-(const time_duration_type & td) const;
.fi

Local_date_time \- time_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
local_date_time_base operator\-=(const time_duration_type & td);
.fi

Local_date_time \-= time_duration\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
time_duration_type operator\-(const local_date_time_base & rhs) const;
.fi

local_date_time \-= local_date_time <ndash></ndash>> time_duration_type .RE

.SS "local_date_time_base public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
static time_is_dst_result 
check_dst(date_type d, time_duration_type td, boost::shared_ptr< tz_type > tz);
.fi

.sp
Determines if given time label is in daylight savings for given zone\&. Determines if given time label is in daylight savings for given zone\&. Takes a date and time_duration representing a local time, along with time zone, and returns a time_is_dst_result object as result\&.
.RE

.SS "local_date_time_base private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
utc_time_type 
construction_adjustment(utc_time_type t, boost::shared_ptr< tz_type > z, 
                        bool dst_flag);
.fi

.sp
Adjust the passed in time to UTC?
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
std::string zone_as_offset(const time_duration_type & td, 
                           const std::string & separator) const;
.fi

.sp
Simple formatting code
<ndash></ndash>
todo remove this?
.RE


