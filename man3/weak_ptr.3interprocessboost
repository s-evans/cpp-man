.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE WE" 3 "" "" ""
.SH "NAME"
boost::interprocess::weak_ptr
.SH "SYNOPSIS"
.\" weak_ptr: Class template weak_ptr
.\" Class template weak_ptr: weak_ptr
.\" swap: Class template weak_ptr
.\" Class template weak_ptr: swap
.\" reset: Class template weak_ptr
.\" Class template weak_ptr: reset
.\" lock: Class template weak_ptr
.\" Class template weak_ptr: lock

.sp
.nf
// In header: <boost/interprocess/smart_ptr/shared_ptr\&.hpp>

template<typename T, typename A, typename D> 
class weak_ptr {
public:
  // construct/copy/destruct
  weak_ptr();
  template<typename Y> weak_ptr(weak_ptr< Y, A, D > const &);
  template<typename Y> weak_ptr(shared_ptr< Y, A, D > const &);
  template<typename Y> weak_ptr & operator=(weak_ptr< Y, A, D > const &);
  template<typename Y> weak_ptr & operator=(shared_ptr< Y, A, D > const &);

  // public member functions
  shared_ptr< T, A, D > lock() const;
  long use_count() const;
  bool expired() const;
  void reset();
  void swap(this_type &);
};
.fi
.SH "DESCRIPTION"
.PP
The
weak_ptr
class template stores a "weak reference" to an object that\'s already managed by a
shared_ptr\&. To access the object, a
weak_ptr
can be converted to a
shared_ptr
using the
shared_ptr
constructor or the member function lock\&. When the last
shared_ptr
to the object goes away and the object is deleted, the attempt to obtain a
shared_ptr
from the
weak_ptr
instances that refer to the deleted object will fail: the constructor will throw an exception of type bad_weak_ptr, and weak_ptr::lock will return an empty
shared_ptr\&.
.PP
Every
weak_ptr
meets the CopyConstructible and Assignable requirements of the C++ Standard Library, and so can be used in standard library containers\&. Comparison operators are supplied so that
weak_ptr
works with the standard library\'s associative containers\&.
.PP
weak_ptr
operations never throw exceptions\&.
.PP
The class template is parameterized on T, the type of the object pointed to\&.
.SS "weak_ptr public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
weak_ptr();
.fi

.sp
Effects: Constructs an empty
weak_ptr\&. Postconditions: use_count() == 0\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Y> weak_ptr(weak_ptr< Y, A, D > const & r);
.fi

.sp
Effects: If r is empty, constructs an empty
weak_ptr; otherwise, constructs a
weak_ptr
that shares ownership with r as if by storing a copy of the pointer stored in r\&.
.sp
Postconditions: use_count() == r\&.use_count()\&.
.sp
Throws: nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename Y> weak_ptr(shared_ptr< Y, A, D > const & r);
.fi

.sp
Effects: If r is empty, constructs an empty
weak_ptr; otherwise, constructs a
weak_ptr
that shares ownership with r as if by storing a copy of the pointer stored in r\&.
.sp
Postconditions: use_count() == r\&.use_count()\&.
.sp
Throws: nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename Y> weak_ptr & operator=(weak_ptr< Y, A, D > const & r);
.fi

.sp
Effects: Equivalent to weak_ptr(r)\&.swap(*this)\&.
.sp
Throws: nothing\&.
.sp
Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename Y> weak_ptr & operator=(shared_ptr< Y, A, D > const & r);
.fi

.sp
Effects: Equivalent to weak_ptr(r)\&.swap(*this)\&.
.sp
Throws: nothing\&.
.sp
Notes: The implementation is free to meet the effects (and the implied guarantees) via different means, without creating a temporary\&.
.RE

.SS "weak_ptr public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" lock: Class template weak_ptr
.\" Class template weak_ptr: lock

.sp

.nf
shared_ptr< T, A, D > lock() const;
.fi

.sp
Returns: expired()? shared_ptr<T>(): shared_ptr<T>(*this)\&.
.sp
Throws: nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
long use_count() const;
.fi

.sp
Returns: 0 if *this is empty; otherwise, the number of
shared_ptr
objects that share ownership with *this\&.
.sp
Throws: nothing\&.
.sp
Notes: use_count() is not necessarily efficient\&. Use only for debugging and testing purposes, not for production code\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
bool expired() const;
.fi

.sp
Returns: Returns: use_count() == 0\&.
.sp
Throws: nothing\&.
.sp
Notes: expired() may be faster than use_count()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" reset: Class template weak_ptr
.\" Class template weak_ptr: reset

.sp

.nf
void reset();
.fi

.sp
Effects: Equivalent to: weak_ptr()\&.swap(*this)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" swap: Class template weak_ptr
.\" Class template weak_ptr: swap

.sp

.nf
void swap(this_type & other);
.fi

.sp
Effects: Exchanges the contents of the two smart pointers\&.
.sp
Throws: nothing\&.
.RE


