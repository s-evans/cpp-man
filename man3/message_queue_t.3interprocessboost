.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLAT" 3 "" "" ""
.SH "NAME"
boost::interprocess::message_queue_t
.SH "SYNOPSIS"
.\" void_pointer: Class template message_queue_t
.\" Class template message_queue_t: void_pointer
.\" try_send: Class template message_queue_t
.\" Class template message_queue_t: try_send
.\" try_receive: Class template message_queue_t
.\" Class template message_queue_t: try_receive
.\" timed_send: Class template message_queue_t
.\" Class template message_queue_t: timed_send
.\" timed_receive: Class template message_queue_t
.\" Class template message_queue_t: timed_receive
.\" size_type: Class template message_queue_t
.\" Class template message_queue_t: size_type
.\" send: Class template message_queue_t
.\" Class template message_queue_t: send
.\" remove: Class template message_queue_t
.\" Class template message_queue_t: remove
.\" receive: Class template message_queue_t
.\" Class template message_queue_t: receive
.\" message_queue_t: Class template message_queue_t
.\" Class template message_queue_t: message_queue_t
.\" difference_type: Class template message_queue_t
.\" Class template message_queue_t: difference_type
.\" char_ptr: Class template message_queue_t
.\" Class template message_queue_t: char_ptr

.sp
.nf
// In header: <boost/interprocess/ipc/message_queue\&.hpp>

template<typename VoidPointer> 
class message_queue_t {
public:
  // types
  typedef VoidPointer                                                                             void_pointer;   
  typedef boost::intrusive::pointer_traits< void_pointer >::template rebind_pointer< char >::type char_ptr;       
  typedef boost::intrusive::pointer_traits< char_ptr >::difference_type                           difference_type;
  typedef \fIunspecified\fR                                                                             size_type;      

  // construct/copy/destruct
  message_queue_t(create_only_t, const char *, size_type, size_type, 
                  const permissions & = permissions());
  message_queue_t(open_or_create_t, const char *, size_type, size_type, 
                  const permissions & = permissions());
  message_queue_t(open_only_t, const char *);
  ~message_queue_t();

  // public member functions
  void send(const void *, size_type, unsigned int);
  bool try_send(const void *, size_type, unsigned int);
  bool timed_send(const void *, size_type, unsigned int, 
                  const boost::posix_time::ptime &);
  void receive(void *, size_type, size_type &, unsigned int &);
  bool try_receive(void *, size_type, size_type &, unsigned int &);
  bool timed_receive(void *, size_type, size_type &, unsigned int &, 
                     const boost::posix_time::ptime &);
  size_type get_max_msg() const;
  size_type get_max_msg_size() const;
  size_type get_num_msg() const;

  // public static functions
  static bool remove(const char *);
};
.fi
.SH "DESCRIPTION"
.PP
A class that allows sending messages between processes\&.
.SS "message_queue_t public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
message_queue_t(create_only_t create_only, const char * name, 
                size_type max_num_msg, size_type max_msg_size, 
                const permissions & perm = permissions());
.fi

.sp
Creates a process shared message queue with name "name"\&. For this message queue, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size"\&. Throws on error and if the queue was previously created\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
message_queue_t(open_or_create_t open_or_create, const char * name, 
                size_type max_num_msg, size_type max_msg_size, 
                const permissions & perm = permissions());
.fi

.sp
Opens or creates a process shared message queue with name "name"\&. If the queue is created, the maximum number of messages will be "max_num_msg" and the maximum message size will be "max_msg_size"\&. If queue was previously created the queue will be opened and "max_num_msg" and "max_msg_size" parameters are ignored\&. Throws on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
message_queue_t(open_only_t open_only, const char * name);
.fi

.sp
Opens a previously created process shared message queue with name "name"\&. If the queue was not previously created or there are no free resources, throws an error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" remove: Class template message_queue_t
.\" Class template message_queue_t: remove

.sp

.nf
~message_queue_t();
.fi

.sp
Destroys *this and indicates that the calling process is finished using the resource\&. All opened message queues are still valid after destruction\&. The destructor function will deallocate any system resources allocated by the system for use by this process for this resource\&. The resource can still be opened again calling the open constructor overload\&. To erase the message queue from the system use remove()\&.
.RE

.SS "message_queue_t public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" send: Class template message_queue_t
.\" Class template message_queue_t: send

.sp

.nf
void send(const void * buffer, size_type buffer_size, unsigned int priority);
.fi

.sp
Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority"\&. If the message queue is full the sender is blocked\&. Throws interprocess_error on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" try_send: Class template message_queue_t
.\" Class template message_queue_t: try_send

.sp

.nf
bool try_send(const void * buffer, size_type buffer_size, 
              unsigned int priority);
.fi

.sp
Sends a message stored in buffer "buffer" with size "buffer_size" through the message queue with priority "priority"\&. If the message queue is full the sender is not blocked and returns false, otherwise returns true\&. Throws interprocess_error on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" timed_send: Class template message_queue_t
.\" Class template message_queue_t: timed_send

.sp

.nf
bool timed_send(const void * buffer, size_type buffer_size, 
                unsigned int priority, 
                const boost::posix_time::ptime & abs_time);
.fi

.sp
Sends a message stored in buffer "buffer" with size "buffer_size" in the message queue with priority "priority"\&. If the message queue is full the sender retries until time "abs_time" is reached\&. Returns true if the message has been successfully sent\&. Returns false if timeout is reached\&. Throws interprocess_error on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" receive: Class template message_queue_t
.\" Class template message_queue_t: receive

.sp

.nf
void receive(void * buffer, size_type buffer_size, size_type & recvd_size, 
             unsigned int & priority);
.fi

.sp
Receives a message from the message queue\&. The message is stored in buffer "buffer", which has size "buffer_size"\&. The received message has size "recvd_size" and priority "priority"\&. If the message queue is empty the receiver is blocked\&. Throws interprocess_error on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" try_receive: Class template message_queue_t
.\" Class template message_queue_t: try_receive

.sp

.nf
bool try_receive(void * buffer, size_type buffer_size, size_type & recvd_size, 
                 unsigned int & priority);
.fi

.sp
Receives a message from the message queue\&. The message is stored in buffer "buffer", which has size "buffer_size"\&. The received message has size "recvd_size" and priority "priority"\&. If the message queue is empty the receiver is not blocked and returns false, otherwise returns true\&. Throws interprocess_error on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" timed_receive: Class template message_queue_t
.\" Class template message_queue_t: timed_receive

.sp

.nf
bool timed_receive(void * buffer, size_type buffer_size, 
                   size_type & recvd_size, unsigned int & priority, 
                   const boost::posix_time::ptime & abs_time);
.fi

.sp
Receives a message from the message queue\&. The message is stored in buffer "buffer", which has size "buffer_size"\&. The received message has size "recvd_size" and priority "priority"\&. If the message queue is empty the receiver retries until time "abs_time" is reached\&. Returns true if the message has been successfully sent\&. Returns false if timeout is reached\&. Throws interprocess_error on error\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
size_type get_max_msg() const;
.fi

.sp
Returns the maximum number of messages allowed by the queue\&. The message queue must be opened or created previously\&. Otherwise, returns 0\&. Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
size_type get_max_msg_size() const;
.fi

.sp
Returns the maximum size of message allowed by the queue\&. The message queue must be opened or created previously\&. Otherwise, returns 0\&. Never throws
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
size_type get_num_msg() const;
.fi

.sp
Returns the number of messages currently stored\&. Never throws
.RE

.SS "message_queue_t public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" remove: Class template message_queue_t
.\" Class template message_queue_t: remove

.sp

.nf
static bool remove(const char * name);
.fi

.sp
Removes the message queue from the system\&. Returns false on error\&. Never throws
.RE


