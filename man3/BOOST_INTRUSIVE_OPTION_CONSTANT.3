.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "" 3 "" "" ""
.\" BOOST_INTRUSIVE_OPTION_CONSTANT: Macro BOOST_INTRUSIVE_OPTION_CONSTANT
.\" Macro BOOST_INTRUSIVE_OPTION_CONSTANT: BOOST_INTRUSIVE_OPTION_CONSTANT
.SH "NAME"
BOOST_INTRUSIVE_OPTION_CONSTANT
.SH "SYNOPSIS"
.\" BOOST_INTRUSIVE_OPTION_CONSTANT: Macro BOOST_INTRUSIVE_OPTION_CONSTANT
.\" Macro BOOST_INTRUSIVE_OPTION_CONSTANT: BOOST_INTRUSIVE_OPTION_CONSTANT

.sp
.nf
// In header: <boost/intrusive/pack_options\&.hpp>

BOOST_INTRUSIVE_OPTION_CONSTANT(OPTION_NAME, TYPE, VALUE, CONSTANT_NAME)
.fi
.SH "DESCRIPTION"
.\" BOOST_INTRUSIVE_OPTION_CONSTANT: Macro BOOST_INTRUSIVE_OPTION_CONSTANT
.\" Macro BOOST_INTRUSIVE_OPTION_CONSTANT: BOOST_INTRUSIVE_OPTION_CONSTANT
.PP
Defines an option class of name OPTION_NAME that can be used to specify a constant of type TYPE with value VALUE\&.\&.\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
struct OPTION_NAME<TYPE VALUE>
{  unspecified_content  };

.fi
.if n \{\
.RE
.\}

.PP
\&.\&.\&.that after being combined with
boost::intrusive::pack_options, will contain a CONSTANT_NAME static constant of value VALUE\&. Example:
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
//[includes and namespaces omitted for brevity]

//This macro will create the following class:
//    template<bool Enabled>
//    struct incremental
//    { unspecified_content };
BOOST_INTRUSIVE_OPTION_CONSTANT(incremental, bool, Enabled, is_incremental)

struct empty_default{};

const bool is_incremental = pack_options< empty_default, incremental<true> >::type::is_incremental;

BOOST_STATIC_ASSERT(( is_incremental == true ));

.fi
.if n \{\
.RE
.\}
.sp


