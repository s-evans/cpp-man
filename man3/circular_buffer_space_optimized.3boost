.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS" 3 "" "" ""
.SH "NAME"
boost::circular_buffer_space_optimized \- Space optimized circular buffer container adaptor\&. T must be a copyable class or must have an noexcept move constructor and move assignment operator\&.
.SH "SYNOPSIS"
.\" value_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: value_type
.\" size_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: size_type
.\" set_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: set_capacity
.\" rvalue_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rvalue_type
.\" rset_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rset_capacity
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert
.\" reverse_iterator: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: reverse_iterator
.\" rerase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rerase
.\" reference: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: reference
.\" reduce_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: reduce_capacity
.\" push_front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_front
.\" push_back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_back
.\" pop_front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: pop_front
.\" pop_back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: pop_back
.\" pointer: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: pointer
.\" param_value_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: param_value_type
.\" iterator: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: iterator
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert
.\" init_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: init_capacity
.\" erase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: erase
.\" difference_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: difference_type
.\" const_reverse_iterator: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: const_reverse_iterator
.\" const_reference: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: const_reference
.\" const_pointer: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: const_pointer
.\" const_iterator: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: const_iterator
.\" const_array_range: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: const_array_range
.\" clear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: clear
.\" circular_buffer_space_optimized: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: circular_buffer_space_optimized
.\" check_low_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: check_low_capacity
.\" check_high_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: check_high_capacity
.\" capacity_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: capacity_type
.\" assign: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: assign
.\" array_range: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: array_range
.\" allocator_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: allocator_type
.\" adjust_min_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: adjust_min_capacity

.sp
.nf
// In header: <boost/circular_buffer/space_optimized\&.hpp>

template<typename T, typename Alloc> 
class circular_buffer_space_optimized :
  private boost::circular_buffer< T, Alloc >
{
public:
  // types
  typedef circular_buffer< T, Alloc >::value_type             value_type;            
  typedef circular_buffer< T, Alloc >::pointer                pointer;               
  typedef circular_buffer< T, Alloc >::const_pointer          const_pointer;         
  typedef circular_buffer< T, Alloc >::reference              reference;             
  typedef circular_buffer< T, Alloc >::const_reference        const_reference;       
  typedef circular_buffer< T, Alloc >::size_type              size_type;             
  typedef circular_buffer< T, Alloc >::difference_type        difference_type;       
  typedef circular_buffer< T, Alloc >::allocator_type         allocator_type;        
  typedef circular_buffer< T, Alloc >::const_iterator         const_iterator;        
  typedef circular_buffer< T, Alloc >::iterator               iterator;              
  typedef circular_buffer< T, Alloc >::const_reverse_iterator const_reverse_iterator;
  typedef circular_buffer< T, Alloc >::reverse_iterator       reverse_iterator;      
  typedef circular_buffer< T, Alloc >::array_range            array_range;           
  typedef circular_buffer< T, Alloc >::const_array_range      const_array_range;     
  typedef circular_buffer< T, Alloc >::param_value_type       param_value_type;      
  typedef circular_buffer< T, Alloc >::rvalue_type            rvalue_type;           
  typedef cb_details::capacity_control< size_type >           capacity_type;         

  // construct/copy/destruct
  explicit circular_buffer_space_optimized(const allocator_type & = allocator_type()) noexcept;
  explicit circular_buffer_space_optimized(capacity_type, 
                                           const allocator_type & = allocator_type());
  circular_buffer_space_optimized(capacity_type, param_value_type, 
                                  const allocator_type & = allocator_type());
  circular_buffer_space_optimized(capacity_type, size_type, param_value_type, 
                                  const allocator_type & = allocator_type());
  circular_buffer_space_optimized(const circular_buffer_space_optimized< T, Alloc > &);
  circular_buffer_space_optimized(circular_buffer_space_optimized< T, Alloc > &&) noexcept;
  template<typename InputIterator> 
    circular_buffer_space_optimized(InputIterator, InputIterator, 
                                    const allocator_type & = allocator_type());
  template<typename InputIterator> 
    circular_buffer_space_optimized(capacity_type, InputIterator, 
                                    InputIterator, 
                                    const allocator_type & = allocator_type());
  circular_buffer_space_optimized< T, Alloc > & 
  operator=(const circular_buffer_space_optimized< T, Alloc > &);
  circular_buffer_space_optimized< T, Alloc > & 
  operator=(circular_buffer_space_optimized< T, Alloc > &&) noexcept;

  // public member functions
  bool full() const noexcept;
  size_type reserve() const noexcept;
  const capacity_type & capacity() const noexcept;
  void set_capacity(const capacity_type &);
  void resize(size_type, param_value_type = value_type());
  void rset_capacity(const capacity_type &);
  void rresize(size_type, param_value_type = value_type());
  void assign(size_type, param_value_type);
  void assign(capacity_type, size_type, param_value_type);
  template<typename InputIterator> void assign(InputIterator, InputIterator);
  template<typename InputIterator> 
    void assign(capacity_type, InputIterator, InputIterator);
  void swap(circular_buffer_space_optimized< T, Alloc > &) noexcept;
  void push_back(param_value_type);
  void push_back(rvalue_type);
  void push_back();
  void push_front(param_value_type);
  void push_front(rvalue_type);
  void push_front();
  void pop_back();
  void pop_front();
  iterator insert(iterator, param_value_type);
  iterator insert(iterator, rvalue_type);
  iterator insert(iterator);
  void insert(iterator, size_type, param_value_type);
  template<typename InputIterator> 
    void insert(iterator, InputIterator, InputIterator);
  iterator rinsert(iterator, param_value_type);
  iterator rinsert(iterator, rvalue_type);
  iterator rinsert(iterator);
  void rinsert(iterator, size_type, param_value_type);
  template<typename InputIterator> 
    void rinsert(iterator, InputIterator, InputIterator);
  iterator erase(iterator);
  iterator erase(iterator, iterator);
  iterator rerase(iterator);
  iterator rerase(iterator, iterator);
  void clear();

  // private member functions
  void adjust_min_capacity();
  size_type ensure_reserve(size_type, size_type) const;
  void check_low_capacity(size_type = 1);
  void check_high_capacity();
  void reduce_capacity(const true_type &);
  void reduce_capacity(const false_type &);
  template<typename IntegralType> 
    void insert(const iterator &, IntegralType, IntegralType, 
                const true_type &);
  template<typename Iterator> 
    void insert(const iterator &, Iterator, Iterator, const false_type &);
  template<typename IntegralType> 
    void rinsert(const iterator &, IntegralType, IntegralType, 
                 const true_type &);
  template<typename Iterator> 
    void rinsert(const iterator &, Iterator, Iterator, const false_type &);

  // private static functions
  static size_type init_capacity(const capacity_type &, size_type);
  template<typename IntegralType> 
    static size_type 
    init_capacity(const capacity_type &, IntegralType, IntegralType, 
                  const true_type &);
  template<typename Iterator> 
    static size_type 
    init_capacity(const capacity_type &, Iterator, Iterator, 
                  const false_type &);
  template<typename InputIterator> 
    static size_type 
    init_capacity(const capacity_type &, InputIterator, InputIterator, 
                  const std::input_iterator_tag &);
  template<typename ForwardIterator> 
    static size_type 
    init_capacity(const capacity_type &, ForwardIterator, ForwardIterator, 
                  const std::forward_iterator_tag &);
};
.fi
.SH "DESCRIPTION"
.SS "circular_buffer_space_optimized public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" capacity_control: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: capacity_control
.\" capacity_type: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: capacity_type

typedef
cb_details::capacity_control<
size_type
>
capacity_type;
.sp
Capacity controller of the space optimized circular buffer\&.
.sp
\fBSee Also:\fRcapacity_control in details\&.hpp\&.
class capacity_control&#9618;.br&#9618; {&#9618;.br&#9618; size_type m_capacity; // Available capacity\&.&#9618;.br&#9618; size_type m_min_capacity; // Minimum capacity\&.&#9618;.br&#9618; public:&#9618;.br&#9618; capacity_control(size_type capacity, size_type min_capacity = 0)&#9618;.br&#9618; : m_capacity(capacity), m_min_capacity(min_capacity)&#9618;.br&#9618; {};&#9618;.br&#9618; size_type capacity() const { return m_capacity; }&#9618;.br&#9618; size_type min_capacity() const { return m_min_capacity; }&#9618;.br&#9618; operator size_type() const { return m_capacity; }&#9618;.br&#9618; };&#9618;.br&#9618;
.sp
Always
capacity >= min_capacity\&.
.sp
The
capacity()
represents the capacity of the
circular_buffer_space_optimized
and the
min_capacity()
determines the minimal allocated size of its internal buffer\&.
.sp
The converting constructor of the
capacity_control
allows implicit conversion from
size_type\-like types which ensures compatibility of creating an instance of the
circular_buffer_space_optimized
with other STL containers\&.
.sp
On the other hand the operator
size_type()
provides implicit conversion to the
size_type
which allows to treat the capacity of the
circular_buffer_space_optimized
the same way as in the
circular_buffer\&.
.RE

.SS "circular_buffer_space_optimized public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit circular_buffer_space_optimized(const allocator_type & alloc = allocator_type()) noexcept;
.fi

.sp
Create an empty space optimized circular buffer with zero capacity\&. 
.PP \fBComplexity\fR. Constant\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
Since Boost version 1\&.36 the behaviour of this constructor has changed\&. Now it creates a space optimized circular buffer with zero capacity\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity()\&.capacity() == 0 && capacity()\&.min_capacity() == 0 && size() == 0
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit circular_buffer_space_optimized(capacity_type capacity_ctrl, 
                                         const allocator_type & alloc = allocator_type());
.fi

.sp
Create an empty space optimized circular buffer with the specified capacity\&. 
.PP \fBComplexity\fR. Constant\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
capacity_ctrl
.RS 4
The capacity controller representing the maximum number of elements which can be stored in the
circular_buffer_space_optimized
and the minimal allocated size of the internal buffer\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && size() == 0&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
capacity_ctrl\&.min_capacity()\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
circular_buffer_space_optimized(capacity_type capacity_ctrl, 
                                param_value_type item, 
                                const allocator_type & alloc = allocator_type());
.fi

Create a full space optimized circular buffer with the specified capacity filled with capacity_ctrl\&.capacity() copies of item\&. 
.PP \fBComplexity\fR. Linear (in the capacity_ctrl\&.capacity())\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
capacity_ctrl
.RS 4
The capacity controller representing the maximum number of elements which can be stored in the
circular_buffer_space_optimized
and the minimal allocated size of the internal buffer\&.
.RE
.PP
item
.RS 4
The element the created
circular_buffer_space_optimized
will be filled with\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && full() && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this) [capacity_ctrl\&.capacity() \- 1] == item&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
capacity_ctrl\&.capacity()\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
circular_buffer_space_optimized(capacity_type capacity_ctrl, size_type n, 
                                param_value_type item, 
                                const allocator_type & alloc = allocator_type());
.fi

Create a space optimized circular buffer with the specified capacity filled with n copies of item\&. 
.PP \fBComplexity\fR. Linear (in the n)\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
capacity_ctrl
.RS 4
The capacity controller representing the maximum number of elements which can be stored in the
circular_buffer_space_optimized
and the minimal allocated size of the internal buffer\&.
.RE
.PP
item
.RS 4
The element the created
circular_buffer_space_optimized
will be filled with\&.
.RE
.PP
n
.RS 4
The number of elements the created
circular_buffer_space_optimized
will be filled with\&.
.RE
.RE
.PP
Requires:
.RS 4
capacity_ctrl\&.capacity() >= n
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && size() == n && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this)[n \- 1] == item&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
max[n, capacity_ctrl\&.min_capacity()]\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
circular_buffer_space_optimized(const circular_buffer_space_optimized< T, Alloc > & cb);
.fi

.sp
The copy constructor\&. Creates a copy of the specified
circular_buffer_space_optimized\&.
.PP \fBComplexity\fR. Linear (in the size of cb)\&.
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
The
circular_buffer_space_optimized
to be copied\&.
.RE
.RE
.PP
Postconditions:
.RS 4
*this == cb&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
cb\&.size()\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
circular_buffer_space_optimized(circular_buffer_space_optimized< T, Alloc > && cb) noexcept;
.fi

.sp
The move constructor\&. Move constructs a
circular_buffer_space_optimized
from
cb, leaving
cb
empty\&.
.PP \fBConstant.\fR.
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
circular_buffer
to \'steal\' value from\&.
.RE
.RE
.PP
Requires:
.RS 4
C++ compiler with rvalue references support\&.
.RE
.PP
Postconditions:
.RS 4
cb\&.empty()
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
template<typename InputIterator> 
  circular_buffer_space_optimized(InputIterator first, InputIterator last, 
                                  const allocator_type & alloc = allocator_type());
.fi

.sp
Create a full space optimized circular buffer filled with a copy of the range\&. 
.PP \fBComplexity\fR. Linear (in the std::distance(first, last))\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[1]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity()\&.capacity() == std::distance(first, last) && capacity()\&.min_capacity() == 0 && full() && (*this)[0]== *first && (*this)[1] == *(first + 1) && \&.\&.\&. && (*this)[std::distance(first, last) \- 1] == *(last \- 1)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
std::distance(first, last)\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept and
InputIterator
is a move iterator\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
template<typename InputIterator> 
  circular_buffer_space_optimized(capacity_type capacity_ctrl, 
                                  InputIterator first, InputIterator last, 
                                  const allocator_type & alloc = allocator_type());
.fi

.sp
Create a space optimized circular buffer with the specified capacity (and the minimal guaranteed amount of allocated memory) filled with a copy of the range\&. 
.PP \fBComplexity\fR. Linear (in std::distance(first, last); in min[capacity_ctrl\&.capacity(), std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[2]\d\s+2)\&.
.PP
Parameters:
.RS 4
.PP
alloc
.RS 4
The allocator\&.
.RE
.PP
capacity_ctrl
.RS 4
The capacity controller representing the maximum number of elements which can be stored in the
circular_buffer_space_optimized
and the minimal allocated size of the internal buffer\&.
.RE
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[1]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && size() <= std::distance(first, last) && (*this)[0]== (last \- capacity_ctrl\&.capacity()) && (*this)[1] == *(last \- capacity_ctrl\&.capacity() + 1) && \&.\&.\&. && (*this)[capacity_ctrl\&.capacity() \- 1] == *(last \- 1)&#9618;.br&#9618;
&#9618;.br&#9618;
If the number of items to be copied from the range
[first, last)
is greater than the specified
capacity_ctrl\&.capacity()
then only elements from the range
[last \- capacity_ctrl\&.capacity(), last)
will be copied\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
max[capacity_ctrl\&.min_capacity(), min[capacity_ctrl\&.capacity(), std::distance(first, last)]]\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
circular_buffer_space_optimized< T, Alloc > & 
operator=(const circular_buffer_space_optimized< T, Alloc > & cb);
.fi

.sp
The assign operator\&. Makes this
circular_buffer_space_optimized
to become a copy of the specified
circular_buffer_space_optimized\&.
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to this circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of cb)\&.
\fBSee Also:\fRassign(size_type, const_reference), assign(capacity_type, size_type, const_reference), assign(InputIterator, InputIterator), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
The
circular_buffer_space_optimized
to be copied\&.
.RE
.RE
.PP
Postconditions:
.RS 4
*this == cb&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
cb\&.size()\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
circular_buffer_space_optimized< T, Alloc > & 
operator=(circular_buffer_space_optimized< T, Alloc > && cb) noexcept;
.fi

Move assigns content of cb to *this, leaving cb empty\&. 
.PP \fBComplexity\fR. Constant\&.
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
circular_buffer
to \'steal\' value from\&.
.RE
.RE
.PP
Requires:
.RS 4
C++ compiler with rvalue references support\&.
.RE
.PP
Postconditions:
.RS 4
cb\&.empty()
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE

.SS "circular_buffer_space_optimized public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool full() const noexcept;
.fi

Is the circular_buffer_space_optimized full? 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRempty()
.PP
Returns:
.RS 4
true
if the number of elements stored in the
circular_buffer_space_optimized
equals the capacity of the
circular_buffer_space_optimized;
false
otherwise\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
size_type reserve() const noexcept;
.fi

Get the maximum number of elements which can be inserted into the circular_buffer_space_optimized without overwriting any of already stored elements\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRcapacity(), size(), max_size()
.PP
Returns:
.RS 4
capacity()\&.capacity() \- size()
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
const capacity_type & capacity() const noexcept;
.fi

Get the capacity of the circular_buffer_space_optimized\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Does not invalidate any iterators\&.
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRreserve(), size(), max_size(), set_capacity(const capacity_type&)
.PP
Returns:
.RS 4
The capacity controller representing the maximum number of elements which can be stored in the
circular_buffer_space_optimized
and the minimal allocated size of the internal buffer\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" set_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: set_capacity

.sp

.nf
void set_capacity(const capacity_type & capacity_ctrl);
.fi

Change the capacity (and the minimal guaranteed amount of allocated memory) of the circular_buffer_space_optimized\&. 
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in min[size(), capacity_ctrl\&.capacity()])\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
To explicitly clear the extra allocated memory use the
\fBshrink\-to\-fit\fR
technique:&#9618;.br&#9618;
&#9618;.br&#9618;
boost::circular_buffer_space_optimized<int> cb(1000);&#9618;.br&#9618; \&.\&.\&.&#9618;.br&#9618; boost::circular_buffer_space_optimized<int>(cb)\&.swap(cb);&#9618;.br&#9618;
&#9618;.br&#9618;
For more information about the shrink\-to\-fit technique in STL see
\m[blue]\fBhttp://www\&.gotw\&.ca/gotw/054\&.htm\fR\m[]\&.
.sp .5v
.RE

\fBSee Also:\fRrset_capacity(const capacity_type&), resize(size_type, const_reference)
.PP
Parameters:
.RS 4
.PP
capacity_ctrl
.RS 4
The new capacity controller\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && size() <= capacity_ctrl\&.capacity()&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer_space_optimized
is greater than the desired new capacity then number of
[size() \- capacity_ctrl\&.capacity()]
\fBlast\fR
elements will be removed and the new size will be equal to
capacity_ctrl\&.capacity()\&.&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer_space_optimized
is lower than the new capacity then the amount of allocated memory in the internal buffer may be accommodated as necessary but it will never drop below
capacity_ctrl\&.min_capacity()\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted, (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
void resize(size_type new_size, param_value_type item = value_type());
.fi

Change the size of the circular_buffer_space_optimized\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the new size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRrresize(size_type, const_reference), set_capacity(const capacity_type&)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element the
circular_buffer_space_optimized
will be filled with in order to gain the requested size\&. (See the
\fIEffect\fR\&.)
.RE
.PP
new_size
.RS 4
The new size\&.
.RE
.RE
.PP
Postconditions:
.RS 4
size() == new_size && capacity()\&.capacity() >= new_size&#9618;.br&#9618;
&#9618;.br&#9618;
If the new size is greater than the current size, copies of
item
will be inserted at the
\fBback\fR
of the of the
circular_buffer_space_optimized
in order to achieve the desired size\&. In the case the resulting size exceeds the current capacity the capacity will be set to
new_size\&.&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer_space_optimized
is greater than the desired new size then number of
[size() \- new_size]
\fBlast\fR
elements will be removed\&. (The capacity will remain unchanged\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be accommodated as necessary\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rset_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rset_capacity

.sp

.nf
void rset_capacity(const capacity_type & capacity_ctrl);
.fi

Change the capacity (and the minimal guaranteed amount of allocated memory) of the circular_buffer_space_optimized\&. 
.PP \fBException Safety\fR. Strong\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in min[size(), capacity_ctrl\&.capacity()])\&.
\fBSee Also:\fRset_capacity(const capacity_type&), rresize(size_type, const_reference)
.PP
Parameters:
.RS 4
.PP
capacity_ctrl
.RS 4
The new capacity controller\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && size() <= capacity_ctrl&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer_space_optimized
is greater than the desired new capacity then number of
[size() \- capacity_ctrl\&.capacity()]
\fBfirst\fR
elements will be removed and the new size will be equal to
capacity_ctrl\&.capacity()\&.&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer_space_optimized
is lower than the new capacity then the amount of allocated memory in the internal buffer may be accommodated as necessary but it will never drop below
capacity_ctrl\&.min_capacity()\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear

.sp

.nf
void rresize(size_type new_size, param_value_type item = value_type());
.fi

Change the size of the circular_buffer_space_optimized\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the new size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRresize(size_type, const_reference), rset_capacity(const capacity_type&)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element the
circular_buffer_space_optimized
will be filled with in order to gain the requested size\&. (See the
\fIEffect\fR\&.)
.RE
.PP
new_size
.RS 4
The new size\&.
.RE
.RE
.PP
Postconditions:
.RS 4
size() == new_size && capacity()\&.capacity() >= new_size&#9618;.br&#9618;
&#9618;.br&#9618;
If the new size is greater than the current size, copies of
item
will be inserted at the
\fBfront\fR
of the of the
circular_buffer_space_optimized
in order to achieve the desired size\&. In the case the resulting size exceeds the current capacity the capacity will be set to
new_size\&.&#9618;.br&#9618;
&#9618;.br&#9618;
If the current number of elements stored in the
circular_buffer_space_optimized
is greater than the desired new size then number of
[size() \- new_size]
\fBfirst\fR
elements will be removed\&. (The capacity will remain unchanged\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be accommodated as necessary\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" assign: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: assign

.sp

.nf
void assign(size_type n, param_value_type item);
.fi

Assign n items into the space optimized circular buffer\&. The content of the
circular_buffer_space_optimized
will be removed and replaced with
n
copies of the
item\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the n)\&.
\fBSee Also:\fRoperator=, assign(capacity_type, size_type, const_reference), assign(InputIterator, InputIterator), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element the
circular_buffer_space_optimized
will be filled with\&.
.RE
.PP
n
.RS 4
The number of elements the
circular_buffer_space_optimized
will be filled with\&.
.RE
.RE
.PP
Postconditions:
.RS 4
capacity()\&.capacity() == n && capacity()\&.min_capacity() == 0 && size() == n && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this) [n \- 1] == item&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
n\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" assign: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: assign

.sp

.nf
void assign(capacity_type capacity_ctrl, size_type n, param_value_type item);
.fi

Assign n items into the space optimized circular buffer specifying the capacity\&. The capacity of the
circular_buffer_space_optimized
will be set to the specified value and the content of the
circular_buffer_space_optimized
will be removed and replaced with
n
copies of the
item\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the n)\&.
\fBSee Also:\fRoperator=, assign(size_type, const_reference), assign(InputIterator, InputIterator), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
capacity_ctrl
.RS 4
The new capacity controller\&.
.RE
.PP
item
.RS 4
The element the
circular_buffer_space_optimized
will be filled with\&.
.RE
.PP
n
.RS 4
The number of elements the
circular_buffer_space_optimized
will be filled with\&.
.RE
.RE
.PP
Requires:
.RS 4
capacity_ctrl\&.capacity() >= n
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && size() == n && (*this)[0] == item && (*this)[1] == item && \&.\&.\&. && (*this) [n \- 1] == item&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory will be
max[n, capacity_ctrl\&.min_capacity()]\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" assign: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: assign

.sp

.nf
template<typename InputIterator> 
  void assign(InputIterator first, InputIterator last);
.fi

.sp
Assign a copy of the range into the space optimized circular buffer\&. The content of the
circular_buffer_space_optimized
will be removed and replaced with copies of elements from the specified range\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the std::distance(first, last))\&.
\fBSee Also:\fRoperator=, assign(size_type, const_reference), assign(capacity_type, size_type, const_reference), assign(capacity_type, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[1]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity()\&.capacity() == std::distance(first, last) && capacity()\&.min_capacity() == 0 && size() == std::distance(first, last) && (*this)[0]== *first && (*this)[1] == *(first + 1) && \&.\&.\&. && (*this)[std::distance(first, last) \- 1] == *(last \- 1)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
std::distance(first, last)\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept and
InputIterator
is a move iterator\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" assign: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: assign

.sp

.nf
template<typename InputIterator> 
  void assign(capacity_type capacity_ctrl, InputIterator first, 
              InputIterator last);
.fi

.sp
Assign a copy of the range into the space optimized circular buffer specifying the capacity\&. The capacity of the
circular_buffer_space_optimized
will be set to the specified value and the content of the
circular_buffer_space_optimized
will be removed and replaced with copies of elements from the specified range\&.
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in std::distance(first, last); in min[capacity_ctrl\&.capacity(), std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[2]\d\s+2)\&.
\fBSee Also:\fRoperator=, assign(size_type, const_reference), assign(capacity_type, size_type, const_reference), assign(InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
capacity_ctrl
.RS 4
The new capacity controller\&.
.RE
.PP
first
.RS 4
The beginning of the range to be copied\&.
.RE
.PP
last
.RS 4
The end of the range to be copied\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.&#9618;.br&#9618;
first
and
last
have to meet the requirements of
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[1]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
capacity() == capacity_ctrl && size() <= std::distance(first, last) && (*this)[0]== *(last \- capacity) && (*this)[1] == *(last \- capacity + 1) && \&.\&.\&. && (*this)[capacity \- 1] == *(last \- 1)&#9618;.br&#9618;
&#9618;.br&#9618;
If the number of items to be copied from the range
[first, last)
is greater than the specified
capacity
then only elements from the range
[last \- capacity, last)
will be copied\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer is
max[std::distance(first, last), capacity_ctrl\&.min_capacity()]\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept and
InputIterator
is a move iterator\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" BOOST_CB_DISABLE_DEBUG: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: BOOST_CB_DISABLE_DEBUG

.sp

.nf
void swap(circular_buffer_space_optimized< T, Alloc > & cb) noexcept;
.fi

.sp
Swap the contents of two space\-optimized circular\-buffers\&. 
.PP \fBException Safety\fR. No\-throw\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators of both circular_buffer_space_optimized containers\&. (On the other hand the iterators still point to the same elements but within another container\&. If you want to rely on this feature you have to turn the __debug_support off by defining macro BOOST_CB_DISABLE_DEBUG, otherwise an assertion will report an error if such invalidated iterator is used\&.)
.PP \fBComplexity\fR. Constant (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRswap(circular_buffer<T, Alloc>&, circular_buffer<T, Alloc>&), swap(circular_buffer_space_optimized<T, Alloc>&, circular_buffer_space_optimized<T, Alloc>&)
.PP
Parameters:
.RS 4
.PP
cb
.RS 4
The
circular_buffer_space_optimized
whose content will be swapped\&.
.RE
.RE
.PP
Postconditions:
.RS 4
this
contains elements of
cb
and vice versa; the capacity and the amount of allocated memory in the internal buffer of
this
equal to the capacity and the amount of allocated memory of
cb
and vice versa\&.
.RE
.PP
Throws:
.RS 4
Nothing\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" push_back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_back

.sp

.nf
void push_back(param_value_type item);
.fi

.sp
Insert a new element at the end of the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpush_front(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: back
if
capacity()\&.capacity() > 0
then
back() == item&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the first element will be removed\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" push_back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_back

.sp

.nf
void push_back(rvalue_type item);
.fi

.sp
Insert a new element at the end of the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpush_front(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: back
if
capacity()\&.capacity() > 0
then
back() == item&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the first element will be removed\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" push_back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_back

.sp

.nf
void push_back();
.fi

.sp
Insert a new element at the end of the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpush_front(const_reference), pop_back(), pop_front()
.PP
Postconditions:
.RS 4
.\" back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: back
if
capacity()\&.capacity() > 0
then
back() == item&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the first element will be removed\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T()
throws\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" push_front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_front

.sp

.nf
void push_front(param_value_type item);
.fi

.sp
Insert a new element at the beginning of the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpush_back(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: front
if
capacity()\&.capacity() > 0
then
front() == item&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the last element will be removed\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" push_front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_front

.sp

.nf
void push_front(rvalue_type item);
.fi

.sp
Insert a new element at the beginning of the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpush_back(const_reference), pop_back(), pop_front()
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.RE
.PP
Postconditions:
.RS 4
.\" front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: front
if
capacity()\&.capacity() > 0
then
front() == item&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the last element will be removed\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" push_front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: push_front

.sp

.nf
void push_front();
.fi

.sp
Insert a new element at the beginning of the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpush_back(const_reference), pop_back(), pop_front()
.PP
Postconditions:
.RS 4
.\" front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: front
if
capacity()\&.capacity() > 0
then
front() == item&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the last element will be removed\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T()
throws\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" pop_back: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: pop_back

.sp

.nf
void pop_back();
.fi

.sp
Remove the last element from the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpop_front(), push_back(const_reference), push_front(const_reference)
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Postconditions:
.RS 4
The last element is removed from the
circular_buffer_space_optimized\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively decreased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" pop_front: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: pop_front

.sp

.nf
void pop_front();
.fi

.sp
Remove the first element from the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRpop_back(), push_back(const_reference), push_front(const_reference)
.PP
Requires:
.RS 4
!empty()
.RE
.PP
Postconditions:
.RS 4
The first element is removed from the
circular_buffer_space_optimized\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively decreased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert

.sp

.nf
iterator insert(iterator pos, param_value_type item);
.fi

.sp
Insert an element at the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRinsert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
The
item
will be inserted at the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the first element will be overwritten\&. If the
circular_buffer_space_optimized
is full and the
pos
points to
begin(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
Iterator to the inserted element or
begin()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert

.sp

.nf
iterator insert(iterator pos, rvalue_type item);
.fi

.sp
Insert an element at the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRinsert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
The
item
will be inserted at the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the first element will be overwritten\&. If the
circular_buffer_space_optimized
is full and the
pos
points to
begin(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
Iterator to the inserted element or
begin()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert

.sp

.nf
iterator insert(iterator pos);
.fi

.sp
Insert an element at the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRinsert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator specifying the position where the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
The
item
will be inserted at the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the first element will be overwritten\&. If the
circular_buffer_space_optimized
is full and the
pos
points to
begin(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
Iterator to the inserted element or
begin()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T()
throws\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert

.sp

.nf
void insert(iterator pos, size_type n, param_value_type item);
.fi

Insert n copies of the item at the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in min[capacity()\&.capacity(), size() + n])\&.
.PP \fBExample\fR. Consider a circular_buffer_space_optimized with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting 5 elements at the position p:&#9618;.br&#9618; &#9618;.br&#9618; insert(p, (size_t)5, 0);&#9618;.br&#9618; &#9618;.br&#9618; actually only 4 elements get inserted and elements 1 and 2 are overwritten\&. This is due to the fact the insert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |0|0|0|0|3|4|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|0|0|0|0|0|3|4|\&.
\fBSee Also:\fRinsert(iterator, value_type), insert(iterator, InputIterator, InputIterator), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element whose copies will be inserted\&.
.RE
.PP
n
.RS 4
The number of
items the to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
items will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
The number of
min[n, (pos \- begin()) + reserve()]
elements will be inserted at the position
pos\&.&#9618;.br&#9618;
The number of
min[pos \- begin(), max[0, n \- reserve()]]
elements will be overwritten at the beginning of the
circular_buffer_space_optimized\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert

.sp

.nf
template<typename InputIterator> 
  void insert(iterator pos, InputIterator first, InputIterator last);
.fi

Insert the range [first, last) at the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in [size() + std::distance(first, last)]; in min[capacity()\&.capacity(), size() + std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[2]\d\s+2)\&.
.PP \fBExample\fR. Consider a circular_buffer_space_optimized with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting a range of elements at the position p:&#9618;.br&#9618; &#9618;.br&#9618; int array[] = { 5, 6, 7, 8, 9 };&#9618;.br&#9618; insert(p, array, array + 5);&#9618;.br&#9618; &#9618;.br&#9618; actually only elements 6, 7, 8 and 9 from the specified range get inserted and elements 1 and 2 are overwritten\&. This is due to the fact the insert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |6|7|8|9|3|4|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|5|6|7|8|9|3|4|\&.
\fBSee Also:\fRinsert(iterator, value_type), insert(iterator, size_type, value_type), rinsert(iterator, value_type), rinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be inserted\&.
.RE
.PP
last
.RS 4
The end of the range to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the range will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.&#9618;.br&#9618;
Valid range
[first, last)
where
first
and
last
meet the requirements of an
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[1]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
Elements from the range
[first + max[0, distance(first, last) \- (pos \- begin()) \- reserve()], last)
will be inserted at the position
pos\&.&#9618;.br&#9618;
The number of
min[pos \- begin(), max[0, distance(first, last) \- reserve()]]
elements will be overwritten at the beginning of the
circular_buffer_space_optimized\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert

.sp

.nf
iterator rinsert(iterator pos, param_value_type item);
.fi

.sp
Insert an element before the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRrinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position before which the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
The
item
will be inserted before the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the last element will be overwritten\&. If the
circular_buffer_space_optimized
is full and the
pos
points to
end(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
Iterator to the inserted element or
end()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert

.sp

.nf
iterator rinsert(iterator pos, rvalue_type item);
.fi

.sp
Insert an element before the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRrinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position before which the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
The
item
will be inserted before the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the last element will be overwritten\&. If the
circular_buffer_space_optimized
is full and the
pos
points to
end(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
Iterator to the inserted element or
end()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert

.sp

.nf
iterator rinsert(iterator pos);
.fi

.sp
Insert an element before the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRrinsert(iterator, size_type, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator specifying the position before which the
item
will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
The
item
will be inserted before the position
pos\&.&#9618;.br&#9618;
If the
circular_buffer_space_optimized
is full, the last element will be overwritten\&. If the
circular_buffer_space_optimized
is full and the
pos
points to
end(), then the
item
will not be inserted\&. If the capacity is
0, nothing will be inserted\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
Iterator to the inserted element or
end()
if the
item
is not inserted\&. (See the
\fIEffect\fR\&.)
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T()
throws\&. Whatever
T::T(const T&)
throws or nothing if
T::T(T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert

.sp

.nf
void rinsert(iterator pos, size_type n, param_value_type item);
.fi

Insert n copies of the item before the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in min[capacity()\&.capacity(), size() + n])\&.
.PP \fBExample\fR. Consider a circular_buffer_space_optimized with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting 5 elements before the position p:&#9618;.br&#9618; &#9618;.br&#9618; rinsert(p, (size_t)5, 0);&#9618;.br&#9618; &#9618;.br&#9618; actually only 4 elements get inserted and elements 3 and 4 are overwritten\&. This is due to the fact the rinsert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |1|2|0|0|0|0|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|0|0|0|0|0|3|4|\&.
\fBSee Also:\fRrinsert(iterator, value_type), rinsert(iterator, InputIterator, InputIterator), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
item
.RS 4
The element whose copies will be inserted\&.
.RE
.PP
n
.RS 4
The number of
items the to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the
items will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.
.RE
.PP
Postconditions:
.RS 4
The number of
min[n, (end() \- pos) + reserve()]
elements will be inserted before the position
pos\&.&#9618;.br&#9618;
The number of
min[end() \- pos, max[0, n \- reserve()]]
elements will be overwritten at the end of the
circular_buffer_space_optimized\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert

.sp

.nf
template<typename InputIterator> 
  void rinsert(iterator pos, InputIterator first, InputIterator last);
.fi

Insert the range [first, last) before the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in [size() + std::distance(first, last)]; in min[capacity()\&.capacity(), size() + std::distance(first, last)] if the InputIterator is a \m[blue]\fBRandomAccessIterator\fR\m[]\&\s-2\u[2]\d\s+2)\&.
.PP \fBExample\fR. Consider a circular_buffer_space_optimized with the capacity of 6 and the size of 4\&. Its internal buffer may look like the one below\&.&#9618;.br&#9618; &#9618;.br&#9618; |1|2|3|4| | |&#9618;.br&#9618; p ___^&#9618;.br&#9618; &#9618;.br&#9618; After inserting a range of elements before the position p:&#9618;.br&#9618; &#9618;.br&#9618; int array[] = { 5, 6, 7, 8, 9 };&#9618;.br&#9618; insert(p, array, array + 5);&#9618;.br&#9618; &#9618;.br&#9618; actually only elements 5, 6, 7 and 8 from the specified range get inserted and elements 3 and 4 are overwritten\&. This is due to the fact the rinsert operation preserves the capacity\&. After insertion the internal buffer looks like this:&#9618;.br&#9618; &#9618;.br&#9618; |1|2|5|6|7|8|&#9618;.br&#9618; &#9618;.br&#9618; For comparison if the capacity would not be preserved the internal buffer would then result in |1|2|5|6|7|8|9|3|4|\&.
\fBSee Also:\fRrinsert(iterator, value_type), rinsert(iterator, size_type, value_type), insert(iterator, value_type), insert(iterator, size_type, value_type), insert(iterator, InputIterator, InputIterator)
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be inserted\&.
.RE
.PP
last
.RS 4
The end of the range to be inserted\&.
.RE
.PP
pos
.RS 4
An iterator specifying the position where the range will be inserted\&.
.RE
.RE
.PP
Requires:
.RS 4
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
or its end\&.&#9618;.br&#9618;
Valid range
[first, last)
where
first
and
last
meet the requirements of an
\m[blue]\fBInputIterator\fR\m[]\&\s-2\u[1]\d\s+2\&.
.RE
.PP
Postconditions:
.RS 4
Elements from the range
[first, last \- max[0, distance(first, last) \- (end() \- pos) \- reserve()])
will be inserted before the position
pos\&.&#9618;.br&#9618;
The number of
min[end() \- pos, max[0, distance(first, last) \- reserve()]]
elements will be overwritten at the end of the
circular_buffer\&.&#9618;.br&#9618;
(See
\fIExample\fR
for the explanation\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively increased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::T(const T&)
throws\&. Whatever
T::operator = (const T&)
throws\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" erase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: erase

.sp

.nf
iterator erase(iterator pos);
.fi

.sp
Remove an element at the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRerase(iterator, iterator), rerase(iterator), rerase(iterator, iterator), clear()
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator pointing at the element to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
(but not an
end())\&.
.RE
.PP
Postconditions:
.RS 4
The element at the position
pos
is removed\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively decreased\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
Iterator to the first element remaining beyond the removed element or
end()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::operator = (const T&)
throws or nothing if
T::operator = (T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" erase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: erase

.sp

.nf
iterator erase(iterator first, iterator last);
.fi

Erase the range [first, last)\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fRerase(iterator), rerase(iterator), rerase(iterator, iterator), clear()
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be removed\&.
.RE
.PP
last
.RS 4
The end of the range to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.
.RE
.PP
Postconditions:
.RS 4
The elements from the range
[first, last)
are removed\&. (If
first == last
nothing is removed\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively decreased\&.
.RE
.PP
Returns:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
Iterator to the first element remaining beyond the removed elements or
end()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::operator = (const T&)
throws or nothing if
T::operator = (T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" erase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: erase
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rerase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rerase

.sp

.nf
iterator rerase(iterator pos);
.fi

.sp
Remove an element at the specified position\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Basically there is no difference between
erase(iterator)
and this method\&. It is implemented only for consistency with the base
circular_buffer\&.
.sp .5v
.RE

\fBSee Also:\fRerase(iterator), erase(iterator, iterator), rerase(iterator, iterator), clear()
.PP
Parameters:
.RS 4
.PP
pos
.RS 4
An iterator pointing at the element to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
pos
is a valid iterator pointing to the
circular_buffer_space_optimized
(but not an
end())\&.&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively decreased\&.
.RE
.PP
Postconditions:
.RS 4
The element at the position
pos
is removed\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
Iterator to the first element remaining in front of the removed element or
begin()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::operator = (const T&)
throws or nothing if
T::operator = (T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" erase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: erase
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" rerase: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rerase

.sp

.nf
iterator rerase(iterator first, iterator last);
.fi

Erase the range [first, last)\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Basically there is no difference between
erase(iterator, iterator)
and this method\&. It is implemented only for consistency with the base
<circular_buffer\&.
.sp .5v
.RE

\fBSee Also:\fRerase(iterator), erase(iterator, iterator), rerase(iterator), clear()
.PP
Parameters:
.RS 4
.PP
first
.RS 4
The beginning of the range to be removed\&.
.RE
.PP
last
.RS 4
The end of the range to be removed\&.
.RE
.RE
.PP
Requires:
.RS 4
Valid range
[first, last)\&.
.RE
.PP
Postconditions:
.RS 4
The elements from the range
[first, last)
are removed\&. (If
first == last
nothing is removed\&.)&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively decreased\&.
.RE
.PP
Returns:
.RS 4
.\" begin: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: begin
Iterator to the first element remaining in front of the removed elements or
begin()
if no such element exists\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&. Whatever
T::operator = (const T&)
throws or nothing if
T::operator = (T&&)
is noexcept\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: end
.\" Linear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: Linear
.\" clear: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: clear

.sp

.nf
void clear();
.fi

.sp
Remove all stored elements from the space optimized circular buffer\&. 
.PP \fBException Safety\fR. Basic\&.
.PP \fBIterator Invalidation\fR. Invalidates all iterators pointing to the circular_buffer_space_optimized (except iterators equal to end())\&.
.PP \fBComplexity\fR. Linear (in the size of the circular_buffer_space_optimized)\&.
\fBSee Also:\fR~circular_buffer_space_optimized(), erase(iterator), erase(iterator, iterator), rerase(iterator), rerase(iterator, iterator)
.PP
Postconditions:
.RS 4
size() == 0&#9618;.br&#9618;
&#9618;.br&#9618;
The amount of allocated memory in the internal buffer may be predictively decreased\&.
.RE
.PP
Throws:
.RS 4
An allocation error if memory is exhausted (std::bad_alloc
if the standard allocator is used)\&.
.RE
.RE

.SS "circular_buffer_space_optimized private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" adjust_min_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: adjust_min_capacity

.sp

.nf
void adjust_min_capacity();
.fi

Adjust the amount of allocated memory\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
size_type ensure_reserve(size_type new_capacity, size_type buffer_size) const;
.fi

Ensure the reserve for possible growth up\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" check_low_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: check_low_capacity

.sp

.nf
void check_low_capacity(size_type n = 1);
.fi

Check for low capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" check_high_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: check_high_capacity

.sp

.nf
void check_high_capacity();
.fi

Check for high capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" reduce_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: reduce_capacity

.sp

.nf
void reduce_capacity(const true_type &);
.fi

Specialized method for reducing the capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" reduce_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: reduce_capacity

.sp

.nf
void reduce_capacity(const false_type &);
.fi

Specialized method for reducing the capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert

.sp

.nf
template<typename IntegralType> 
  void insert(const iterator & pos, IntegralType n, IntegralType item, 
              const true_type &);
.fi

Specialized insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" insert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: insert

.sp

.nf
template<typename Iterator> 
  void insert(const iterator & pos, Iterator first, Iterator last, 
              const false_type &);
.fi

Specialized insert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert

.sp

.nf
template<typename IntegralType> 
  void rinsert(const iterator & pos, IntegralType n, IntegralType item, 
               const true_type &);
.fi

Specialized rinsert method\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rinsert: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: rinsert

.sp

.nf
template<typename Iterator> 
  void rinsert(const iterator & pos, Iterator first, Iterator last, 
               const false_type &);
.fi

Specialized rinsert method\&. .RE

.SS "circular_buffer_space_optimized private static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" init_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: init_capacity

.sp

.nf
static size_type 
init_capacity(const capacity_type & capacity_ctrl, size_type n);
.fi

Determine the initial capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" init_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: init_capacity

.sp

.nf
template<typename IntegralType> 
  static size_type 
  init_capacity(const capacity_type & capacity_ctrl, IntegralType n, 
                IntegralType, const true_type &);
.fi

Specialized method for determining the initial capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" init_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: init_capacity

.sp

.nf
template<typename Iterator> 
  static size_type 
  init_capacity(const capacity_type & capacity_ctrl, Iterator first, 
                Iterator last, const false_type &);
.fi

Specialized method for determining the initial capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" init_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: init_capacity

.sp

.nf
template<typename InputIterator> 
  static size_type 
  init_capacity(const capacity_type & capacity_ctrl, InputIterator, 
                InputIterator, const std::input_iterator_tag &);
.fi

Specialized method for determining the initial capacity\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" init_capacity: Class template circular_buffer_space_optimized
.\" Class template circular_buffer_space_optimized: init_capacity

.sp

.nf
template<typename ForwardIterator> 
  static size_type 
  init_capacity(const capacity_type & capacity_ctrl, ForwardIterator first, 
                ForwardIterator last, const std::forward_iterator_tag &);
.fi

Specialized method for determining the initial capacity\&. .RE



    .PP
\fBJan Gaspar\fR

.RS 4
Author.
.RE

    20032004200520062007200820092010201120122013Jan Gaspar
    
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      
  