.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS ATTRIBUTE" 3 "" "" ""
.SH "NAME"
boost::log::attribute \- A base class for an attribute value factory\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/attributes/attribute\&.hpp>


class attribute {
public:
  // member classes/structs/unions

  // A base class for an attribute value factory\&.

  struct impl : public boost::intrusive_ref_counter< impl > {
    // construct/copy/destruct
    ~impl();

    // public member functions
    virtual attribute_value get_value() = 0;

    // public static functions
    static void * operator new(std::size_t);
    static void operator delete(void *, std::size_t) noexcept;
  };
  // construct/copy/destruct
  attribute() = default;
  attribute(attribute const &) noexcept;
  attribute(attribute &&) noexcept;
  explicit attribute(intrusive_ptr< impl >) noexcept;
  attribute & operator=(attribute const &) noexcept;
  attribute & operator=(attribute &&) noexcept;

  // public member functions
  explicit operator bool() const noexcept;
  bool operator!() const noexcept;
  attribute_value get_value() const;
  void swap(attribute &) noexcept;

  // protected member functions
  impl * get_impl() const noexcept;
  void set_impl(intrusive_ptr< impl >) noexcept;

  // friend functions
  template<typename T> friend T attribute_cast(attribute const &);
};
.fi
.SH "DESCRIPTION"
.PP
Every attribute is represented with a factory that is basically an attribute value generator\&. The sole purpose of an attribute is to return an actual value when requested\&. A simplest attribute can always return the same value that it stores internally, but more complex ones can perform a considerable amount of work to return a value, and the returned values may differ each time requested\&.
.PP
A word about thread safety\&. An attribute should be prepared to be requested a value from multiple threads concurrently\&.
.SS "attribute public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
attribute() = default;
.fi

.sp
Default constructor\&. Creates an empty attribute value factory, which is not usable until
set_impl
is called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
attribute(attribute const & that) noexcept;
.fi

.sp
Copy constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
attribute(attribute && that) noexcept;
.fi

.sp
Move constructor
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
explicit attribute(intrusive_ptr< impl > p) noexcept;
.fi

.sp
Initializing constructor
.sp

.PP
Parameters:
.RS 4
.PP
p
.RS 4
Pointer to the implementation\&. Must not be
NULL\&.
.RE
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
attribute & operator=(attribute const & that) noexcept;
.fi

.sp
Copy assignment
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
attribute & operator=(attribute && that) noexcept;
.fi

.sp
Move assignment
.RE

.SS "attribute public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit operator bool() const noexcept;
.fi

.sp
Verifies that the factory is not in empty state
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
bool operator!() const noexcept;
.fi

.sp
Verifies that the factory is in empty state
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
attribute_value get_value() const;
.fi

.sp

.PP
Returns:
.RS 4
The actual attribute value\&. It shall not return empty values (exceptions shall be used to indicate errors)\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void swap(attribute & that) noexcept;
.fi

.sp
The method swaps two factories (i\&.e\&. their implementations)\&.
.RE

.SS "attribute protected member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
impl * get_impl() const noexcept;
.fi

.sp

.PP
Returns:
.RS 4
The pointer to the implementation
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void set_impl(intrusive_ptr< impl > p) noexcept;
.fi

.sp
Sets the pointer to the factory implementation\&.
.sp

.PP
Parameters:
.RS 4
.PP
p
.RS 4
Pointer to the implementation\&. Must not be
NULL\&.
.RE
.RE
.RE

.SS "attribute friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename T> friend T attribute_cast(attribute const &);
.fi

.sp
The function casts one attribute factory to another
.RE


