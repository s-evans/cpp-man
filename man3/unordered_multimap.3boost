.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::unordered_multimap \- An unordered associative container that associates keys with another value\&. The same key can be stored multiple times\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/unordered_map\&.hpp>

template<typename Key, typename Mapped, typename Hash = boost::hash<Key>, 
         typename Pred = std::equal_to<Key>, 
         typename Alloc = std::allocator<std::pair<Key const, Mapped>> > 
class unordered_multimap {
public:
  // types
  typedef Key                                    key_type;            
  typedef std::pair<Key const, Mapped>           value_type;          
  typedef Mapped                                 mapped_type;         
  typedef Hash                                   hasher;              
  typedef Pred                                   key_equal;           
  typedef Alloc                                  allocator_type;      
  typedef typename allocator_type::pointer       pointer;             
  typedef typename allocator_type::const_pointer const_pointer;       
  typedef value_type&                            reference;           
  typedef value_type const&                      const_reference;     
  typedef \fIimplementation\fR\fI\-\fR\fIdefined\fR                 size_type;           
  typedef \fIimplementation\fR\fI\-\fR\fIdefined\fR                 difference_type;     
  typedef \fIimplementation\fR\fI\-\fR\fIdefined\fR                 iterator;            
  typedef \fIimplementation\fR\fI\-\fR\fIdefined\fR                 const_iterator;      
  typedef \fIimplementation\fR\fI\-\fR\fIdefined\fR                 local_iterator;      
  typedef \fIimplementation\fR\fI\-\fR\fIdefined\fR                 const_local_iterator;

  // construct/copy/destruct
  explicit unordered_multimap(size_type = \fIimplementation\fR\fI\-\fR\fIdefined\fR, 
                              hasher const& = hasher(), 
                              key_equal const& = key_equal(), 
                              allocator_type const& = allocator_type());
  template<typename InputIterator> 
    unordered_multimap(InputIterator, InputIterator, 
                       size_type = \fIimplementation\fR\fI\-\fR\fIdefined\fR, 
                       hasher const& = hasher(), 
                       key_equal const& = key_equal(), 
                       allocator_type const& = allocator_type());
  unordered_multimap(unordered_multimap const&);
  unordered_multimap(unordered_multimap &&);
  explicit unordered_multimap(Allocator const&);
  unordered_multimap(unordered_multimap const&, Allocator const&);
  ~unordered_multimap();
  unordered_multimap& operator=(unordered_multimap const&);
  unordered_multimap& operator=(unordered_multimap &&);
  allocator_type get_allocator() const;

  // size and capacity
  bool empty() const;
  size_type size() const;
  size_type max_size() const;

  // iterators
  iterator begin();
  const_iterator begin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cbegin() const;
  const_iterator cend() const;

  // modifiers
  template<typename\&.\&.\&. Args> iterator emplace(Args&&\&.\&.\&.);
  template<typename\&.\&.\&. Args> iterator emplace_hint(const_iterator, Args&&\&.\&.\&.);
  iterator insert(value_type const&);
  iterator insert(value_type&&);
  iterator insert(const_iterator, value_type const&);
  iterator insert(const_iterator, value_type&&);
  template<typename InputIterator> void insert(InputIterator, InputIterator);
  iterator erase(const_iterator);
  size_type erase(key_type const&);
  iterator erase(const_iterator, const_iterator);
  void quick_erase(const_iterator);
  void erase_return_void(const_iterator);
  void clear();
  void swap(unordered_multimap&);

  // observers
  hasher hash_function() const;
  key_equal key_eq() const;

  // lookup
  iterator find(key_type const&);
  const_iterator find(key_type const&) const;
  template<typename CompatibleKey, typename CompatibleHash, 
           typename CompatiblePredicate> 
    iterator find(CompatibleKey const&, CompatibleHash const&, 
                  CompatiblePredicate const&);
  template<typename CompatibleKey, typename CompatibleHash, 
           typename CompatiblePredicate> 
    const_iterator 
    find(CompatibleKey const&, CompatibleHash const&, 
         CompatiblePredicate const&) const;
  size_type count(key_type const&) const;
  std::pair<iterator, iterator> equal_range(key_type const&);
  std::pair<const_iterator, const_iterator> equal_range(key_type const&) const;

  // bucket interface
  size_type bucket_count() const;
  size_type max_bucket_count() const;
  size_type bucket_size(size_type) const;
  size_type bucket(key_type const&) const;
  local_iterator begin(size_type);
  const_local_iterator begin(size_type) const;
  local_iterator end(size_type);
  const_local_iterator end(size_type) const;
  const_local_iterator cbegin(size_type) const;
  const_local_iterator cend(size_type);

  // hash policy
  float load_factor() const;
  float max_load_factor() const;
  void max_load_factor(float);
  void rehash(size_type);
  void reserve(size_type);
};

// Equality Comparisons
template<typename Key, typename Mapped, typename Hash, typename Pred, 
         typename Alloc> 
  bool operator==(unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const&, 
                  unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const&);
template<typename Key, typename Mapped, typename Hash, typename Pred, 
         typename Alloc> 
  bool operator!=(unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const&, 
                  unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const&);

// swap
template<typename Key, typename Mapped, typename Hash, typename Pred, 
         typename Alloc> 
  void swap(unordered_multimap<Key, Mapped, Hash, Pred, Alloc>&, 
            unordered_multimap<Key, Mapped, Hash, Pred, Alloc>&);
.fi
.SH "DESCRIPTION"
.PP
\fBTemplate Parameters\fR
.TS
allbox tab(:);
l l
l l
l l
l l
l l.
T{
\fIKey\fR
T}:T{
Key must be Erasable from the container
                        (i\&.e\&. allocator_traits can destroy it)\&.
T}
T{
\fIMapped\fR
T}:T{
Mapped must be Erasable from the container
                        (i\&.e\&. allocator_traits can destroy it)\&.
T}
T{
\fIHash\fR
T}:T{
A unary function object type that acts a hash function for a Key\&. It takes a single argument of type Key and returns a value of type std::size_t\&.
T}
T{
\fIPred\fR
T}:T{
A binary function object that implements an equivalence relation on values of type Key\&.
                        A binary function object that induces an equivalence relation on values of type Key\&.
                        It takes two arguments of type Key and returns a value of type bool\&.
T}
T{
\fIAlloc\fR
T}:T{
An allocator whose value type is the same as the container\'s value type\&.
T}
.TE
.sp 1

.PP
The elements are organized into buckets\&. Keys with the same hash code are stored in the same bucket and elements with equivalent keys are stored next to each other\&.
.PP
The number of buckets can be automatically increased by a call to insert, or as the result of calling rehash\&.
.SS "unordered_multimap public types"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

typedef
Key
key_type;
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

typedef
std::pair<Key
const,
Mapped>
value_type;
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

typedef
Mapped
mapped_type;
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

typedef
Hash
hasher;
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

typedef
Pred
key_equal;
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

typedef
Alloc
allocator_type;
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

typedef
typename
allocator_type::pointer
pointer;
.sp

value_type*
if
allocator_type::pointer
is not defined\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

typedef
typename
allocator_type::const_pointer
const_pointer;
.sp

boost::pointer_to_other<pointer, value_type>::type
if
allocator_type::const_pointer
is not defined\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

typedef
value_type&
reference;
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

typedef
value_type
const&
const_reference;
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

typedef
\fIimplementation\fR\fI\-\fR\fIdefined\fR
size_type;
.sp
An unsigned integral type\&.
.sp
size_type can represent any non\-negative value of difference_type\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

typedef
\fIimplementation\fR\fI\-\fR\fIdefined\fR
difference_type;
.sp
A signed integral type\&.
.sp
Is identical to the difference type of iterator and const_iterator\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

typedef
\fIimplementation\fR\fI\-\fR\fIdefined\fR
iterator;
.sp
An iterator whose value type is value_type\&.
.sp
The iterator category is at least a forward iterator\&.
.sp
Convertible to const_iterator\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

typedef
\fIimplementation\fR\fI\-\fR\fIdefined\fR
const_iterator;
.sp
A constant iterator whose value type is value_type\&.
.sp
The iterator category is at least a forward iterator\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

typedef
\fIimplementation\fR\fI\-\fR\fIdefined\fR
local_iterator;
.sp
An iterator with the same value type, difference type and pointer and reference type as iterator\&.
.sp
A local_iterator object can be used to iterate through a single bucket\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

typedef
\fIimplementation\fR\fI\-\fR\fIdefined\fR
const_local_iterator;
.sp
A constant iterator with the same value type, difference type and pointer and reference type as const_iterator\&.
.sp
A const_local_iterator object can be used to iterate through a single bucket\&.
.RE

.SS "unordered_multimap public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit unordered_multimap(size_type n = \fIimplementation\fR\fI\-\fR\fIdefined\fR, 
                            hasher const& hf = hasher(), 
                            key_equal const& eq = key_equal(), 
                            allocator_type const& a = allocator_type());
.fi

.sp
Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1\&.0\&.
.PP
Postconditions:
.RS 4
size() == 0.RE
.PP
Requires:
.RS 4
If the defaults are used,
hasher,
key_equal
and
allocator_type
need to be
DefaultConstructible\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  unordered_multimap(InputIterator f, InputIterator l, 
                     size_type n = \fIimplementation\fR\fI\-\fR\fIdefined\fR, 
                     hasher const& hf = hasher(), 
                     key_equal const& eq = key_equal(), 
                     allocator_type const& a = allocator_type());
.fi

.sp
Constructs an empty container with at least n buckets, using hf as the hash function, eq as the key equality predicate, a as the allocator and a maximum load factor of 1\&.0 and inserts the elements from [f, l) into it\&.
.PP
Requires:
.RS 4
If the defaults are used,
hasher,
key_equal
and
allocator_type
need to be
DefaultConstructible\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
unordered_multimap(unordered_multimap const&);
.fi

.sp
The copy constructor\&. Copies the contained elements, hash function, predicate, maximum load factor and allocator\&.
.sp
If
Allocator::select_on_container_copy_construction
exists and has the right signature, the allocator will be constructed from its result\&.
.PP
Requires:
.RS 4
value_type
is copy constructible
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
unordered_multimap(unordered_multimap &&);
.fi

.sp
The move constructor\&.
.PP
Notes:
.RS 4
This is implemented using Boost\&.Move\&.
.RE
.PP
Requires:
.RS 4

value_type
is move constructible\&.
.sp
On compilers without rvalue reference support the emulation does not support moving without calling
boost::move
if
value_type
is not copyable\&. So, for example, you can\'t return the container from a function\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
explicit unordered_multimap(Allocator const& a);
.fi

.sp
Constructs an empty container, using allocator
a\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
unordered_multimap(unordered_multimap const& x, Allocator const& a);
.fi

.sp
Constructs an container, copying
x\'s contained elements, hash function, predicate, maximum load factor, but using allocator
a\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
~unordered_multimap();
.fi

.PP
Notes:
.RS 4
The destructor is applied to every element, and all memory is deallocated
.RE
.RE

.PP

.sp

.nf
unordered_multimap& operator=(unordered_multimap const&);
.fi

.PP
The assignment operator\&. Copies the contained elements, hash function, predicate and maximum load factor but not the allocator\&.
.PP
If
Alloc::propagate_on_container_copy_assignment
exists and
Alloc::propagate_on_container_copy_assignment::value
is true, the allocator is overwritten, if not the copied elements are created using the existing allocator\&.
.PP
Requires:
.RS 4
value_type
is copy constructible
.RE
.PP

.sp

.nf
unordered_multimap& operator=(unordered_multimap &&);
.fi

.PP
The move assignment operator\&.
.PP
If
Alloc::propagate_on_container_move_assignment
exists and
Alloc::propagate_on_container_move_assignment::value
is true, the allocator is overwritten, if not the moved elements are created using the existing allocator\&.
.PP
Notes:
.RS 4
On compilers without rvalue references, this is emulated using Boost\&.Move\&. Note that on some compilers the copy assignment operator may be used in some circumstances\&.
.RE
.PP
Requires:
.RS 4

value_type
is move constructible\&.
.RE
.PP

.sp

.nf
allocator_type get_allocator() const;
.fi

.SS "unordered_multimap size and capacity"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.PP
Returns:
.RS 4
size() == 0.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
size_type size() const;
.fi

.PP
Returns:
.RS 4
std::distance(begin(), end()).RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
size_type max_size() const;
.fi

.PP
Returns:
.RS 4
size() of the largest possible container\&.
              .RE
.RE

.SS "unordered_multimap iterators"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
iterator begin();
const_iterator begin() const;
.fi

.PP
Returns:
.RS 4
An iterator referring to the first element of the container, or if the container is empty the past\-the\-end value for the container\&.
              .RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
iterator end();
const_iterator end() const;
.fi

.PP
Returns:
.RS 4
An iterator which refers to the past\-the\-end value for the container\&.
              .RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
const_iterator cbegin() const;
.fi

.PP
Returns:
.RS 4
A constant iterator referring to the first element of the container, or if the container is empty the past\-the\-end value for the container\&.
              .RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
const_iterator cend() const;
.fi

.PP
Returns:
.RS 4
A constant iterator which refers to the past\-the\-end value for the container\&.
              .RE
.RE

.SS "unordered_multimap modifiers"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename\&.\&.\&. Args> iterator emplace(Args&&\&.\&.\&. args);
.fi

.sp
Inserts an object, constructed with the arguments
args, in the container\&.
.PP
Requires:
.RS 4
value_type
is
EmplaceConstructible
into
X
from
args\&.
.RE
.PP
Returns:
.RS 4
An iterator pointing to the inserted element\&.
.RE
.PP
Throws:
.RS 4
If an exception is thrown by an operation other than a call to
hasher
the function has no effect\&.
.RE
.PP
Notes:
.RS 4
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor\&.
.sp
Pointers and references to elements are never invalidated\&.
.sp
If the compiler doesn\'t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics\&.
.sp
Since existing
std::pair
implementations don\'t support
std::piecewise_construct
this emulates it, but using
boost::unordered::piecewise_construct\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename\&.\&.\&. Args> 
  iterator emplace_hint(const_iterator hint, Args&&\&.\&.\&. args);
.fi

.sp
Inserts an object, constructed with the arguments
args, in the container\&.
.sp
hint
is a suggestion to where the element should be inserted\&.
.PP
Requires:
.RS 4
value_type
is
EmplaceConstructible
into
X
from
args\&.
.RE
.PP
Returns:
.RS 4
An iterator pointing to the inserted element\&.
.RE
.PP
Throws:
.RS 4
If an exception is thrown by an operation other than a call to
hasher
the function has no effect\&.
.RE
.PP
Notes:
.RS 4
The standard is fairly vague on the meaning of the hint\&. But the only practical way to use it, and the only way that Boost\&.Unordered supports is to point to an existing element with the same key\&.
.sp
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor\&.
.sp
Pointers and references to elements are never invalidated\&.
.sp
If the compiler doesn\'t support variadic template arguments or rvalue references, this is emulated for up to 10 arguments, with no support for rvalue references or move semantics\&.
.sp
Since existing
std::pair
implementations don\'t support
std::piecewise_construct
this emulates it, but using
boost::unordered::piecewise_construct\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
iterator insert(value_type const& obj);
.fi

.sp
Inserts
obj
in the container\&.
.PP
Requires:
.RS 4
value_type
is
CopyInsertable\&.
.RE
.PP
Returns:
.RS 4
An iterator pointing to the inserted element\&.
.RE
.PP
Throws:
.RS 4
If an exception is thrown by an operation other than a call to
hasher
the function has no effect\&.
.RE
.PP
Notes:
.RS 4
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor\&.
.sp
Pointers and references to elements are never invalidated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
iterator insert(value_type&& obj);
.fi

.sp
Inserts
obj
in the container\&.
.PP
Requires:
.RS 4
value_type
is
MoveInsertable\&.
.RE
.PP
Returns:
.RS 4
An iterator pointing to the inserted element\&.
.RE
.PP
Throws:
.RS 4
If an exception is thrown by an operation other than a call to
hasher
the function has no effect\&.
.RE
.PP
Notes:
.RS 4
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor\&.
.sp
Pointers and references to elements are never invalidated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
iterator insert(const_iterator hint, value_type const& obj);
.fi

.sp
Inserts
obj
in the container\&.
.sp
hint is a suggestion to where the element should be inserted\&.
.PP
Requires:
.RS 4
value_type
is
CopyInsertable\&.
.RE
.PP
Returns:
.RS 4
An iterator pointing to the inserted element\&.
.RE
.PP
Throws:
.RS 4
If an exception is thrown by an operation other than a call to
hasher
the function has no effect\&.
.RE
.PP
Notes:
.RS 4
The standard is fairly vague on the meaning of the hint\&. But the only practical way to use it, and the only way that Boost\&.Unordered supports is to point to an existing element with the same key\&.
.sp
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor\&.
.sp
Pointers and references to elements are never invalidated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
iterator insert(const_iterator hint, value_type&& obj);
.fi

.sp
Inserts
obj
in the container\&.
.sp
hint is a suggestion to where the element should be inserted\&.
.PP
Requires:
.RS 4
value_type
is
MoveInsertable\&.
.RE
.PP
Returns:
.RS 4
An iterator pointing to the inserted element\&.
.RE
.PP
Throws:
.RS 4
If an exception is thrown by an operation other than a call to
hasher
the function has no effect\&.
.RE
.PP
Notes:
.RS 4
The standard is fairly vague on the meaning of the hint\&. But the only practical way to use it, and the only way that Boost\&.Unordered supports is to point to an existing element with the same key\&.
.sp
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor\&.
.sp
Pointers and references to elements are never invalidated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  void insert(InputIterator first, InputIterator last);
.fi

.sp
Inserts a range of elements into the container\&. Elements are inserted if and only if there is no element in the container with an equivalent key\&.
.PP
Requires:
.RS 4
value_type
is
EmplaceConstructible
into
X
from
*first\&.
.RE
.PP
Throws:
.RS 4
When inserting a single element, if an exception is thrown by an operation other than a call to
hasher
the function has no effect\&.
.RE
.PP
Notes:
.RS 4
Can invalidate iterators, but only if the insert causes the load factor to be greater to or equal to the maximum load factor\&.
.sp
Pointers and references to elements are never invalidated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
iterator erase(const_iterator position);
.fi

.sp
Erase the element pointed to by
position\&.
.PP
Returns:
.RS 4
The iterator following
position
before the erasure\&.
.RE
.PP
Throws:
.RS 4
Only throws an exception if it is thrown by
hasher
or
key_equal\&.
.RE
.PP
Notes:
.RS 4
In older versions this could be inefficient because it had to search through several buckets to find the position of the returned iterator\&. The data structure has been changed so that this is no longer the case, and the alternative erase methods have been deprecated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
size_type erase(key_type const& k);
.fi

.sp
Erase all elements with key equivalent to
k\&.
.PP
Returns:
.RS 4
The number of elements erased\&.
.RE
.PP
Throws:
.RS 4
Only throws an exception if it is thrown by
hasher
or
key_equal\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

.sp
Erases the elements in the range from
first
to
last\&.
.PP
Returns:
.RS 4
The iterator following the erased elements \- i\&.e\&.
last\&.
.RE
.PP
Throws:
.RS 4
Only throws an exception if it is thrown by
hasher
or
key_equal\&.
.sp
In this implementation, this overload doesn\'t call either function object\'s methods so it is no throw, but this might not be true in other implementations\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
void quick_erase(const_iterator position);
.fi

.sp
Erase the element pointed to by
position\&.
.PP
Throws:
.RS 4
Only throws an exception if it is thrown by
hasher
or
key_equal\&.
.sp
In this implementation, this overload doesn\'t call either function object\'s methods so it is no throw, but this might not be true in other implementations\&.
.RE
.PP
Notes:
.RS 4
This method was implemented because returning an iterator to the next element from
erase
was expensive, but the container has been redesigned so that is no longer the case\&. So this method is now deprecated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
void erase_return_void(const_iterator position);
.fi

.sp
Erase the element pointed to by
position\&.
.PP
Throws:
.RS 4
Only throws an exception if it is thrown by
hasher
or
key_equal\&.
.sp
In this implementation, this overload doesn\'t call either function object\'s methods so it is no throw, but this might not be true in other implementations\&.
.RE
.PP
Notes:
.RS 4
This method was implemented because returning an iterator to the next element from
erase
was expensive, but the container has been redesigned so that is no longer the case\&. So this method is now deprecated\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
void clear();
.fi

.sp
Erases all elements in the container\&.
.PP
Postconditions:
.RS 4
size() == 0
.RE
.PP
Throws:
.RS 4
Never throws an exception\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
void swap(unordered_multimap&);
.fi

.sp
Swaps the contents of the container with the parameter\&.
.sp
If
Allocator::propagate_on_container_swap
is declared and
Allocator::propagate_on_container_swap::value
is true then the containers\' allocators are swapped\&. Otherwise, swapping with unequal allocators results in undefined behavior\&.
.PP
Throws:
.RS 4
Doesn\'t throw an exception unless it is thrown by the copy constructor or copy assignment operator of
key_equal
or
hasher\&.
.RE
.PP
Notes:
.RS 4
The exception specifications aren\'t quite the same as the C++11 standard, as the equality predieate and hash function are swapped using their copy constructors\&.
.RE
.RE

.SS "unordered_multimap observers"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
hasher hash_function() const;
.fi

.PP
Returns:
.RS 4
The container\'s hash function\&.
              .RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
key_equal key_eq() const;
.fi

.PP
Returns:
.RS 4
The container\'s key equality predicate\&.
              .RE
.RE

.SS "unordered_multimap lookup"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
iterator find(key_type const& k);
const_iterator find(key_type const& k) const;
template<typename CompatibleKey, typename CompatibleHash, 
         typename CompatiblePredicate> 
  iterator find(CompatibleKey const& k, CompatibleHash const& hash, 
                CompatiblePredicate const& eq);
template<typename CompatibleKey, typename CompatibleHash, 
         typename CompatiblePredicate> 
  const_iterator 
  find(CompatibleKey const& k, CompatibleHash const& hash, 
       CompatiblePredicate const& eq) const;
.fi

.PP
Returns:
.RS 4
An iterator pointing to an element with key equivalent to
k, or
b\&.end()
if no such element exists\&.
.RE
.PP
Notes:
.RS 4
The templated overloads are a non\-standard extensions which allows you to use a compatible hash function and equality predicate for a key of a different type in order to avoid an expensive type cast\&. In general, its use is not encouraged\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
size_type count(key_type const& k) const;
.fi

.PP
Returns:
.RS 4
The number of elements with key equivalent to
k\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
std::pair<iterator, iterator> equal_range(key_type const& k);
std::pair<const_iterator, const_iterator> equal_range(key_type const& k) const;
.fi

.PP
Returns:
.RS 4
A range containing all elements with key equivalent to
k\&. If the container doesn\'t container any such elements, returns
std::make_pair(b\&.end(),b\&.end())\&.
.RE
.RE

.SS "unordered_multimap bucket interface"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
size_type bucket_count() const;
.fi

.PP
Returns:
.RS 4
The number of buckets\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
size_type max_bucket_count() const;
.fi

.PP
Returns:
.RS 4
An upper bound on the number of buckets\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
size_type bucket_size(size_type n) const;
.fi

.PP
Requires:
.RS 4
n < bucket_count()
.RE
.PP
Returns:
.RS 4
The number of elements in bucket
n\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
size_type bucket(key_type const& k) const;
.fi

.PP
Returns:
.RS 4
The index of the bucket which would contain an element with key
k\&.
.RE
.PP
Postconditions:
.RS 4
The return value is less than
bucket_count()
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
local_iterator begin(size_type n);
const_local_iterator begin(size_type n) const;
.fi

.PP
Requires:
.RS 4
n
shall be in the range
[0, bucket_count())\&.
.RE
.PP
Returns:
.RS 4
A local iterator pointing the first element in the bucket with index
n\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
local_iterator end(size_type n);
const_local_iterator end(size_type n) const;
.fi

.PP
Requires:
.RS 4
n
shall be in the range
[0, bucket_count())\&.
.RE
.PP
Returns:
.RS 4
A local iterator pointing the \'one past the end\' element in the bucket with index
n\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
const_local_iterator cbegin(size_type n) const;
.fi

.PP
Requires:
.RS 4
n
shall be in the range
[0, bucket_count())\&.
.RE
.PP
Returns:
.RS 4
A constant local iterator pointing the first element in the bucket with index
n\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
const_local_iterator cend(size_type n);
.fi

.PP
Requires:
.RS 4
n
shall be in the range
[0, bucket_count())\&.
.RE
.PP
Returns:
.RS 4
A constant local iterator pointing the \'one past the end\' element in the bucket with index
n\&.
.RE
.RE

.SS "unordered_multimap hash policy"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
float load_factor() const;
.fi

.PP
Returns:
.RS 4
The average number of elements per bucket\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
float max_load_factor() const;
.fi

.PP
Returns:
.RS 4
Returns the current maximum load factor\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void max_load_factor(float z);
.fi

.PP
Effects:
.RS 4
Changes the container\'s maximum load factor, using
z
as a hint\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void rehash(size_type n);
.fi

.sp
Changes the number of buckets so that there at least
n
buckets, and so that the load factor is less than the maximum load factor\&.
.sp
Invalidates iterators, and changes the order of elements\&. Pointers and references to elements are not invalidated\&.
.PP
Throws:
.RS 4
The function has no effect if an exception is thrown, unless it is thrown by the container\'s hash function or comparison function\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void reserve(size_type n);
.fi

.sp
Invalidates iterators, and changes the order of elements\&. Pointers and references to elements are not invalidated\&.
.PP
Throws:
.RS 4
The function has no effect if an exception is thrown, unless it is thrown by the container\'s hash function or comparison function\&.
.RE
.RE

.SS "unordered_multimap Equality Comparisons"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Key, typename Mapped, typename Hash, typename Pred, 
         typename Alloc> 
  bool operator==(unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const& x, 
                  unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const& y);
.fi

.sp
Return
true
if
x\&.size() == y\&.size
and for every equivalent key group in
x, there is a group in
y
for the same key, which is a permutation (using
operator==
to compare the value types)\&.
.PP
Notes:
.RS 4
The behavior of this function was changed to match the C++11 standard in Boost 1\&.48\&.
.sp
Behavior is undefined if the two containers don\'t have equivalent equality predicates\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Key, typename Mapped, typename Hash, typename Pred, 
         typename Alloc> 
  bool operator!=(unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const& x, 
                  unordered_multimap<Key, Mapped, Hash, Pred, Alloc> const& y);
.fi

.sp
Return
false
if
x\&.size() == y\&.size
and for every equivalent key group in
x, there is a group in
y
for the same key, which is a permutation (using
operator==
to compare the value types)\&.
.PP
Notes:
.RS 4
The behavior of this function was changed to match the C++11 standard in Boost 1\&.48\&.
.sp
Behavior is undefined if the two containers don\'t have equivalent equality predicates\&.
.RE
.RE

.SS "unordered_multimap swap"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Key, typename Mapped, typename Hash, typename Pred, 
         typename Alloc> 
  void swap(unordered_multimap<Key, Mapped, Hash, Pred, Alloc>& x, 
            unordered_multimap<Key, Mapped, Hash, Pred, Alloc>& y);
.fi

.sp
Swaps the contents of
x
and
y\&.
.sp
If
Allocator::propagate_on_container_swap
is declared and
Allocator::propagate_on_container_swap::value
is true then the containers\' allocators are swapped\&. Otherwise, swapping with unequal allocators results in undefined behavior\&.
.PP
Effects:
.RS 4
x\&.swap(y)
.RE
.PP
Throws:
.RS 4
Doesn\'t throw an exception unless it is thrown by the copy constructor or copy assignment operator of
key_equal
or
hasher\&.
.RE
.PP
Notes:
.RS 4
The exception specifications aren\'t quite the same as the C++11 standard, as the equality predieate and hash function are swapped using their copy constructors\&.
.RE
.RE


