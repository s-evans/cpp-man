.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TYPE_INFO_W" 3 "" "" ""
.SH "NAME"
boost::log::type_info_wrapper \- A simple std::type_info wrapper that implements value semantic for type information objects\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/log/utility/type_info_wrapper\&.hpp>


class type_info_wrapper {
public:
  // construct/copy/destruct
  type_info_wrapper() noexcept;
  type_info_wrapper(type_info_wrapper const &) noexcept;
  type_info_wrapper(std::type_info const &) noexcept;

  // public member functions
  explicit operator bool() const noexcept;
  std::type_info const & get() const noexcept;
  void swap(type_info_wrapper &) noexcept;
  std::string pretty_name() const;
  bool operator!() const noexcept;
  bool operator==(type_info_wrapper const &) const noexcept;
  bool operator<(type_info_wrapper const &) const noexcept;
};
.fi
.SH "DESCRIPTION"
.PP
The type info wrapper is very useful for storing type information objects in containers, as a key or value\&. It also provides a number of useful features, such as default construction and assignment support, an empty state and extended support for human\-friendly type names\&.
.SS "type_info_wrapper public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
type_info_wrapper() noexcept;
.fi

.sp
Default constructor
.sp

.PP
Postconditions:
.RS 4
!*this == true
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
type_info_wrapper(type_info_wrapper const & that) noexcept;
.fi

.sp
Copy constructor
.sp

.PP
Parameters:
.RS 4
.PP
that
.RS 4
Source type info wrapper to copy from
.RE
.RE
.PP
Postconditions:
.RS 4
*this == that
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
type_info_wrapper(std::type_info const & that) noexcept;
.fi

.sp
Conversion constructor
.sp

.PP
Parameters:
.RS 4
.PP
that
.RS 4
Type info object to be wrapped
.RE
.RE
.PP
Postconditions:
.RS 4
*this == that && !!*this
.RE
.RE

.SS "type_info_wrapper public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit operator bool() const noexcept;
.fi

.sp

.PP
Returns:
.RS 4
true
if the type info wrapper was initialized with a particular type,
false
if the wrapper was default\-constructed and not yet initialized
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
std::type_info const & get() const noexcept;
.fi

.sp
Stored type info getter
.sp

.PP
Requires:
.RS 4
!!*this
.RE
.PP
Returns:
.RS 4
Constant reference to the wrapped type info object
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void swap(type_info_wrapper & that) noexcept;
.fi

.sp
Swaps two instances of the wrapper
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
std::string pretty_name() const;
.fi

.sp
The method returns the contained type name string in a possibly more readable format than
get()\&.name()
.sp

.PP
Requires:
.RS 4
!!*this
.RE
.PP
Returns:
.RS 4
Type name string
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool operator!() const noexcept;
.fi

.sp

.PP
Returns:
.RS 4
false
if the type info wrapper was initialized with a particular type,
true
if the wrapper was default\-constructed and not yet initialized
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
bool operator==(type_info_wrapper const & that) const noexcept;
.fi

.sp
Equality comparison
.sp

.PP
Parameters:
.RS 4
.PP
that
.RS 4
Comparand
.RE
.RE
.PP
Returns:
.RS 4
If either this object or comparand is in empty state and the other is not, the result is
false\&. If both arguments are empty, the result is
true\&. If both arguments are not empty, the result is
true
if this object wraps the same type as the comparand and
false
otherwise\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
bool operator<(type_info_wrapper const & that) const noexcept;
.fi

.sp
Ordering operator
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
The results of this operator are only consistent within a single run of application\&. The result may change for the same types after rebuilding or even restarting the application\&.
.sp .5v
.RE

.PP
Parameters:
.RS 4
.PP
that
.RS 4
Comparand
.RE
.RE
.PP
Requires:
.RS 4
!!*this && !!that
.RE
.PP
Returns:
.RS 4
true
if this object wraps type info object that is ordered before the type info object in the comparand,
false
otherwise
.RE
.RE


