.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::move_iterator
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/move/iterator\&.hpp>

template<typename It> 
class move_iterator {
public:
  // types
  typedef It                                                                  iterator_type;    
  typedef boost::movelib::iterator_traits< iterator_type >::value_type        value_type;       
  typedef value_type &&                                                       reference;        
  typedef It                                                                  pointer;          
  typedef boost::movelib::iterator_traits< iterator_type >::difference_type   difference_type;  
  typedef boost::movelib::iterator_traits< iterator_type >::iterator_category iterator_category;

  // construct/copy/destruct
  move_iterator();
  explicit move_iterator(It);
  template<typename U> move_iterator(const move_iterator< U > &);

  // public member functions
  iterator_type base() const;
  reference operator*() const;
  pointer operator\->() const;
  move_iterator & operator++();
  move_iterator< iterator_type > operator++(int);
  move_iterator & operator\-\-();
  move_iterator< iterator_type > operator\-\-(int);
  move_iterator< iterator_type > operator+(difference_type) const;
  move_iterator & operator+=(difference_type);
  move_iterator< iterator_type > operator\-(difference_type) const;
  move_iterator & operator\-=(difference_type);
  reference operator[](difference_type) const;
};
.fi
.SH "DESCRIPTION"
.PP
Class template
move_iterator
is an iterator adaptor with the same behavior as the underlying iterator except that its dereference operator implicitly converts the value returned by the underlying iterator\'s dereference operator to an rvalue reference\&. Some generic algorithms can be called with move iterators to replace copying with moving\&.
.SS "move_iterator public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
move_iterator();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit move_iterator(It i);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename U> move_iterator(const move_iterator< U > & u);
.fi

.RE

.SS "move_iterator public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
iterator_type base() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
reference operator*() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
pointer operator\->() const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
move_iterator & operator++();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
move_iterator< iterator_type > operator++(int);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
move_iterator & operator\-\-();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
move_iterator< iterator_type > operator\-\-(int);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
move_iterator< iterator_type > operator+(difference_type n) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
move_iterator & operator+=(difference_type n);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
move_iterator< iterator_type > operator\-(difference_type n) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
move_iterator & operator\-=(difference_type n);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
reference operator[](difference_type n) const;
.fi

.RE


