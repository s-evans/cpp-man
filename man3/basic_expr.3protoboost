.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::proto::basic_expr \- Simplified representation of a node in an expression tree\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/proto/expr\&.hpp>

template<typename Tag, typename Args, long Arity = Args::arity> 
struct basic_expr {
  // types
  typedef Tag                         proto_tag;         
  typedef Args                        proto_args;        
  typedef mpl::long_< Arity >         proto_arity;       
  typedef proto::basic_default_domain proto_domain;      
  typedef basic_expr                  proto_grammar;     
  typedef basic_expr                  proto_base_expr;   
  typedef basic_expr                  proto_derived_expr;
  typedef typename Args::child\fIN\fR       proto_childN;        // For each \fIN\fR in \fI[0,max(Arity,1))\fR\&.

  // public static functions
  template<typename\&.\&.\&. A> static basic_expr const make(A const &\&.\&.\&.);

  // public member functions
  basic_expr & proto_base();
  basic_expr const & proto_base() const;
};
.fi
.SH "DESCRIPTION"
.PP

proto::basic_expr<>
is a node in an expression template tree\&. It is a container for its child sub\-trees\&. It also serves as the terminal nodes of the tree\&.
.PP

Tag
is type that represents the operation encoded by this expression\&. It is typically one of the structs in the
boost::proto::tag
namespace, but it doesn\'t have to be\&. If
Arity
is 0 then this
expr<>
type represents a leaf in the expression tree\&.
.PP

Args
is a list of types representing the children of this expression\&. It is an instantiation of one of
proto::list1<>,
proto::list2<>, etc\&. The child types must all themselves be either
proto::expr<>
or
proto::basic_expr<>&
(or extensions thereof via
proto::extends<>
or
BOOST_PROTO_EXTENDS()), unless
Arity
is 0, in which case
Args
must be
proto::term<T>, where
T
can be any type\&.
.PP

proto::basic_expr<>
is a valid Fusion random\-access sequence, where the elements of the sequence are the child expressions\&.
.SS "basic_expr public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename\&.\&.\&. A> static basic_expr const make(A const &\&.\&.\&. a);
.fi

.PP
Requires:
.RS 4
The number of supplied arguments must be
max(Arity,1)\&.
.RE
.PP
Returns:
.RS 4
A new
basic_expr
object initialized with the specified arguments\&.
.RE
.RE

.SS "basic_expr public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
basic_expr & proto_base();
.fi

.PP
Returns:
.RS 4

*this
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
basic_expr const & proto_base() const;
.fi

.sp
This is an overloaded member function, provided for convenience\&. It differs from the above function only in what argument(s) it accepts\&.
.RE


