.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE" 3 "" "" ""
.SH "NAME"
boost::intrusive::splay_multiset
.SH "SYNOPSIS"
.\" value_type: Class template splay_multiset
.\" Class template splay_multiset: value_type
.\" value_traits: Class template splay_multiset
.\" Class template splay_multiset: value_traits
.\" value_compare: Class template splay_multiset
.\" Class template splay_multiset: value_compare
.\" upper_bound: Class template splay_multiset
.\" Class template splay_multiset: upper_bound
.\" unlink_leftmost_without_rebalance: Class template splay_multiset
.\" Class template splay_multiset: unlink_leftmost_without_rebalance
.\" swap: Class template splay_multiset
.\" Class template splay_multiset: swap
.\" splay_up: Class template splay_multiset
.\" Class template splay_multiset: splay_up
.\" splay_down: Class template splay_multiset
.\" Class template splay_multiset: splay_down
.\" size_type: Class template splay_multiset
.\" Class template splay_multiset: size_type
.\" size: Class template splay_multiset
.\" Class template splay_multiset: size
.\" s_iterator_to: Class template splay_multiset
.\" Class template splay_multiset: s_iterator_to
.\" reverse_iterator: Class template splay_multiset
.\" Class template splay_multiset: reverse_iterator
.\" replace_node: Class template splay_multiset
.\" Class template splay_multiset: replace_node
.\" rend: Class template splay_multiset
.\" Class template splay_multiset: rend
.\" remove_node: Class template splay_multiset
.\" Class template splay_multiset: remove_node
.\" reference: Class template splay_multiset
.\" Class template splay_multiset: reference
.\" rebalance_subtree: Class template splay_multiset
.\" Class template splay_multiset: rebalance_subtree
.\" rebalance: Class template splay_multiset
.\" Class template splay_multiset: rebalance
.\" rbegin: Class template splay_multiset
.\" Class template splay_multiset: rbegin
.\" push_front: Class template splay_multiset
.\" Class template splay_multiset: push_front
.\" push_back: Class template splay_multiset
.\" Class template splay_multiset: push_back
.\" pointer: Class template splay_multiset
.\" Class template splay_multiset: pointer
.\" node_traits: Class template splay_multiset
.\" Class template splay_multiset: node_traits
.\" node_ptr: Class template splay_multiset
.\" Class template splay_multiset: node_ptr
.\" node_algorithms: Class template splay_multiset
.\" Class template splay_multiset: node_algorithms
.\" node: Class template splay_multiset
.\" Class template splay_multiset: node
.\" lower_bound: Class template splay_multiset
.\" Class template splay_multiset: lower_bound
.\" key_type: Class template splay_multiset
.\" Class template splay_multiset: key_type
.\" key_of_value: Class template splay_multiset
.\" Class template splay_multiset: key_of_value
.\" key_compare: Class template splay_multiset
.\" Class template splay_multiset: key_compare
.\" iterator_to: Class template splay_multiset
.\" Class template splay_multiset: iterator_to
.\" iterator: Class template splay_multiset
.\" Class template splay_multiset: iterator
.\" insert_commit_data: Class template splay_multiset
.\" Class template splay_multiset: insert_commit_data
.\" insert_before: Class template splay_multiset
.\" Class template splay_multiset: insert_before
.\" insert: Class template splay_multiset
.\" Class template splay_multiset: insert
.\" init_node: Class template splay_multiset
.\" Class template splay_multiset: init_node
.\" find: Class template splay_multiset
.\" Class template splay_multiset: find
.\" erase_and_dispose: Class template splay_multiset
.\" Class template splay_multiset: erase_and_dispose
.\" erase: Class template splay_multiset
.\" Class template splay_multiset: erase
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" difference_type: Class template splay_multiset
.\" Class template splay_multiset: difference_type
.\" count: Class template splay_multiset
.\" Class template splay_multiset: count
.\" container_from_iterator: Class template splay_multiset
.\" Class template splay_multiset: container_from_iterator
.\" container_from_end_iterator: Class template splay_multiset
.\" Class template splay_multiset: container_from_end_iterator
.\" const_reverse_iterator: Class template splay_multiset
.\" Class template splay_multiset: const_reverse_iterator
.\" const_reference: Class template splay_multiset
.\" Class template splay_multiset: const_reference
.\" const_pointer: Class template splay_multiset
.\" Class template splay_multiset: const_pointer
.\" const_node_ptr: Class template splay_multiset
.\" Class template splay_multiset: const_node_ptr
.\" const_iterator: Class template splay_multiset
.\" Class template splay_multiset: const_iterator
.\" clone_from: Class template splay_multiset
.\" Class template splay_multiset: clone_from
.\" clear_and_dispose: Class template splay_multiset
.\" Class template splay_multiset: clear_and_dispose
.\" clear: Class template splay_multiset
.\" Class template splay_multiset: clear
.\" cend: Class template splay_multiset
.\" Class template splay_multiset: cend
.\" cbegin: Class template splay_multiset
.\" Class template splay_multiset: cbegin
.\" bounded_range: Class template splay_multiset
.\" Class template splay_multiset: bounded_range
.\" begin: Class template splay_multiset
.\" Class template splay_multiset: begin

.sp
.nf
// In header: <boost/intrusive/splay_set\&.hpp>

template<typename T, class\&.\&.\&. Options> 
class splay_multiset {
public:
  // types
  typedef implementation_defined::value_type             value_type;            
  typedef implementation_defined::key_type               key_type;              
  typedef implementation_defined::key_of_value           key_of_value;          
  typedef implementation_defined::value_traits           value_traits;          
  typedef implementation_defined::pointer                pointer;               
  typedef implementation_defined::const_pointer          const_pointer;         
  typedef implementation_defined::reference              reference;             
  typedef implementation_defined::const_reference        const_reference;       
  typedef implementation_defined::difference_type        difference_type;       
  typedef implementation_defined::size_type              size_type;             
  typedef implementation_defined::value_compare          value_compare;         
  typedef implementation_defined::key_compare            key_compare;           
  typedef implementation_defined::iterator               iterator;              
  typedef implementation_defined::const_iterator         const_iterator;        
  typedef implementation_defined::reverse_iterator       reverse_iterator;      
  typedef implementation_defined::const_reverse_iterator const_reverse_iterator;
  typedef implementation_defined::insert_commit_data     insert_commit_data;    
  typedef implementation_defined::node_traits            node_traits;           
  typedef implementation_defined::node                   node;                  
  typedef implementation_defined::node_ptr               node_ptr;              
  typedef implementation_defined::const_node_ptr         const_node_ptr;        
  typedef implementation_defined::node_algorithms        node_algorithms;       

  // construct/copy/destruct
  explicit splay_multiset(const key_compare & = key_compare(), 
                          const value_traits & = value_traits());
  template<typename Iterator> 
    splay_multiset(Iterator, Iterator, const key_compare & = key_compare(), 
                   const value_traits & = value_traits());
  splay_multiset(splay_multiset &&);
  splay_multiset & operator=(splay_multiset &&);
  ~splay_multiset();

  // public member functions
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  reverse_iterator rbegin();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator crbegin() const;
  reverse_iterator rend();
  const_reverse_iterator rend() const;
  const_reverse_iterator crend() const;
  key_compare key_comp() const;
  value_compare value_comp() const;
  bool empty() const;
  size_type size() const;
  void swap(splay_multiset &);
  template<typename Cloner, typename Disposer> 
    void clone_from(const splay_multiset &, Cloner, Disposer);
  template<typename Cloner, typename Disposer> 
    void clone_from(splay_multiset &&, Cloner, Disposer);
  iterator insert(reference);
  iterator insert(const_iterator, reference);
  template<typename Iterator> void insert(Iterator, Iterator);
  iterator insert_before(const_iterator, reference);
  void push_back(reference);
  void push_front(reference);
  iterator erase(const_iterator);
  iterator erase(const_iterator, const_iterator);
  size_type erase(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    size_type erase(const KeyType &, KeyTypeKeyCompare);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, Disposer);
  template<typename Disposer> 
    iterator erase_and_dispose(const_iterator, const_iterator, Disposer);
  template<typename Disposer> 
    size_type erase_and_dispose(const key_type &, Disposer);
  template<typename KeyType, typename KeyTypeKeyCompare, typename Disposer> 
    size_type erase_and_dispose(const KeyType &, KeyTypeKeyCompare, Disposer);
  void clear();
  template<typename Disposer> void clear_and_dispose(Disposer);
  size_type count(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    size_type count(const KeyType &, KeyTypeKeyCompare);
  iterator lower_bound(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator lower_bound(const KeyType &, KeyTypeKeyCompare);
  const_iterator lower_bound(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator lower_bound(const KeyType &, KeyTypeKeyCompare) const;
  iterator upper_bound(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator upper_bound(const KeyType &, KeyTypeKeyCompare);
  const_iterator upper_bound(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator upper_bound(const KeyType &, KeyTypeKeyCompare) const;
  iterator find(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator find(const KeyType &, KeyTypeKeyCompare);
  const_iterator find(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    const_iterator find(const KeyType &, KeyTypeKeyCompare) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, iterator > 
    equal_range(const KeyType &, KeyTypeKeyCompare);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< const_iterator, const_iterator > 
    equal_range(const KeyType &, KeyTypeKeyCompare) const;
  std::pair< iterator, iterator > 
  bounded_range(const_reference, const_reference, bool, bool);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< iterator, iterator > 
    bounded_range(const KeyType &, const KeyType &, KeyTypeKeyCompare, bool, 
                  bool);
  std::pair< const_iterator, const_iterator > 
  bounded_range(const_reference, const_reference, bool, bool) const;
  template<typename KeyType, typename KeyTypeKeyCompare> 
    std::pair< const_iterator, const_iterator > 
    bounded_range(const KeyType &, const KeyType &, KeyTypeKeyCompare, bool, 
                  bool) const;
  iterator iterator_to(reference);
  const_iterator iterator_to(const_reference) const;
  pointer unlink_leftmost_without_rebalance();
  void replace_node(iterator, reference);
  void remove_node(reference);
  void splay_up(iterator);
  template<typename KeyType, typename KeyTypeKeyCompare> 
    iterator splay_down(const KeyType &, KeyTypeKeyCompare);
  iterator splay_down(const key_type &);
  void rebalance();
  iterator rebalance_subtree(iterator);

  // public static functions
  static splay_multiset & container_from_end_iterator(iterator);
  static const splay_multiset & container_from_end_iterator(const_iterator);
  static splay_multiset & container_from_iterator(iterator);
  static const splay_multiset & container_from_iterator(const_iterator);
  static iterator s_iterator_to(reference);
  static const_iterator s_iterator_to(const_reference);
  static void init_node(reference);

  // public data members
  static const bool constant_time_size;
};
.fi
.SH "DESCRIPTION"
.PP
The class template
splay_multiset
is an intrusive container, that mimics most of the interface of std::multiset as described in the C++ standard\&.
.PP
The template parameter
T
is the type to be managed by the container\&. The user can specify additional options and if no options are provided default options are used\&.
.PP
The container supports the following options:
base_hook<>/member_hook<>/value_traits<>,
constant_time_size<>,
size_type<>
and
compare<>\&.
.SS "splay_multiset public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
explicit splay_multiset(const key_compare & cmp = key_compare(), 
                        const value_traits & v_traits = value_traits());
.fi

.sp
\fBEffects\fR: Constructs an empty container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor of the key_compare object throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Iterator> 
  splay_multiset(Iterator b, Iterator e, 
                 const key_compare & cmp = key_compare(), 
                 const value_traits & v_traits = value_traits());
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&. cmp must be a comparison function that induces a strict weak ordering\&.
.sp
\fBEffects\fR: Constructs an empty container and inserts elements from [b, e)\&.
.sp
\fBComplexity\fR: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last\&.
.sp
\fBThrows\fR: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost\&.Intrusive hooks) or the copy constructor/operator() of the key_compare object throws\&. Basic guarantee\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
splay_multiset(splay_multiset && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
splay_multiset & operator=(splay_multiset && x);
.fi

.sp
\fBEffects\fR: to\-do
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
~splay_multiset();
.fi

.sp
\fBEffects\fR: Detaches all elements from this\&. The objects in the set are not deleted (i\&.e\&. no destructors are called), but the nodes according to the
value_traits
template parameter are reinitialized and thus can be reused\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this\&.
.sp
\fBThrows\fR: Nothing\&.
.RE

.SS "splay_multiset public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" begin: Class template splay_multiset
.\" Class template splay_multiset: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" begin: Class template splay_multiset
.\" Class template splay_multiset: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" cbegin: Class template splay_multiset
.\" Class template splay_multiset: cbegin

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the beginning of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" cend: Class template splay_multiset
.\" Class template splay_multiset: cend

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator pointing to the end of the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" rbegin: Class template splay_multiset
.\" Class template splay_multiset: rbegin

.sp

.nf
reverse_iterator rbegin();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" rbegin: Class template splay_multiset
.\" Class template splay_multiset: rbegin

.sp

.nf
const_reverse_iterator rbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rend: Class template splay_multiset
.\" Class template splay_multiset: rend

.sp

.nf
reverse_iterator rend();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rend: Class template splay_multiset
.\" Class template splay_multiset: rend

.sp

.nf
const_reverse_iterator rend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the key_compare object used by the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If key_compare copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns the value_compare object used by the container\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If value_compare copy\-constructor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container is empty\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" size: Class template splay_multiset
.\" Class template splay_multiset: size

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of elements stored in the container\&.
.sp
\fBComplexity\fR: Linear to elements contained in *this if constant\-time size option is disabled\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" swap: Class template splay_multiset
.\" Class template splay_multiset: swap

.sp

.nf
void swap(splay_multiset & other);
.fi

.sp
\fBEffects\fR: Swaps the contents of two containers\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: If the comparison functor\'s swap call throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" clone_from: Class template splay_multiset
.\" Class template splay_multiset: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(const splay_multiset & src, Cloner cloner, 
                  Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this\&. Copies the predicate from the source container\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws or predicate copy assignment throws\&. Basic guarantee\&. Additional notes: it also copies the alpha factor from the source container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" clone_from: Class template splay_multiset
.\" Class template splay_multiset: clone_from

.sp

.nf
template<typename Cloner, typename Disposer> 
  void clone_from(splay_multiset && src, Cloner cloner, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&. Cloner should yield to nodes equivalent to the original nodes\&.
.sp
\fBEffects\fR: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(reference) and inserts them on *this\&. Copies the predicate from the source container\&.
.sp
If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer)\&.
.sp
\fBComplexity\fR: Linear to erased plus inserted elements\&.
.sp
\fBThrows\fR: If cloner throws or predicate copy assignment throws\&. Basic guarantee\&.
.sp
\fBNote\fR: This version can modify the source container, useful to implement move semantics\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" insert: Class template splay_multiset
.\" Class template splay_multiset: insert

.sp

.nf
iterator insert(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue
.sp
\fBEffects\fR: Inserts value into the container before the upper bound\&.
.sp
\fBComplexity\fR: Average complexity for insert element is at most logarithmic\&.
.sp
\fBThrows\fR: If the internal key_compare ordering function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" insert: Class template splay_multiset
.\" Class template splay_multiset: insert

.sp

.nf
iterator insert(const_iterator hint, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and "hint" must be a valid iterator\&.
.sp
\fBEffects\fR: Inserts x into the container, using "hint" as a hint to where it will be inserted\&. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)
.sp
\fBComplexity\fR: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint\&.
.sp
\fBThrows\fR: If the internal key_compare ordering function throws\&. Strong guarantee\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" insert: Class template splay_multiset
.\" Class template splay_multiset: insert

.sp

.nf
template<typename Iterator> void insert(Iterator b, Iterator e);
.fi

.sp
\fBRequires\fR: Dereferencing iterator must yield an lvalue of type value_type\&.
.sp
\fBEffects\fR: Inserts a each element of a range into the container before the upper bound of the key of each element\&.
.sp
\fBComplexity\fR: Insert range is in general O(N * log(N)), where N is the size of the range\&. However, it is linear in N if the range is already sorted by value_comp()\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Does not affect the validity of iterators and references\&. No copy\-constructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" insert_before: Class template splay_multiset
.\" Class template splay_multiset: insert_before

.sp

.nf
iterator insert_before(const_iterator pos, reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate
.sp
\fBEffects\fR: Inserts x into the container before "pos"\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function does not check preconditions so if "pos" is not the successor of "value" container ordering invariant will be broken\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" push_back: Class template splay_multiset
.\" Class template splay_multiset: push_back

.sp

.nf
void push_back(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and it must be no less than the greatest inserted key
.sp
\fBEffects\fR: Inserts x into the container in the last position\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function does not check preconditions so if value is less than the greatest inserted key container ordering invariant will be broken\&. This function is slightly more efficient than using "insert_before"\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" push_front: Class template splay_multiset
.\" Class template splay_multiset: push_front

.sp

.nf
void push_front(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue, and it must be no greater than the minimum inserted key
.sp
\fBEffects\fR: Inserts x into the container in the first position\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function does not check preconditions so if value is greater than the minimum inserted key container ordering invariant will be broken\&. This function is slightly more efficient than using "insert_before"\&. This is a low\-level function to be used only for performance reasons by advanced users\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" erase: Class template splay_multiset
.\" Class template splay_multiset: erase

.sp

.nf
iterator erase(const_iterator i);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by i\&.
.sp
\fBComplexity\fR: Average complexity for erase element is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" erase: Class template splay_multiset
.\" Class template splay_multiset: erase

.sp

.nf
iterator erase(const_iterator b, const_iterator e);
.fi

.sp
\fBEffects\fR: Erases the range pointed to by b end e\&.
.sp
\fBComplexity\fR: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" erase: Class template splay_multiset
.\" Class template splay_multiset: erase

.sp

.nf
size_type erase(const key_type & key);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given value\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" erase: Class template splay_multiset
.\" Class template splay_multiset: erase

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  size_type erase(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "comp"\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" erase_and_dispose: Class template splay_multiset
.\" Class template splay_multiset: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator i, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the element pointed to by i\&. Disposer::operator()(pointer) is called for the removed element\&.
.sp
\fBComplexity\fR: Average complexity for erase element is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" erase_and_dispose: Class template splay_multiset
.\" Class template splay_multiset: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  iterator erase_and_dispose(const_iterator b, const_iterator e, 
                             Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases the range pointed to by b end e\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBComplexity\fR: Average complexity for erase range is at most O(log(size() + N)), where N is the number of elements in the range\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" erase_and_dispose: Class template splay_multiset
.\" Class template splay_multiset: erase_and_dispose

.sp

.nf
template<typename Disposer> 
  size_type erase_and_dispose(const key_type & key, Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given value\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" erase_and_dispose: Class template splay_multiset
.\" Class template splay_multiset: erase_and_dispose

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare, typename Disposer> 
  size_type erase_and_dispose(const KeyType & key, KeyTypeKeyCompare comp, 
                              Disposer disposer);
.fi

.sp
\fBRequires\fR: Disposer::operator()(pointer) shouldn\'t throw\&.
.sp
\fBEffects\fR: Erases all the elements with the given key\&. according to the comparison functor "comp"\&. Disposer::operator()(pointer) is called for the removed elements\&.
.sp
\fBReturns\fR: The number of erased elements\&.
.sp
\fBComplexity\fR: O(log(size() + N)\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators to the erased elements\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" clear: Class template splay_multiset
.\" Class template splay_multiset: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: Erases all of the elements\&.
.sp
\fBComplexity\fR: Linear to the number of elements on the container\&. if it\'s a safe\-mode or auto\-unlink value_type\&. Constant time otherwise\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. No destructors are called\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" clear_and_dispose: Class template splay_multiset
.\" Class template splay_multiset: clear_and_dispose

.sp

.nf
template<typename Disposer> void clear_and_dispose(Disposer disposer);
.fi

.sp
\fBEffects\fR: Erases all of the elements calling disposer(p) for each node to be erased\&.
\fBComplexity\fR: Average complexity for is at most O(log(size() + N)), where N is the number of elements in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: Invalidates the iterators (but not the references) to the erased elements\&. Calls N times to disposer functor\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" count: Class template splay_multiset
.\" Class template splay_multiset: count

.sp

.nf
size_type count(const key_type &);
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given value
.sp
\fBComplexity\fR: Logarithmic to the number of elements contained plus lineal to number of objects with the given value\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: non\-const function, splaying is performed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" count: Class template splay_multiset
.\" Class template splay_multiset: count

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  size_type count(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Returns the number of contained elements with the given key
.sp
\fBComplexity\fR: Logarithmic to the number of elements contained plus lineal to number of objects with the given key\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" lower_bound: Class template splay_multiset
.\" Class template splay_multiset: lower_bound

.sp

.nf
iterator lower_bound(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: non\-const function, splaying is performed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" lower_bound: Class template splay_multiset
.\" Class template splay_multiset: lower_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator lower_bound(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: non\-const function, splaying is performed for the first element of the equal range of "key"
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" lower_bound: Class template splay_multiset
.\" Class template splay_multiset: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" lower_bound: Class template splay_multiset
.\" Class template splay_multiset: lower_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator 
  lower_bound(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns a const iterator to the first element whose key is not less than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" upper_bound: Class template splay_multiset
.\" Class template splay_multiset: upper_bound

.sp

.nf
iterator upper_bound(const key_type & key);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: non\-const function, splaying is performed for the first element of the equal range of "value"
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" upper_bound: Class template splay_multiset
.\" Class template splay_multiset: upper_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator upper_bound(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: non\-const function, splaying is performed for the first element of the equal range of "key"
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" upper_bound: Class template splay_multiset
.\" Class template splay_multiset: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" upper_bound: Class template splay_multiset
.\" Class template splay_multiset: upper_bound

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator 
  upper_bound(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element whose key is greater than k according to comp or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" find: Class template splay_multiset
.\" Class template splay_multiset: find

.sp

.nf
iterator find(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: non\-const function, splaying is performed for the first element of the equal range of "value"
.RE


.sp
.RS 4
.ie n \{\
\h'-04'47.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "47." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" find: Class template splay_multiset
.\" Class template splay_multiset: find

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator find(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Finds an iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: non\-const function, splaying is performed for the first element of the equal range of "key"
.RE


.sp
.RS 4
.ie n \{\
\h'-04'48.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "48." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" find: Class template splay_multiset
.\" Class template splay_multiset: find

.sp

.nf
const_iterator find(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Finds a const_iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'49.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "49." 4.2
.\}
.\" end: Class template splay_multiset
.\" Class template splay_multiset: end
.\" find: Class template splay_multiset
.\" Class template splay_multiset: find

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  const_iterator find(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Finds a const_iterator to the first element whose key is k or end() if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'50.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "50." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & key);
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: non\-const function, splaying is performed for the first element of the equal range of "value"
.RE


.sp
.RS 4
.ie n \{\
\h'-04'51.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "51." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, iterator > 
  equal_range(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: non\-const function, splaying is performed for the first element of the equal range of "key"
.RE


.sp
.RS 4
.ie n \{\
\h'-04'52.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "52." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & key) const;
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'53.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "53." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< const_iterator, const_iterator > 
  equal_range(const KeyType & key, KeyTypeKeyCompare comp) const;
.fi

.sp
\fBEffects\fR: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&. Additional note: const function, no splaying is performed
.RE


.sp
.RS 4
.ie n \{\
\h'-04'54.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "54." 4.2
.\}
.\" bounded_range: Class template splay_multiset
.\" Class template splay_multiset: bounded_range

.sp

.nf
std::pair< iterator, iterator > 
bounded_range(const_reference lower_value, const_reference upper_value, 
              bool left_closed, bool right_closed);
.fi

.sp
\fBRequires\fR: \'lower_key\' must not be greater than \'upper_key\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise
.sp
second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'55.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "55." 4.2
.\}
.\" bounded_range: Class template splay_multiset
.\" Class template splay_multiset: bounded_range

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< iterator, iterator > 
  bounded_range(const KeyType & lower_key, const KeyType & upper_key, 
                KeyTypeKeyCompare comp, bool left_closed, bool right_closed);
.fi

.sp
\fBRequires\fR: KeyTypeKeyCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the container\&. \'lower_key\' must not be greater than \'upper_key\' according to \'comp\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise
.sp
second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'56.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "56." 4.2
.\}
.\" bounded_range: Class template splay_multiset
.\" Class template splay_multiset: bounded_range

.sp

.nf
std::pair< const_iterator, const_iterator > 
bounded_range(const_reference lower_value, const_reference upper_value, 
              bool left_closed, bool right_closed) const;
.fi

.sp
\fBRequires\fR: \'lower_key\' must not be greater than \'upper_key\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise
.sp
second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
key_compare
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_value and upper_value\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'57.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "57." 4.2
.\}
.\" bounded_range: Class template splay_multiset
.\" Class template splay_multiset: bounded_range

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  std::pair< const_iterator, const_iterator > 
  bounded_range(const KeyType & lower_key, const KeyType & upper_key, 
                KeyTypeKeyCompare comp, bool left_closed, bool right_closed) const;
.fi

.sp
\fBRequires\fR: KeyTypeKeyCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the container\&. \'lower_key\' must not be greater than \'upper_key\' according to \'comp\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be false\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key, comp) if left_closed, upper_bound(lower_key, comp) otherwise
.sp
second = upper_bound(upper_key, comp) if right_closed, lower_bound(upper_key, comp) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If
comp
throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key\&.
.sp
\fBNote\fR: Experimental function, the interface might change in future releases\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'58.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "58." 4.2
.\}
.\" iterator_to: Class template splay_multiset
.\" Class template splay_multiset: iterator_to

.sp

.nf
iterator iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'59.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "59." 4.2
.\}
.\" iterator_to: Class template splay_multiset
.\" Class template splay_multiset: iterator_to

.sp

.nf
const_iterator iterator_to(const_reference value) const;
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid const_iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'60.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "60." 4.2
.\}
.\" unlink_leftmost_without_rebalance: Class template splay_multiset
.\" Class template splay_multiset: unlink_leftmost_without_rebalance

.sp

.nf
pointer unlink_leftmost_without_rebalance();
.fi

.sp
\fBEffects\fR: Unlinks the leftmost node from the container\&.
.sp
\fBComplexity\fR: Average complexity is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function breaks the container and the container can only be used for more unlink_leftmost_without_rebalance calls\&. This function is normally used to achieve a step by step controlled destruction of the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'61.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "61." 4.2
.\}
.\" replace_node: Class template splay_multiset
.\" Class template splay_multiset: replace_node

.sp

.nf
void replace_node(iterator replace_this, reference with_this);
.fi

.sp
\fBRequires\fR: replace_this must be a valid iterator of *this and with_this must not be inserted in any container\&.
.sp
\fBEffects\fR: Replaces replace_this in its position in the container with with_this\&. The container does not need to be rebalanced\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules\&. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'62.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "62." 4.2
.\}
.\" remove_node: Class template splay_multiset
.\" Class template splay_multiset: remove_node

.sp

.nf
void remove_node(reference value);
.fi

.sp
\fBEffects\fR: removes "value" from the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic time\&.
.sp
\fBNote\fR: This static function is only usable with non\-constant time size containers that have stateless comparison functors\&.
.sp
If the user calls this function with a constant time size container or stateful comparison functor a compilation error will be issued\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'63.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "63." 4.2
.\}
.\" splay_up: Class template splay_multiset
.\" Class template splay_multiset: splay_up

.sp

.nf
void splay_up(iterator i);
.fi

.sp
\fBRequires\fR: i must be a valid iterator of *this\&.
.sp
\fBEffects\fR: Rearranges the container so that the element pointed by i is placed as the root of the tree, improving future searches of this value\&.
.sp
\fBComplexity\fR: Amortized logarithmic\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'64.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "64." 4.2
.\}
.\" splay_down: Class template splay_multiset
.\" Class template splay_multiset: splay_down

.sp

.nf
template<typename KeyType, typename KeyTypeKeyCompare> 
  iterator splay_down(const KeyType & key, KeyTypeKeyCompare comp);
.fi

.sp
\fBEffects\fR: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree\&. If the element is not present returns the last node compared with the key\&. If the tree is empty, end() is returned\&.
.sp
\fBComplexity\fR: Amortized logarithmic\&.
.sp
\fBReturns\fR: An iterator to the new root of the tree, end() if the tree is empty\&.
.sp
\fBThrows\fR: If the comparison functor throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'65.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "65." 4.2
.\}
.\" splay_down: Class template splay_multiset
.\" Class template splay_multiset: splay_down

.sp

.nf
iterator splay_down(const key_type & key);
.fi

.sp
\fBEffects\fR: Rearranges the container so that if *this stores an element with a key equivalent to value the element is placed as the root of the tree\&.
.sp
\fBComplexity\fR: Amortized logarithmic\&.
.sp
\fBReturns\fR: An iterator to the new root of the tree, end() if the tree is empty\&.
.sp
\fBThrows\fR: If the predicate throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'66.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "66." 4.2
.\}
.\" rebalance: Class template splay_multiset
.\" Class template splay_multiset: rebalance

.sp

.nf
void rebalance();
.fi

.sp
\fBEffects\fR: Rebalances the tree\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'67.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "67." 4.2
.\}
.\" rebalance_subtree: Class template splay_multiset
.\" Class template splay_multiset: rebalance_subtree

.sp

.nf
iterator rebalance_subtree(iterator root);
.fi

.sp
\fBRequires\fR: old_root is a node of a tree\&.
.sp
\fBEffects\fR: Rebalances the subtree rooted at old_root\&.
.sp
\fBReturns\fR: The new root of the subtree\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear to the elements in the subtree\&.
.RE

.SS "splay_multiset public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" container_from_end_iterator: Class template splay_multiset
.\" Class template splay_multiset: container_from_end_iterator

.sp

.nf
static splay_multiset & container_from_end_iterator(iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" container_from_end_iterator: Class template splay_multiset
.\" Class template splay_multiset: container_from_end_iterator

.sp

.nf
static const splay_multiset & 
container_from_end_iterator(const_iterator end_iterator);
.fi

.sp
\fBPrecondition\fR: end_iterator must be a valid end iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the end iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" container_from_iterator: Class template splay_multiset
.\" Class template splay_multiset: container_from_iterator

.sp

.nf
static splay_multiset & container_from_iterator(iterator it);
.fi

.sp
\fBPrecondition\fR: it must be a valid iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" container_from_iterator: Class template splay_multiset
.\" Class template splay_multiset: container_from_iterator

.sp

.nf
static const splay_multiset & container_from_iterator(const_iterator it);
.fi

.sp
\fBPrecondition\fR: it must be a valid iterator of the container\&.
.sp
\fBEffects\fR: Returns a const reference to the container associated to the iterator
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" s_iterator_to: Class template splay_multiset
.\" Class template splay_multiset: s_iterator_to

.sp

.nf
static iterator s_iterator_to(reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" s_iterator_to: Class template splay_multiset
.\" Class template splay_multiset: s_iterator_to

.sp

.nf
static const_iterator s_iterator_to(const_reference value);
.fi

.sp
\fBRequires\fR: value must be an lvalue and shall be in a set of appropriate type\&. Otherwise the behavior is undefined\&.
.sp
\fBEffects\fR: Returns: a valid iterator i belonging to the set that points to the value
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This static function is available only if the
\fIvalue traits\fR
is stateless\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" init_node: Class template splay_multiset
.\" Class template splay_multiset: init_node

.sp

.nf
static void init_node(reference value);
.fi

.sp
\fBRequires\fR: value shall not be in a container\&.
.sp
\fBEffects\fR: init_node puts the hook of a value in a well\-known default state\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBNote\fR: This function puts the hook in the well\-known default state used by auto_unlink and safe hooks\&.
.RE


