.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "MACRO BOOST" 3 "" "" ""
.SH "NAME"
BOOST_TTI_TRAIT_HAS_TEMPLATE \- Expands to a metafunction which tests whether an inner class template with a particular name exists\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/tti/has_template\&.hpp>

BOOST_TTI_TRAIT_HAS_TEMPLATE(trait, \&.\&.\&.)
.fi
.SH "DESCRIPTION"
.PP
trait = the name of the metafunction\&. \&.\&.\&. = variadic parameters\&. The first variadic parameter is the inner class template name\&. Following variadic parameters are optional\&. If no following variadic parameters exist, then the inner class template being introspected must be all template type parameters ( template parameters starting with `class` or `typename` ) and any number of template type parameters can occur\&. If the second variadic parameter is BOOST_PP_NIL and no other variadic parameter is given, then just as in the previous case the inner class template being introspected must be all template type parameters ( template parameters starting with `class` or `typename` ) and any number of template type parameters can occur\&. This form is allowed in order to be consistent with using the non\-variadic form of this macro\&. If the second variadic parameter is a Boost preprocessor library array and no other variadic parameter is given, then the inner class template must have its template parameters matching the sequence in the tuple portion of the Boost PP array\&. This form is allowed in order to be consistent with using the non\-variadic form of this macro\&. Otherwise the inner class template must have its template parameters matching the sequence of the optional variadic parameters\&.
.PP
generates a metafunction called "trait" where \'trait\' is the first macro parameter\&. template<class BOOST_TTI_TP_T> struct trait { static const value = unspecified; typedef mpl::bool_<true\-or\-false> type; }; The metafunction types and return: BOOST_TTI_TP_T = the enclosing type in which to look for our \'name\'\&. returns = \'value\' is true if the \'name\' template exists within the enclosing type, otherwise \'value\' is false\&.
.PP
Examples:
.PP
1) Search for an inner class template called \'MyTemplate\', with all template type parameters, nested within the class \'MyClass\' using a metafunction name of \'MyMeta\'\&.
.PP
BOOST_TTI_TRAIT_HAS_TEMPLATE(MyMeta,MyTemplate)
.PP
or
.PP
BOOST_TTI_TRAIT_HAS_TEMPLATE(MyMeta,MyTemplate,BOOST_PP_NIL) // Non\-variadic macro form
.PP
MyMeta<MyClass>::value
.PP
is a compile time boolean constant which is either \'true\' or \'false\' if the nested template exists\&.
.PP
2) Search for an inner class template called \'MyTemplate\', with template parameters of \'class T,int x,template<class> class U\', nested within the class \'MyClass\' using a metafunction name of \'MyMeta\'\&.
.PP
BOOST_TTI_TRAIT_HAS_TEMPLATE(MyMeta,MyTemplate,class,int,template<class> class)
.PP
or
.PP
BOOST_TTI_TRAIT_HAS_TEMPLATE(MyMeta,MyTemplate,(3,(class,int,template<class> class))) // Non\-variadic macro form
.PP
MyMeta<MyClass>::value
.PP
is a compile time boolean constant which is either \'true\' or \'false\' if the nested template exists\&.

