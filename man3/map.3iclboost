.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE MAP" 3 "" "" ""
.SH "NAME"
boost::icl::map \- Addable, subractable and intersectable maps\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/icl/map\&.hpp>

template<typename DomainT, typename CodomainT, 
         typename Traits = icl::partial_absorber, 
         ICL_COMPARE Compare = ICL_COMPARE_INSTANCE(ICL_COMPARE_DEFAULT, DomainT), 
         ICL_COMBINE Combine = ICL_COMBINE_INSTANCE(icl::inplace_plus, CodomainT), 
         ICL_SECTION Section = ICL_SECTION_INSTANCE(icl::inter_section, CodomainT), 
         ICL_ALLOC Alloc = std::allocator> 
class map : private ICL_IMPL_SPACE::map< DomainT, CodomainT, ICL_COMPARE_DOMAIN(Compare, DomainT), Alloc< std::pair< const DomainT, CodomainT > > >
{
public:
  // types
  typedef Alloc< typename std::pair< const DomainT, CodomainT > >                                                          allocator_type;            
  typedef icl::map< DomainT, CodomainT, Traits, Compare, Combine, Section, Alloc >                                         type;                      
  typedef ICL_IMPL_SPACE::map< DomainT, CodomainT, ICL_COMPARE_DOMAIN(Compare, DomainT), allocator_type >                  base_type;                 
  typedef Traits                                                                                                           traits;                    
  typedef DomainT                                                                                                          domain_type;               
  typedef boost::call_traits< DomainT >::param_type                                                                        domain_param;              
  typedef DomainT                                                                                                          key_type;                  
  typedef CodomainT                                                                                                        codomain_type;             
  typedef CodomainT                                                                                                        mapped_type;               
  typedef CodomainT                                                                                                        data_type;                 
  typedef std::pair< const DomainT, CodomainT >                                                                            element_type;              
  typedef std::pair< const DomainT, CodomainT >                                                                            value_type;                
  typedef domain_compare                                                                                                   key_compare;               
  typedef inverse< codomain_combine >::type                                                                                inverse_codomain_combine;  
  typedef mpl::if_< has_set_semantics< codomain_type >, ICL_SECTION_CODOMAIN(Section, CodomainT), codomain_combine >::type codomain_intersect;        
  typedef inverse< codomain_intersect >::type                                                                              inverse_codomain_intersect;
  typedef base_type::value_compare                                                                                         value_compare;             
  typedef ICL_IMPL_SPACE::set< DomainT, domain_compare, Alloc< DomainT > >                                                 set_type;                  
  typedef set_type                                                                                                         key_object_type;           
  typedef on_absorbtion< type, codomain_combine, Traits::absorbs_identities >                                              on_identity_absorbtion;    
  typedef base_type::pointer                                                                                               pointer;                   
  typedef base_type::const_pointer                                                                                         const_pointer;             
  typedef base_type::reference                                                                                             reference;                 
  typedef base_type::const_reference                                                                                       const_reference;           
  typedef base_type::iterator                                                                                              iterator;                  
  typedef base_type::const_iterator                                                                                        const_iterator;            
  typedef base_type::size_type                                                                                             size_type;                 
  typedef base_type::difference_type                                                                                       difference_type;           
  typedef base_type::reverse_iterator                                                                                      reverse_iterator;          
  typedef base_type::const_reverse_iterator                                                                                const_reverse_iterator;    

  // member classes/structs/unions
  template<typename Type, bool has_set_semantics, bool absorbs_identities> 
  struct on_codomain_model {
  };
  template<typename Type> 
  struct on_codomain_model<Type, false, false> {

    // public static functions
    static void subtract(Type &, typename Type::iterator, 
                         const typename Type::codomain_type &);
  };
  template<typename Type> 
  struct on_codomain_model<Type, false, true> {

    // public static functions
    static void subtract(Type &, typename Type::iterator, 
                         const typename Type::codomain_type &);
  };
  template<typename Type> 
  struct on_codomain_model<Type, true, false> {
    // types
    typedef Type::inverse_codomain_intersect inverse_codomain_intersect;

    // public static functions
    static void subtract(Type &, typename Type::iterator, 
                         const typename Type::codomain_type &);
  };
  template<typename Type> 
  struct on_codomain_model<Type, true, true> {
    // types
    typedef Type::inverse_codomain_intersect inverse_codomain_intersect;

    // public static functions
    static void subtract(Type &, typename Type::iterator, 
                         const typename Type::codomain_type &);
  };
  template<typename Type, bool is_total> 
  struct on_definedness {
  };
  template<typename Type> 
  struct on_definedness<Type, false> {

    // public static functions
    static void add_intersection(Type &, const Type &, const element_type &);
  };
  template<typename Type> 
  struct on_definedness<Type, true> {

    // public static functions
    static void add_intersection(Type &, const Type &, const element_type &);
  };
  template<typename Type, bool is_total_invertible> 
  struct on_invertible {
  };
  template<typename Type> 
  struct on_invertible<Type, false> {
    // types
    typedef Type::element_type             element_type;            
    typedef Type::inverse_codomain_combine inverse_codomain_combine;

    // public static functions
    static void subtract(Type &, const element_type &);
  };
  template<typename Type> 
  struct on_invertible<Type, true> {
    // types
    typedef Type::element_type             element_type;            
    typedef Type::inverse_codomain_combine inverse_codomain_combine;

    // public static functions
    static void subtract(Type &, const element_type &);
  };
  template<typename Type, bool is_total, bool absorbs_identities> 
  struct on_total_absorbable {
  };
  template<typename Type> 
  struct on_total_absorbable<Type, false, false> {
    // types
    typedef Type::element_type               element_type;              
    typedef Type::codomain_type              codomain_type;             
    typedef Type::iterator                   iterator;                  
    typedef Type::inverse_codomain_intersect inverse_codomain_intersect;

    // public static functions
    static void flip(Type &, const element_type &);
  };
  template<typename Type> 
  struct on_total_absorbable<Type, false, true> {
    // types
    typedef Type::element_type               element_type;              
    typedef Type::codomain_type              codomain_type;             
    typedef Type::iterator                   iterator;                  
    typedef Type::inverse_codomain_intersect inverse_codomain_intersect;

    // public static functions
    static void flip(Type &, const element_type &);
  };
  template<typename Type> 
  struct on_total_absorbable<Type, true, false> {
    // types
    typedef Type::element_type  element_type; 
    typedef Type::codomain_type codomain_type;

    // public static functions
    static void flip(Type &, const element_type &);
  };
  template<typename Type> 
  struct on_total_absorbable<Type, true, true> {
    // types
    typedef Type::element_type element_type;

    // public static functions
    static void flip(Type &, const typename Type::element_type &);
  };

  // construct/copy/destruct
  map();
  map(const key_compare &);
  template<typename InputIterator> map(InputIterator, InputIterator);
  template<typename InputIterator> 
    map(InputIterator, InputIterator, const key_compare &);
  map(const map &);
  explicit map(const element_type &);
  map(map &&);
  map & operator=(map);

  // public member functions
  typedef ICL_COMPARE_DOMAIN(Compare, DomainT);
  typedef ICL_COMBINE_CODOMAIN(Combine, CodomainT);
  typedef ICL_COMPARE_DOMAIN(Compare, element_type);
   BOOST_STATIC_CONSTANT(bool, _total = (Traits::is_total));
   BOOST_STATIC_CONSTANT(bool, _absorbs = (Traits::absorbs_identities));
   BOOST_STATIC_CONSTANT(bool, 
                         total_invertible = (mpl::and_< is_total< type >, has_inverse< codomain_type > >::value));
   BOOST_STATIC_CONSTANT(bool, 
                         is_total_invertible = (Traits::is_total &&has_inverse< codomain_type >::value));
   BOOST_STATIC_CONSTANT(int, fineness = 4);
  void swap(map &);
  template<typename SubObject> bool contains(const SubObject &) const;
  bool within(const map &) const;
  std::size_t iterative_size() const;
  codomain_type operator()(const domain_type &) const;
  map & add(const value_type &);
  iterator add(iterator, const value_type &);
  map & subtract(const element_type &);
  map & subtract(const domain_type &);
  std::pair< iterator, bool > insert(const value_type &);
  iterator insert(iterator, const value_type &);
  template<typename Iterator> iterator insert(Iterator, Iterator);
  map & set(const element_type &);
  size_type erase(const element_type &);
  void add_intersection(map &, const element_type &) const;
  map & flip(const element_type &);
  template<typename Combiner> 
    map< DomainT, CodomainT, Traits, Compare, Combine, Section, Alloc > & 
    _add(const element_type &);
  template<typename Combiner> 
    map< DomainT, CodomainT, Traits, Compare, Combine, Section, Alloc > & 
    _subtract(const value_type &);

  // private member functions
  template<typename Combiner> map & _add(const element_type &);
  template<typename Combiner> iterator _add(iterator, const element_type &);
  template<typename Combiner> map & _subtract(const element_type &);
  template<typename FragmentT> 
    void total_add_intersection(type &, const FragmentT &) const;
  void partial_add_intersection(type &, const element_type &) const;
};
.fi
.SH "DESCRIPTION"
.SS "map public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
map();
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
map(const key_compare & comp);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename InputIterator> map(InputIterator first, InputIterator past);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  map(InputIterator first, InputIterator past, const key_compare & comp);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
map(const map & src);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
explicit map(const element_type & key_value_pair);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
map(map && src);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
map & operator=(map src);
.fi

.RE

.SS "map public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typedef ICL_COMPARE_DOMAIN(Compare, DomainT);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typedef ICL_COMBINE_CODOMAIN(Combine, CodomainT);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typedef ICL_COMPARE_DOMAIN(Compare, element_type);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
 BOOST_STATIC_CONSTANT(bool, _total = (Traits::is_total));
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
 BOOST_STATIC_CONSTANT(bool, _absorbs = (Traits::absorbs_identities));
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
 BOOST_STATIC_CONSTANT(bool, 
                       total_invertible = (mpl::and_< is_total< type >, has_inverse< codomain_type > >::value));
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
 BOOST_STATIC_CONSTANT(bool, 
                       is_total_invertible = (Traits::is_total &&has_inverse< codomain_type >::value));
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
 BOOST_STATIC_CONSTANT(int, fineness = 4);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
void swap(map & src);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
template<typename SubObject> bool contains(const SubObject & sub) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
bool within(const map & super) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
std::size_t iterative_size() const;
.fi

.sp
iterative_size()
yields the number of elements that is visited throu complete iteration\&. For interval sets
iterative_size()
is different from
size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
codomain_type operator()(const domain_type & key) const;
.fi

.sp
Total select function\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
map & add(const value_type & value_pair);
.fi

.sp
add
inserts
value_pair
into the map if it\'s key does not exist in the map\&. If
value_pairs\'s
key value exists in the map, it\'s data value is added to the data value already found in the map\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
iterator add(iterator prior, const value_type & value_pair);
.fi

.sp
add
add
value_pair
into the map using
prior
as a hint to insert
value_pair
after the position
prior
is pointing to\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
map & subtract(const element_type & value_pair);
.fi

.sp
If the
value_pair\'s
key value is in the map, it\'s data value is subtraced from the data value stored in the map\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
map & subtract(const domain_type & key);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
std::pair< iterator, bool > insert(const value_type & value_pair);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}

.sp

.nf
iterator insert(iterator prior, const value_type & value_pair);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
template<typename Iterator> iterator insert(Iterator first, Iterator last);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}

.sp

.nf
map & set(const element_type & key_value_pair);
.fi

.sp
With
key_value_pair = (k,v)
set value
v
for key
k
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}

.sp

.nf
size_type erase(const element_type & key_value_pair);
.fi

.sp
erase
key_value_pair
from the map\&. Erase only if, the exact value content
val
is stored for the given key\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}

.sp

.nf
void add_intersection(map & section, const element_type & key_value_pair) const;
.fi

.sp
The intersection of
key_value_pair
and
*this
map is added to
section\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}

.sp

.nf
map & flip(const element_type & operand);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
template<typename Combiner> 
  map< DomainT, CodomainT, Traits, Compare, Combine, Section, Alloc > & 
  _add(const element_type & addend);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
template<typename Combiner> 
  map< DomainT, CodomainT, Traits, Compare, Combine, Section, Alloc > & 
  _subtract(const value_type & minuend);
.fi

.RE

.SS "map private member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
template<typename Combiner> map & _add(const element_type & value_pair);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename Combiner> 
  iterator _add(iterator prior, const element_type & value_pair);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
template<typename Combiner> map & _subtract(const element_type & value_pair);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename FragmentT> 
  void total_add_intersection(type & section, const FragmentT & fragment) const;
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void partial_add_intersection(type & section, const element_type & operand) const;
.fi

.RE


