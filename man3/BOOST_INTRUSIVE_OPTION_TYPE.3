.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "" 3 "" "" ""
.\" BOOST_INTRUSIVE_OPTION_TYPE: Macro BOOST_INTRUSIVE_OPTION_TYPE
.\" Macro BOOST_INTRUSIVE_OPTION_TYPE: BOOST_INTRUSIVE_OPTION_TYPE
.SH "NAME"
BOOST_INTRUSIVE_OPTION_TYPE
.SH "SYNOPSIS"
.\" BOOST_INTRUSIVE_OPTION_TYPE: Macro BOOST_INTRUSIVE_OPTION_TYPE
.\" Macro BOOST_INTRUSIVE_OPTION_TYPE: BOOST_INTRUSIVE_OPTION_TYPE

.sp
.nf
// In header: <boost/intrusive/pack_options\&.hpp>

BOOST_INTRUSIVE_OPTION_TYPE(OPTION_NAME, TYPE, TYPEDEF_EXPR, TYPEDEF_NAME)
.fi
.SH "DESCRIPTION"
.\" type: Macro BOOST_INTRUSIVE_OPTION_TYPE
.\" Macro BOOST_INTRUSIVE_OPTION_TYPE: type
.\" BOOST_INTRUSIVE_OPTION_TYPE: Macro BOOST_INTRUSIVE_OPTION_TYPE
.\" Macro BOOST_INTRUSIVE_OPTION_TYPE: BOOST_INTRUSIVE_OPTION_TYPE
.PP
Defines an option class of name OPTION_NAME that can be used to specify a type of type TYPE\&.\&.\&.
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
struct OPTION_NAME<class TYPE>
{  unspecified_content  };

.fi
.if n \{\
.RE
.\}

.PP
\&.\&.\&.that after being combined with
boost::intrusive::pack_options, will typedef TYPE as a typedef of name TYPEDEF_NAME\&. Example:
.PP

.sp
.if n \{\
.RS 4
.\}
.nf
//[includes and namespaces omitted for brevity]

//This macro will create the following class:
//    template<class VoidPointer>
//    struct my_pointer
//    { unspecified_content };
BOOST_INTRUSIVE_OPTION_TYPE(my_pointer, VoidPointer, boost::remove_pointer<VoidPointer>::type, my_pointer_type)

struct empty_default{};

typedef pack_options< empty_default, typename my_pointer<void*> >::type::my_pointer_type type;

BOOST_STATIC_ASSERT(( boost::is_same<type, void>::value ));

.fi
.if n \{\
.RE
.\}
.sp


