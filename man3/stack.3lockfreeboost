.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE STA" 3 "" "" ""
.SH "NAME"
boost::lockfree::stack
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/lockfree/stack\&.hpp>

template<typename T, \&.\&.\&. Options> 
class stack {
public:
  // types
  typedef T                                 value_type;
  typedef implementation_defined::allocator allocator; 
  typedef implementation_defined::size_type size_type; 

  // construct/copy/destruct
  stack(void);
  template<typename U> 
    explicit stack(typename node_allocator::template rebind< U >::other const &);
  explicit stack(allocator const &);
  explicit stack(size_type);
  template<typename U> 
    stack(size_type, 
          typename node_allocator::template rebind< U >::other const &);
  ~stack(void);

  // public member functions
  bool is_lock_free(void) const;
  void reserve(size_type);
  void reserve_unsafe(size_type);
  bool push(T const &);
  bool bounded_push(T const &);
  template<typename ConstIterator> 
    ConstIterator push(ConstIterator, ConstIterator);
  template<typename ConstIterator> 
    ConstIterator bounded_push(ConstIterator, ConstIterator);
  bool unsynchronized_push(T const &);
  template<typename ConstIterator> 
    ConstIterator unsynchronized_push(ConstIterator, ConstIterator);
  bool pop(T &);
  template<typename U> bool pop(U &);
  bool unsynchronized_pop(T &);
  template<typename U> bool unsynchronized_pop(U &);
  template<typename Functor> bool consume_one(Functor &);
  template<typename Functor> bool consume_one(Functor const &);
  template<typename Functor> size_t consume_all(Functor &);
  template<typename Functor> size_t consume_all(Functor const &);
  bool empty(void) const;
};
.fi
.SH "DESCRIPTION"
.PP
The stack class provides a multi\-writer/multi\-reader stack, pushing and popping is lock\-free, construction/destruction has to be synchronized\&. It uses a freelist for memory management, freed nodes are pushed to the freelist and not returned to the OS before the stack is destroyed\&.
.PP
\fBPolicies:\fR
.PP

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::fixed_sized<>, defaults to
boost::lockfree::fixed_sized<false>
&#9618;.br&#9618;
Can be used to completely disable dynamic memory allocations during push in order to ensure lockfree behavior\&.&#9618;.br&#9618;
If the data structure is configured as fixed\-sized, the internal nodes are stored inside an array and they are addressed by array indexing\&. This limits the possible size of the stack to the number of elements that can be addressed by the index type (usually 2**16\-2), but on platforms that lack double\-width compare\-and\-exchange instructions, this is the best way to achieve lock\-freedom\&.
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::capacity<>, optional
&#9618;.br&#9618;
If this template argument is passed to the options, the size of the stack is set at compile\-time\&.
&#9618;.br&#9618;
It this option implies
fixed_sized<true>
.RE

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
boost::lockfree::allocator<>, defaults to
boost::lockfree::allocator<std::allocator<void>>
&#9618;.br&#9618;
Specifies the allocator that is used for the internal freelist
.RE
.sp
.RE

.PP
\fBRequirements:\fR

.sp
.RS 4
.ie n \{\
\h'-04'&#8226;\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
T must have a copy constructor
.RE
.sp
.RE

.SS "stack public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
stack(void);
.fi

Construct stack\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
template<typename U> 
  explicit stack(typename node_allocator::template rebind< U >::other const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit stack(allocator const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
explicit stack(size_type n);
.fi

Construct stack, allocate n nodes for the freelist\&. .RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename U> 
  stack(size_type n, 
        typename node_allocator::template rebind< U >::other const & alloc);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
~stack(void);
.fi

.sp
Destroys stack, free all nodes from freelist\&.
.sp
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
not thread\-safe
.sp .5v
.RE

.RE

.SS "stack public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
bool is_lock_free(void) const;
.fi

.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBWarning\fR
.ps -1
.br
It only checks, if the top stack node and the freelist can be modified in a lock\-free manner\&. On most platforms, the whole implementation is lock\-free, if this is true\&. Using c++0x\-style atomics, there is no possibility to provide a completely accurate implementation, because one would need to test every internal node, which is impossible if further nodes will be allocated from the operating system\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if implementation is lock\-free\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
void reserve(size_type n);
.fi

.sp
Allocate n nodes for freelist
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
thread\-safe, may block if memory allocator blocks
.sp .5v
.RE

.PP
Requires:
.RS 4
only valid if no capacity<> argument given
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
void reserve_unsafe(size_type n);
.fi

.sp
Allocate n nodes for freelist
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
not thread\-safe, may block if memory allocator blocks
.sp .5v
.RE

.PP
Requires:
.RS 4
only valid if no capacity<> argument given
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
bool push(T const & v);
.fi

.sp
Pushes object t to the stack\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe\&. If internal memory pool is exhausted and the memory pool is not fixed\-sized, a new node will be allocated from the OS\&. This may not be lock\-free\&.
.sp .5v
.RE

.PP
Postconditions:
.RS 4
object will be pushed to the stack, if internal node can be allocated
.RE
.PP
Returns:
.RS 4
true, if the push operation is successful\&.
.RE
.PP
Throws:
.RS 4
if memory allocator throws
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
bool bounded_push(T const & v);
.fi

.sp
Pushes object t to the stack\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking\&. If internal memory pool is exhausted, the push operation will fail
.sp .5v
.RE

.PP
Postconditions:
.RS 4
object will be pushed to the stack, if internal node can be allocated
.RE
.PP
Returns:
.RS 4
true, if the push operation is successful\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename ConstIterator> 
  ConstIterator push(ConstIterator begin, ConstIterator end);
.fi

.sp
Pushes as many objects from the range [begin, end) as freelist node can be allocated\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Operation is applied atomically
.sp .5v
.RE

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe\&. If internal memory pool is exhausted and the memory pool is not fixed\-sized, a new node will be allocated from the OS\&. This may not be lock\-free\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
iterator to the first element, which has not been pushed
.RE
.PP
Throws:
.RS 4
if memory allocator throws
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
template<typename ConstIterator> 
  ConstIterator bounded_push(ConstIterator begin, ConstIterator end);
.fi

.sp
Pushes as many objects from the range [begin, end) as freelist node can be allocated\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Operation is applied atomically
.sp .5v
.RE

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking\&. If internal memory pool is exhausted, the push operation will fail
.sp .5v
.RE

.PP
Returns:
.RS 4
iterator to the first element, which has not been pushed
.RE
.PP
Throws:
.RS 4
if memory allocator throws
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
bool unsynchronized_push(T const & v);
.fi

.sp
Pushes object t to the stack\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not thread\-safe\&. If internal memory pool is exhausted and the memory pool is not fixed\-sized, a new node will be allocated from the OS\&. This may not be lock\-free\&.
.sp .5v
.RE

.PP
Postconditions:
.RS 4
object will be pushed to the stack, if internal node can be allocated
.RE
.PP
Returns:
.RS 4
true, if the push operation is successful\&.
.RE
.PP
Throws:
.RS 4
if memory allocator throws
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
template<typename ConstIterator> 
  ConstIterator unsynchronized_push(ConstIterator begin, ConstIterator end);
.fi

.sp
Pushes as many objects from the range [begin, end) as freelist node can be allocated\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not thread\-safe\&. If internal memory pool is exhausted and the memory pool is not fixed\-sized, a new node will be allocated from the OS\&. This may not be lock\-free\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
iterator to the first element, which has not been pushed
.RE
.PP
Throws:
.RS 4
if memory allocator throws
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
bool pop(T & ret);
.fi

.sp
Pops object from stack\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if stack was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
template<typename U> bool pop(U & ret);
.fi

.sp
Pops object from stack\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Requires:
.RS 4
type T must be convertible to U
.RE
.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if stack was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
bool unsynchronized_pop(T & ret);
.fi

.sp
Pops object from stack\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not thread\-safe, but non\-blocking
.sp .5v
.RE

.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if stack was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
template<typename U> bool unsynchronized_pop(U & ret);
.fi

.sp
Pops object from stack\&.
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Not thread\-safe, but non\-blocking
.sp .5v
.RE

.PP
Requires:
.RS 4
type T must be convertible to U
.RE
.PP
Postconditions:
.RS 4
if pop operation is successful, object will be copied to ret\&.
.RE
.PP
Returns:
.RS 4
true, if the pop operation is successful, false if stack was empty\&.
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
template<typename Functor> bool consume_one(Functor & f);
.fi

.sp
consumes one element via a functor
.sp
pops one element from the stack and applies the functor on this object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if one element was consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
template<typename Functor> bool consume_one(Functor const & f);
.fi

.sp
consumes one element via a functor
.sp
pops one element from the stack and applies the functor on this object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if one element was consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
template<typename Functor> size_t consume_all(Functor & f);
.fi

.sp
consumes all elements via a functor
.sp
sequentially pops all elements from the stack and applies the functor on each object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
number of elements that are consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
template<typename Functor> size_t consume_all(Functor const & f);
.fi

.sp
consumes all elements via a functor
.sp
sequentially pops all elements from the stack and applies the functor on each object
.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
Thread\-safe and non\-blocking, if functor is thread\-safe and non\-blocking
.sp .5v
.RE

.PP
Returns:
.RS 4
number of elements that are consumed
.RE
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
bool empty(void) const;
.fi

.sp

.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
It only guarantees that at some point during the execution of the function the stack has been empty\&. It is rarely practical to use this value in program logic, because the stack can be modified by other threads\&.
.sp .5v
.RE

.PP
Returns:
.RS 4
true, if stack is empty\&.
.RE
.RE


