.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLA" 3 "" "" ""
.SH "NAME"
boost::intrusive::bstree_algorithms
.SH "SYNOPSIS"
.\" vine_to_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: vine_to_subtree
.\" upper_bound_loop: Class template bstree_algorithms
.\" Class template bstree_algorithms: upper_bound_loop
.\" upper_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: upper_bound
.\" unlink_leftmost_without_rebalance: Class template bstree_algorithms
.\" Class template bstree_algorithms: unlink_leftmost_without_rebalance
.\" unlink: Class template bstree_algorithms
.\" Class template bstree_algorithms: unlink
.\" unique: Class template bstree_algorithms
.\" Class template bstree_algorithms: unique
.\" swap_tree: Class template bstree_algorithms
.\" Class template bstree_algorithms: swap_tree
.\" swap_nodes: Class template bstree_algorithms
.\" Class template bstree_algorithms: swap_nodes
.\" subtree_to_vine: Class template bstree_algorithms
.\" Class template bstree_algorithms: subtree_to_vine
.\" subtree_size: Class template bstree_algorithms
.\" Class template bstree_algorithms: subtree_size
.\" size: Class template bstree_algorithms
.\" Class template bstree_algorithms: size
.\" set_child: Class template bstree_algorithms
.\" Class template bstree_algorithms: set_child
.\" rotate_right_no_parent_fix: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_right_no_parent_fix
.\" rotate_right: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_right
.\" rotate_left_no_parent_fix: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_left_no_parent_fix
.\" rotate_left: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_left
.\" root_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: root_node
.\" replace_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: replace_node
.\" rebalance_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: rebalance_subtree
.\" rebalance: Class template bstree_algorithms
.\" Class template bstree_algorithms: rebalance
.\" push_front_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_front_check
.\" push_front: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_front
.\" push_back_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_back_check
.\" push_back: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_back
.\" prev_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: prev_node
.\" node_traits: Class template bstree_algorithms
.\" Class template bstree_algorithms: node_traits
.\" node_ptr: Class template bstree_algorithms
.\" Class template bstree_algorithms: node_ptr
.\" node: Class template bstree_algorithms
.\" Class template bstree_algorithms: node
.\" next_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: next_node
.\" minimum: Class template bstree_algorithms
.\" Class template bstree_algorithms: minimum
.\" maximum: Class template bstree_algorithms
.\" Class template bstree_algorithms: maximum
.\" lower_bound_loop: Class template bstree_algorithms
.\" Class template bstree_algorithms: lower_bound_loop
.\" lower_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: lower_bound
.\" is_right_child: Class template bstree_algorithms
.\" Class template bstree_algorithms: is_right_child
.\" is_left_child: Class template bstree_algorithms
.\" Class template bstree_algorithms: is_left_child
.\" is_header: Class template bstree_algorithms
.\" Class template bstree_algorithms: is_header
.\" insert_unique_commit: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_unique_commit
.\" insert_unique_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_unique_check
.\" insert_equal_upper_bound_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_upper_bound_check
.\" insert_equal_upper_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_upper_bound
.\" insert_equal_lower_bound_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_lower_bound_check
.\" insert_equal_lower_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_lower_bound
.\" insert_equal_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_check
.\" insert_equal: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal
.\" insert_commit_data: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_commit_data
.\" insert_commit: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_commit
.\" insert_before_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_before_check
.\" insert_before: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_before
.\" inited: Class template bstree_algorithms
.\" Class template bstree_algorithms: inited
.\" init_header: Class template bstree_algorithms
.\" Class template bstree_algorithms: init_header
.\" init: Class template bstree_algorithms
.\" Class template bstree_algorithms: init
.\" get_root: Class template bstree_algorithms
.\" Class template bstree_algorithms: get_root
.\" get_header: Class template bstree_algorithms
.\" Class template bstree_algorithms: get_header
.\" find: Class template bstree_algorithms
.\" Class template bstree_algorithms: find
.\" erase: Class template bstree_algorithms
.\" Class template bstree_algorithms: erase
.\" end_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: end_node
.\" dispose_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: dispose_subtree
.\" depth: Class template bstree_algorithms
.\" Class template bstree_algorithms: depth
.\" data_for_rebalance: Class template bstree_algorithms
.\" Class template bstree_algorithms: data_for_rebalance
.\" count: Class template bstree_algorithms
.\" Class template bstree_algorithms: count
.\" const_node_ptr: Class template bstree_algorithms
.\" Class template bstree_algorithms: const_node_ptr
.\" compress_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: compress_subtree
.\" clone_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: clone_subtree
.\" clone: Class template bstree_algorithms
.\" Class template bstree_algorithms: clone
.\" clear_and_dispose: Class template bstree_algorithms
.\" Class template bstree_algorithms: clear_and_dispose
.\" check_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: check_subtree
.\" check: Class template bstree_algorithms
.\" Class template bstree_algorithms: check
.\" bstree_algorithms: Class template bstree_algorithms
.\" Class template bstree_algorithms: bstree_algorithms
.\" bounded_range: Class template bstree_algorithms
.\" Class template bstree_algorithms: bounded_range
.\" begin_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: begin_node

.sp
.nf
// In header: <boost/intrusive/bstree_algorithms\&.hpp>

template<typename NodeTraits> 
class bstree_algorithms : public bstree_algorithms_base< NodeTraits > {
public:
  // types
  typedef NodeTraits::node                 node;              
  typedef NodeTraits                       node_traits;       
  typedef NodeTraits::node_ptr             node_ptr;          
  typedef NodeTraits::const_node_ptr       const_node_ptr;    
  typedef insert_commit_data_t< node_ptr > insert_commit_data;
  typedef data_for_rebalance_t< node_ptr > data_for_rebalance;

  // public static functions
  static node_ptr begin_node(const const_node_ptr &);
  static node_ptr end_node(const const_node_ptr &);
  static node_ptr root_node(const const_node_ptr &);
  static bool unique(const const_node_ptr &);
  static node_ptr get_header(const const_node_ptr &);
  static void swap_nodes(const node_ptr &, const node_ptr &);
  static void swap_nodes(const node_ptr &, const node_ptr &, const node_ptr &, 
                         const node_ptr &);
  static void replace_node(const node_ptr &, const node_ptr &);
  static void replace_node(const node_ptr &, const node_ptr &, 
                           const node_ptr &);
  static node_ptr next_node(const node_ptr &);
  static node_ptr prev_node(const node_ptr &);
  static node_ptr minimum(node_ptr);
  static node_ptr maximum(node_ptr);
  static void init(const node_ptr &);
  static bool inited(const const_node_ptr &);
  static void init_header(const node_ptr &);
  template<typename Disposer> 
    static void clear_and_dispose(const node_ptr &, Disposer);
  static node_ptr unlink_leftmost_without_rebalance(const node_ptr &);
  static std::size_t size(const const_node_ptr &);
  static void swap_tree(const node_ptr &, const node_ptr &);
  static bool is_header(const const_node_ptr &);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static node_ptr 
    find(const const_node_ptr &, const KeyType &, KeyNodePtrCompare);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static std::pair< node_ptr, node_ptr > 
    bounded_range(const const_node_ptr &, const KeyType &, const KeyType &, 
                  KeyNodePtrCompare, bool, bool);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static std::size_t 
    count(const const_node_ptr &, const KeyType &, KeyNodePtrCompare);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static std::pair< node_ptr, node_ptr > 
    equal_range(const const_node_ptr &, const KeyType &, KeyNodePtrCompare);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static std::pair< node_ptr, node_ptr > 
    lower_bound_range(const const_node_ptr &, const KeyType &, 
                      KeyNodePtrCompare);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static node_ptr 
    lower_bound(const const_node_ptr &, const KeyType &, KeyNodePtrCompare);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static node_ptr 
    upper_bound(const const_node_ptr &, const KeyType &, KeyNodePtrCompare);
  static void insert_unique_commit(const node_ptr &, const node_ptr &, 
                                   const insert_commit_data &);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static std::pair< node_ptr, bool > 
    insert_unique_check(const const_node_ptr &, const KeyType &, 
                        KeyNodePtrCompare, insert_commit_data &);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static std::pair< node_ptr, bool > 
    insert_unique_check(const const_node_ptr &, const node_ptr &, 
                        const KeyType &, KeyNodePtrCompare, 
                        insert_commit_data &);
  template<typename NodePtrCompare> 
    static node_ptr 
    insert_equal(const node_ptr &, const node_ptr &, const node_ptr &, 
                 NodePtrCompare);
  template<typename NodePtrCompare> 
    static node_ptr 
    insert_equal_upper_bound(const node_ptr &, const node_ptr &, 
                             NodePtrCompare);
  template<typename NodePtrCompare> 
    static node_ptr 
    insert_equal_lower_bound(const node_ptr &, const node_ptr &, 
                             NodePtrCompare);
  static node_ptr 
  insert_before(const node_ptr &, const node_ptr &, const node_ptr &);
  static void push_back(const node_ptr &, const node_ptr &);
  static void push_front(const node_ptr &, const node_ptr &);
  static std::size_t depth(const_node_ptr);
  template<typename Cloner, typename Disposer> 
    static void clone(const const_node_ptr &, const node_ptr &, Cloner, 
                      Disposer);
  static void erase(const node_ptr &, const node_ptr &);
  static void unlink(const node_ptr &);
  static void rebalance(const node_ptr &);
  static node_ptr rebalance_subtree(const node_ptr &);
  template<typename Checker> 
    static void check(const const_node_ptr &, Checker, 
                      typename Checker::return_type &);

  // protected static functions
  static void erase(const node_ptr &, const node_ptr &, data_for_rebalance &);
  static std::size_t subtree_size(const const_node_ptr &);
  static bool is_left_child(const node_ptr &);
  static bool is_right_child(const node_ptr &);
  static void insert_before_check(const node_ptr &, const node_ptr &, 
                                  insert_commit_data &);
  static void push_back_check(const node_ptr &, insert_commit_data &);
  static void push_front_check(const node_ptr &, insert_commit_data &);
  template<typename NodePtrCompare> 
    static void insert_equal_check(const node_ptr &, const node_ptr &, 
                                   const node_ptr &, NodePtrCompare, 
                                   insert_commit_data &);
  template<typename NodePtrCompare> 
    static void insert_equal_upper_bound_check(const node_ptr &, 
                                               const node_ptr &, 
                                               NodePtrCompare, 
                                               insert_commit_data &, 
                                               std::size_t * = 0);
  template<typename NodePtrCompare> 
    static void insert_equal_lower_bound_check(const node_ptr &, 
                                               const node_ptr &, 
                                               NodePtrCompare, 
                                               insert_commit_data &, 
                                               std::size_t * = 0);
  static void insert_commit(const node_ptr &, const node_ptr &, 
                            const insert_commit_data &);
  static void set_child(const node_ptr &, const node_ptr &, const node_ptr &, 
                        const bool);
  static void rotate_left_no_parent_fix(const node_ptr &, const node_ptr &);
  static void rotate_left(const node_ptr &, const node_ptr &, 
                          const node_ptr &, const node_ptr &);
  static void rotate_right_no_parent_fix(const node_ptr &, const node_ptr &);
  static void rotate_right(const node_ptr &, const node_ptr &, 
                           const node_ptr &, const node_ptr &);

  // private static functions
  static void subtree_to_vine(node_ptr, std::size_t &);
  static void compress_subtree(node_ptr, std::size_t);
  static void vine_to_subtree(const node_ptr &, std::size_t);
  static node_ptr get_root(const node_ptr &);
  template<typename Cloner, typename Disposer> 
    static node_ptr 
    clone_subtree(const const_node_ptr &, const node_ptr &, Cloner, Disposer, 
                  node_ptr &, node_ptr &);
  template<typename Disposer> static void dispose_subtree(node_ptr, Disposer);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static node_ptr 
    lower_bound_loop(node_ptr, node_ptr, const KeyType &, KeyNodePtrCompare);
  template<typename KeyType, typename KeyNodePtrCompare> 
    static node_ptr 
    upper_bound_loop(node_ptr, node_ptr, const KeyType &, KeyNodePtrCompare);
  template<typename Checker> 
    static void check_subtree(const const_node_ptr &, Checker, 
                              typename Checker::return_type &);
};
.fi
.SH "DESCRIPTION"
.\" set_right: Class template bstree_algorithms
.\" Class template bstree_algorithms: set_right
.\" get_right: Class template bstree_algorithms
.\" Class template bstree_algorithms: get_right
.\" set_left: Class template bstree_algorithms
.\" Class template bstree_algorithms: set_left
.\" get_left: Class template bstree_algorithms
.\" Class template bstree_algorithms: get_left
.\" set_parent: Class template bstree_algorithms
.\" Class template bstree_algorithms: set_parent
.\" get_parent: Class template bstree_algorithms
.\" Class template bstree_algorithms: get_parent
.PP
This is an implementation of a binary search tree\&. A node in the search tree has references to its children and its parent\&. This is to allow traversal of the whole tree from a given node making the implementation of iterator a pointer to a node\&. At the top of the tree a node is used specially\&. This node\'s parent pointer is pointing to the root of the tree\&. Its left pointer points to the leftmost node in the tree and the right pointer to the rightmost one\&. This node is used to represent the end\-iterator\&. +\-\-\-\-\-\-\-\-\-+ header\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->| | | | +\-\-\-\-\-\-\-\-\-\-(left)\-\-\-\-\-\-\-\-| |\-\-\-\-\-\-\-\-(right)\-\-\-\-\-\-\-\-\-+ | +\-\-\-\-\-\-\-\-\-+ | | | | | | (parent) | | | | | | | | +\-\-\-\-\-\-\-\-\-+ | root of tree \&.\&.|\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&.> | | | | | D | | | | | | | +\-\-\-\-<mdash></mdash>+\-\-\-\-\-\-<mdash></mdash>+\-\-\-\-<mdash></mdash>+ |
.TS
allbox tab(:);
l l l
l l l
l l l
l l l.
T{

T}:T{

T}:T{

T}
T{
 
T}:T{
 
T}:T{
 
T}
T{
 
T}:T{
 
T}:T{
 
T}
T{
 
T}:T{
 
T}:T{
 
T}
.TE
.sp 1
| +\-\-\-\-\-\-<mdash></mdash>+ +\-\-\-\-\-\-<mdash></mdash>+ | | | | | | | | | B | | F | | | | | | | | | +<ndash></ndash>+\-\-\-\-\-\-<mdash></mdash>+<ndash></ndash>+ +<ndash></ndash>+\-\-\-\-\-\-<mdash></mdash>+<ndash></ndash>+ |
.TS
allbox tab(:);
l l l l l
l l l l l.
T{

T}:T{

T}:T{

T}:T{

T}:T{

T}
T{
 
T}:T{
 
T}:T{
 
T}:T{
 
T}:T{
 
T}
.TE
.sp 1
| +<mdash></mdash>+\-\-<mdash></mdash>+ +\-\-<mdash></mdash>+<mdash></mdash>+ +<mdash></mdash>+\-\-<mdash></mdash>+ +\-\-<mdash></mdash>+<mdash></mdash>+ | +<ndash></ndash>>| | | | | | | |<<ndash></ndash>+ | A | | C | | E | | G | | | | | | | | | +\-\-\-\-\-\-<mdash></mdash>+ +\-\-\-\-\-\-<mdash></mdash>+ +\-\-\-\-\-\-<mdash></mdash>+ +\-\-\-\-\-\-<mdash></mdash>+
.PP
bstree_algorithms
is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated\&. NodeTraits must support the following interface:
.PP
\fBTypedefs\fR:
.PP
node: The type of the node that forms the binary search tree
.PP
node_ptr: A pointer to a node
.PP
const_node_ptr: A pointer to a const node
.PP
\fBStatic functions\fR:
.PP
static node_ptr get_parent(const_node_ptr n);
.PP
static void set_parent(node_ptr n, node_ptr parent);
.PP
static node_ptr get_left(const_node_ptr n);
.PP
static void set_left(node_ptr n, node_ptr left);
.PP
static node_ptr get_right(const_node_ptr n);
.PP
static void set_right(node_ptr n, node_ptr right);
.SS "bstree_algorithms public static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" begin_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: begin_node

.sp

.nf
static node_ptr begin_node(const const_node_ptr & header);
.fi

.sp
\fBRequires\fR: \'header\' is the header node of a tree\&.
.sp
\fBEffects\fR: Returns the first node of the tree, the header if the tree is empty\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" end_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: end_node

.sp

.nf
static node_ptr end_node(const const_node_ptr & header);
.fi

.sp
\fBRequires\fR: \'header\' is the header node of a tree\&.
.sp
\fBEffects\fR: Returns the header of the tree\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" root_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: root_node

.sp

.nf
static node_ptr root_node(const const_node_ptr & header);
.fi

.sp
\fBRequires\fR: \'header\' is the header node of a tree\&.
.sp
\fBEffects\fR: Returns the root of the tree if any, header otherwise
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" init_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: init_node
.\" init: Class template bstree_algorithms
.\" Class template bstree_algorithms: init
.\" init: Class template bstree_algorithms
.\" Class template bstree_algorithms: init
.\" unique: Class template bstree_algorithms
.\" Class template bstree_algorithms: unique

.sp

.nf
static bool unique(const const_node_ptr & node);
.fi

.sp
\fBRequires\fR: \'node\' is a node of the tree or a node initialized by init(\&.\&.\&.) or init_node\&.
.sp
\fBEffects\fR: Returns true if the node is initialized by init() or init_node()\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" get_header: Class template bstree_algorithms
.\" Class template bstree_algorithms: get_header

.sp

.nf
static node_ptr get_header(const const_node_ptr & node);
.fi

.sp
\fBRequires\fR: \'node\' is a node of the tree or a header node\&.
.sp
\fBEffects\fR: Returns the header of the tree\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" swap_nodes: Class template bstree_algorithms
.\" Class template bstree_algorithms: swap_nodes

.sp

.nf
static void swap_nodes(const node_ptr & node1, const node_ptr & node2);
.fi

.sp
\fBRequires\fR: node1 and node2 can\'t be header nodes of two trees\&.
.sp
\fBEffects\fR: Swaps two nodes\&. After the function node1 will be inserted in the position node2 before the function\&. node2 will be inserted in the position node1 had before the function\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules\&.
.sp
Experimental function
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap_nodes: Class template bstree_algorithms
.\" Class template bstree_algorithms: swap_nodes

.sp

.nf
static void swap_nodes(const node_ptr & node1, const node_ptr & header1, 
                       const node_ptr & node2, const node_ptr & header2);
.fi

.sp
\fBRequires\fR: node1 and node2 can\'t be header nodes of two trees with header header1 and header2\&.
.sp
\fBEffects\fR: Swaps two nodes\&. After the function node1 will be inserted in the position node2 before the function\&. node2 will be inserted in the position node1 had before the function\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules\&.
.sp
Experimental function
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" replace_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: replace_node

.sp

.nf
static void replace_node(const node_ptr & node_to_be_replaced, 
                         const node_ptr & new_node);
.fi

.sp
\fBRequires\fR: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree\&.
.sp
\fBEffects\fR: Replaces node_to_be_replaced in its position in the tree with new_node\&. The tree does not need to be rebalanced
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules\&. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed\&. Experimental function
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" replace_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: replace_node

.sp

.nf
static void replace_node(const node_ptr & node_to_be_replaced, 
                         const node_ptr & header, const node_ptr & new_node);
.fi

.sp
\fBRequires\fR: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree\&.
.sp
\fBEffects\fR: Replaces node_to_be_replaced in its position in the tree with new_node\&. The tree does not need to be rebalanced
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules\&. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed\&. Experimental function
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" next_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: next_node

.sp

.nf
static node_ptr next_node(const node_ptr & node);
.fi

.sp
\fBRequires\fR: \'node\' is a node from the tree except the header\&.
.sp
\fBEffects\fR: Returns the next node of the tree\&.
.sp
\fBComplexity\fR: Average constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" prev_node: Class template bstree_algorithms
.\" Class template bstree_algorithms: prev_node

.sp

.nf
static node_ptr prev_node(const node_ptr & node);
.fi

.sp
\fBRequires\fR: \'node\' is a node from the tree except the leftmost node\&.
.sp
\fBEffects\fR: Returns the previous node of the tree\&.
.sp
\fBComplexity\fR: Average constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" minimum: Class template bstree_algorithms
.\" Class template bstree_algorithms: minimum

.sp

.nf
static node_ptr minimum(node_ptr node);
.fi

.sp
\fBRequires\fR: \'node\' is a node of a tree but not the header\&.
.sp
\fBEffects\fR: Returns the minimum node of the subtree starting at p\&.
.sp
\fBComplexity\fR: Logarithmic to the size of the subtree\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" maximum: Class template bstree_algorithms
.\" Class template bstree_algorithms: maximum

.sp

.nf
static node_ptr maximum(node_ptr node);
.fi

.sp
\fBRequires\fR: \'node\' is a node of a tree but not the header\&.
.sp
\fBEffects\fR: Returns the maximum node of the subtree starting at p\&.
.sp
\fBComplexity\fR: Logarithmic to the size of the subtree\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" unique: Class template bstree_algorithms
.\" Class template bstree_algorithms: unique
.\" init: Class template bstree_algorithms
.\" Class template bstree_algorithms: init

.sp

.nf
static void init(const node_ptr & node);
.fi

.sp
\fBRequires\fR: \'node\' must not be part of any tree\&.
.sp
\fBEffects\fR: After the function unique(node) == true\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNodes\fR: If node is inserted in a tree, this function corrupts the tree\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" init: Class template bstree_algorithms
.\" Class template bstree_algorithms: init
.\" inited: Class template bstree_algorithms
.\" Class template bstree_algorithms: inited

.sp

.nf
static bool inited(const const_node_ptr & node);
.fi

.sp
\fBEffects\fR: Returns true if node is in the same state as if called init(node)
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" init_header: Class template bstree_algorithms
.\" Class template bstree_algorithms: init_header

.sp

.nf
static void init_header(const node_ptr & header);
.fi

.sp
\fBRequires\fR: node must not be part of any tree\&.
.sp
\fBEffects\fR: Initializes the header to represent an empty tree\&. unique(header) == true\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNodes\fR: If node is inserted in a tree, this function corrupts the tree\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}
.\" clear_and_dispose: Class template bstree_algorithms
.\" Class template bstree_algorithms: clear_and_dispose

.sp

.nf
template<typename Disposer> 
  static void clear_and_dispose(const node_ptr & header, Disposer disposer);
.fi

.sp
\fBRequires\fR: "disposer" must be an object function taking a node_ptr parameter and shouldn\'t throw\&.
.sp
\fBEffects\fR: Empties the target tree calling
void disposer::operator()(const node_ptr &)
for every node of the tree except the header\&.
.sp
\fBComplexity\fR: Linear to the number of element of the source tree plus the\&. number of elements of tree target tree when calling this function\&.
.sp
\fBThrows\fR: If cloner functor throws\&. If this happens target nodes are disposed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}
.\" unlink_leftmost_without_rebalance: Class template bstree_algorithms
.\" Class template bstree_algorithms: unlink_leftmost_without_rebalance

.sp

.nf
static node_ptr unlink_leftmost_without_rebalance(const node_ptr & header);
.fi

.sp
\fBRequires\fR: header is the header of a tree\&.
.sp
\fBEffects\fR: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node\&.
.sp
\fBComplexity\fR: Average complexity is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls\&. This function is normally used to achieve a step by step controlled destruction of the tree\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" size: Class template bstree_algorithms
.\" Class template bstree_algorithms: size

.sp

.nf
static std::size_t size(const const_node_ptr & header);
.fi

.sp
\fBRequires\fR: node is a node of the tree but it\'s not the header\&.
.sp
\fBEffects\fR: Returns the number of nodes of the subtree\&.
.sp
\fBComplexity\fR: Linear time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}
.\" swap_tree: Class template bstree_algorithms
.\" Class template bstree_algorithms: swap_tree

.sp

.nf
static void swap_tree(const node_ptr & header1, const node_ptr & header2);
.fi

.sp
\fBRequires\fR: header1 and header2 must be the header nodes of two trees\&.
.sp
\fBEffects\fR: Swaps two trees\&. After the function header1 will contain links to the second tree and header2 will have links to the first tree\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" is_header: Class template bstree_algorithms
.\" Class template bstree_algorithms: is_header

.sp

.nf
static bool is_header(const const_node_ptr & p);
.fi

.sp
\fBRequires\fR: p is a node of a tree\&.
.sp
\fBEffects\fR: Returns true if p is the header of the tree\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" find: Class template bstree_algorithms
.\" Class template bstree_algorithms: find

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static node_ptr 
  find(const const_node_ptr & header, const KeyType & key, 
       KeyNodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. KeyNodePtrCompare can compare KeyType with tree\'s node_ptrs\&.
.sp
\fBEffects\fR: Returns a node_ptr to the first element that is equivalent to "key" according to "comp" or "header" if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" bounded_range: Class template bstree_algorithms
.\" Class template bstree_algorithms: bounded_range

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static std::pair< node_ptr, node_ptr > 
  bounded_range(const const_node_ptr & header, const KeyType & lower_key, 
                const KeyType & upper_key, KeyNodePtrCompare comp, 
                bool left_closed, bool right_closed);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. KeyNodePtrCompare can compare KeyType with tree\'s node_ptrs\&. \'lower_key\' must not be greater than \'upper_key\' according to \'comp\'\&. If \'lower_key\' == \'upper_key\', (\'left_closed\' || \'right_closed\') must be true\&.
.sp
\fBEffects\fR: Returns an a pair with the following criteria:
.sp
first = lower_bound(lower_key) if left_closed, upper_bound(lower_key) otherwise
.sp
second = upper_bound(upper_key) if right_closed, lower_bound(upper_key) otherwise
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.sp
\fBNote\fR: This function can be more efficient than calling upper_bound and lower_bound for lower_key and upper_key\&.
.sp
\fBNote\fR: Experimental function, the interface might change\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" count: Class template bstree_algorithms
.\" Class template bstree_algorithms: count

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static std::size_t 
  count(const const_node_ptr & header, const KeyType & key, 
        KeyNodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. KeyNodePtrCompare can compare KeyType with tree\'s node_ptrs\&.
.sp
\fBEffects\fR: Returns the number of elements with a key equivalent to "key" according to "comp"\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static std::pair< node_ptr, node_ptr > 
  equal_range(const const_node_ptr & header, const KeyType & key, 
              KeyNodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. KeyNodePtrCompare can compare KeyType with tree\'s node_ptrs\&.
.sp
\fBEffects\fR: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if there are no equivalent elements\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static std::pair< node_ptr, node_ptr > 
  lower_bound_range(const const_node_ptr & header, const KeyType & key, 
                    KeyNodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. KeyNodePtrCompare can compare KeyType with tree\'s node_ptrs\&.
.sp
\fBEffects\fR: Returns an a pair of node_ptr delimiting a range containing the first element that is equivalent to "key" according to "comp" or an empty range that indicates the position where that element would be if there are no equivalent elements\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" lower_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: lower_bound

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static node_ptr 
  lower_bound(const const_node_ptr & header, const KeyType & key, 
              KeyNodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. KeyNodePtrCompare can compare KeyType with tree\'s node_ptrs\&.
.sp
\fBEffects\fR: Returns a node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" upper_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: upper_bound

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static node_ptr 
  upper_bound(const const_node_ptr & header, const KeyType & key, 
              KeyNodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. KeyNodePtrCompare can compare KeyType with tree\'s node_ptrs\&.
.sp
\fBEffects\fR: Returns a node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" insert_unique_commit: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_unique_commit

.sp

.nf
static void insert_unique_commit(const node_ptr & header, 
                                 const node_ptr & new_value, 
                                 const insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. "commit_data" must have been obtained from a previous call to "insert_unique_check"\&. No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit"\&.
.sp
\fBEffects\fR: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled\&.
.sp
\fBComplexity\fR: Constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNotes\fR: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data"\&. No value should be inserted or erased between the "insert_check" and "insert_commit" calls\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" insert_unique_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_unique_check

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static std::pair< node_ptr, bool > 
  insert_unique_check(const const_node_ptr & header, const KeyType & key, 
                      KeyNodePtrCompare comp, 
                      insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. NodePtrCompare compares KeyType with a node_ptr\&.
.sp
\fBEffects\fR: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant\-time node insertion if there is no equivalent node\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false\&. If there is not equivalent key can be inserted returns true in the returned pair\'s boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant\-time insertion function\&.
.sp
\fBComplexity\fR: Average complexity is at most logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant\-time\&. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1))\&.
.sp
"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" insert_unique_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_unique_check

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static std::pair< node_ptr, bool > 
  insert_unique_check(const const_node_ptr & header, const node_ptr & hint, 
                      const KeyType & key, KeyNodePtrCompare comp, 
                      insert_commit_data & commit_data);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. NodePtrCompare compares KeyType with a node_ptr\&. "hint" is node from the "header"\'s tree\&.
.sp
\fBEffects\fR: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant\-time node insertion if there is no equivalent node\&. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case)\&.
.sp
\fBReturns\fR: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false\&. If there is not equivalent key can be inserted returns true in the returned pair\'s boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant\-time insertion function\&.
.sp
\fBComplexity\fR: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint"\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.sp
\fBNotes\fR: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded\&. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful\&.
.sp
If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant\-time\&. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1))\&.
.sp
"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}
.\" insert_equal: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal

.sp

.nf
template<typename NodePtrCompare> 
  static node_ptr 
  insert_equal(const node_ptr & h, const node_ptr & hint, 
               const node_ptr & new_node, NodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. NodePtrCompare compares two node_ptrs\&. "hint" is node from the "header"\'s tree\&.
.sp
\fBEffects\fR: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted\&. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)\&.
.sp
\fBComplexity\fR: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint"\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}
.\" insert_equal_upper_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_upper_bound

.sp

.nf
template<typename NodePtrCompare> 
  static node_ptr 
  insert_equal_upper_bound(const node_ptr & h, const node_ptr & new_node, 
                           NodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "h" must be the header node of a tree\&. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. NodePtrCompare compares two node_ptrs\&.
.sp
\fBEffects\fR: Inserts new_node into the tree before the upper bound according to "comp"\&.
.sp
\fBComplexity\fR: Average complexity for insert element is at most logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" insert_equal_lower_bound: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_lower_bound

.sp

.nf
template<typename NodePtrCompare> 
  static node_ptr 
  insert_equal_lower_bound(const node_ptr & h, const node_ptr & new_node, 
                           NodePtrCompare comp);
.fi

.sp
\fBRequires\fR: "h" must be the header node of a tree\&. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree\&. NodePtrCompare compares two node_ptrs\&.
.sp
\fBEffects\fR: Inserts new_node into the tree before the lower bound according to "comp"\&.
.sp
\fBComplexity\fR: Average complexity for insert element is at most logarithmic\&.
.sp
\fBThrows\fR: If "comp" throws\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" insert_before: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_before

.sp

.nf
static node_ptr 
insert_before(const node_ptr & header, const node_ptr & pos, 
              const node_ptr & new_node);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. "pos" must be a valid iterator or header (end) node\&. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes\&. This function does not check "pos" and this precondition must be guaranteed by the caller\&.
.sp
\fBEffects\fR: Inserts new_node into the tree before "pos"\&.
.sp
\fBComplexity\fR: Constant\-time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" push_back: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_back

.sp

.nf
static void push_back(const node_ptr & header, const node_ptr & new_node);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. "new_node" must be, according to the used ordering no less than the greatest inserted key\&.
.sp
\fBEffects\fR: Inserts new_node into the tree before "pos"\&.
.sp
\fBComplexity\fR: Constant\-time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: If "new_node" is less than the greatest inserted key tree invariants are broken\&. This function is slightly faster than using "insert_before"\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" push_front: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_front

.sp

.nf
static void push_front(const node_ptr & header, const node_ptr & new_node);
.fi

.sp
\fBRequires\fR: "header" must be the header node of a tree\&. "new_node" must be, according to the used ordering, no greater than the lowest inserted key\&.
.sp
\fBEffects\fR: Inserts new_node into the tree before "pos"\&.
.sp
\fBComplexity\fR: Constant\-time\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBNote\fR: If "new_node" is greater than the lowest inserted key tree invariants are broken\&. This function is slightly faster than using "insert_before"\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" depth: Class template bstree_algorithms
.\" Class template bstree_algorithms: depth

.sp

.nf
static std::size_t depth(const_node_ptr node);
.fi

.sp
\fBRequires\fR: \'node\' can\'t be a header node\&.
.sp
\fBEffects\fR: Calculates the depth of a node: the depth of a node is the length (number of edges) of the path from the root to that node\&. (The root node is at depth 0\&.)
.sp
\fBComplexity\fR: Logarithmic to the number of nodes in the tree\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" clone: Class template bstree_algorithms
.\" Class template bstree_algorithms: clone

.sp

.nf
template<typename Cloner, typename Disposer> 
  static void clone(const const_node_ptr & source_header, 
                    const node_ptr & target_header, Cloner cloner, 
                    Disposer disposer);
.fi

.sp
\fBRequires\fR: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it\&. "disposer" must take a node_ptr and shouldn\'t throw\&.
.sp
\fBEffects\fR: First empties target tree calling
void disposer::operator()(const node_ptr &)
for every node of the tree except the header\&.
.sp
Then, duplicates the entire tree pointed by "source_header" cloning each source node with
node_ptr Cloner::operator()(const node_ptr &)
to obtain the nodes of the target tree\&. If "cloner" throws, the cloned target nodes are disposed using
void disposer(const node_ptr &)\&.
.sp
\fBComplexity\fR: Linear to the number of element of the source tree plus the number of elements of tree target tree when calling this function\&.
.sp
\fBThrows\fR: If cloner functor throws\&. If this happens target nodes are disposed\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" erase: Class template bstree_algorithms
.\" Class template bstree_algorithms: erase

.sp

.nf
static void erase(const node_ptr & header, const node_ptr & z);
.fi

.sp
\fBRequires\fR: header must be the header of a tree, z a node of that tree and z != header\&.
.sp
\fBEffects\fR: Erases node "z" from the tree with header "header"\&.
.sp
\fBComplexity\fR: Amortized constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" unlink: Class template bstree_algorithms
.\" Class template bstree_algorithms: unlink

.sp

.nf
static void unlink(const node_ptr & node);
.fi

.sp
\fBRequires\fR: node is a tree node but not the header\&.
.sp
\fBEffects\fR: Unlinks the node and rebalances the tree\&.
.sp
\fBComplexity\fR: Average complexity is constant time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}
.\" rebalance: Class template bstree_algorithms
.\" Class template bstree_algorithms: rebalance

.sp

.nf
static void rebalance(const node_ptr & header);
.fi

.sp
\fBRequires\fR: header must be the header of a tree\&.
.sp
\fBEffects\fR: Rebalances the tree\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}
.\" rebalance_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: rebalance_subtree

.sp

.nf
static node_ptr rebalance_subtree(const node_ptr & old_root);
.fi

.sp
\fBRequires\fR: old_root is a node of a tree\&. It shall not be null\&.
.sp
\fBEffects\fR: Rebalances the subtree rooted at old_root\&.
.sp
\fBReturns\fR: The new root of the subtree\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Linear\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}
.\" check: Class template bstree_algorithms
.\" Class template bstree_algorithms: check

.sp

.nf
template<typename Checker> 
  static void check(const const_node_ptr & header, Checker checker, 
                    typename Checker::return_type & checker_return);
.fi

.sp
\fBEffects\fR: Asserts the integrity of the container with additional checks provided by the user\&.
.sp
\fBRequires\fR: header must be the header of a tree\&.
.sp
\fBComplexity\fR: Linear time\&.
.sp
\fBNote\fR: The method might not have effect when asserts are turned off (e\&.g\&., with NDEBUG)\&. Experimental function, interface might change in future versions\&.
.RE

.SS "bstree_algorithms protected static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" erase: Class template bstree_algorithms
.\" Class template bstree_algorithms: erase

.sp

.nf
static void erase(const node_ptr & header, const node_ptr & z, 
                  data_for_rebalance & info);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" subtree_size: Class template bstree_algorithms
.\" Class template bstree_algorithms: subtree_size

.sp

.nf
static std::size_t subtree_size(const const_node_ptr & subtree);
.fi

.sp
\fBRequires\fR: node is a node of the tree but it\'s not the header\&.
.sp
\fBEffects\fR: Returns the number of nodes of the subtree\&.
.sp
\fBComplexity\fR: Linear time\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" is_left_child: Class template bstree_algorithms
.\" Class template bstree_algorithms: is_left_child

.sp

.nf
static bool is_left_child(const node_ptr & p);
.fi

.sp
\fBRequires\fR: p is a node of a tree\&.
.sp
\fBEffects\fR: Returns true if p is a left child\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" is_right_child: Class template bstree_algorithms
.\" Class template bstree_algorithms: is_right_child

.sp

.nf
static bool is_right_child(const node_ptr & p);
.fi

.sp
\fBRequires\fR: p is a node of a tree\&.
.sp
\fBEffects\fR: Returns true if p is a right child\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" insert_before_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_before_check

.sp

.nf
static void insert_before_check(const node_ptr & header, const node_ptr & pos, 
                                insert_commit_data & commit_data);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" push_back_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_back_check

.sp

.nf
static void push_back_check(const node_ptr & header, 
                            insert_commit_data & commit_data);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" push_front_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: push_front_check

.sp

.nf
static void push_front_check(const node_ptr & header, 
                             insert_commit_data & commit_data);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" insert_equal_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_check

.sp

.nf
template<typename NodePtrCompare> 
  static void insert_equal_check(const node_ptr & header, 
                                 const node_ptr & hint, 
                                 const node_ptr & new_node, 
                                 NodePtrCompare comp, 
                                 insert_commit_data & commit_data);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" insert_equal_upper_bound_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_upper_bound_check

.sp

.nf
template<typename NodePtrCompare> 
  static void insert_equal_upper_bound_check(const node_ptr & h, 
                                             const node_ptr & new_node, 
                                             NodePtrCompare comp, 
                                             insert_commit_data & commit_data, 
                                             std::size_t * pdepth = 0);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" insert_equal_lower_bound_check: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_equal_lower_bound_check

.sp

.nf
template<typename NodePtrCompare> 
  static void insert_equal_lower_bound_check(const node_ptr & h, 
                                             const node_ptr & new_node, 
                                             NodePtrCompare comp, 
                                             insert_commit_data & commit_data, 
                                             std::size_t * pdepth = 0);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" insert_commit: Class template bstree_algorithms
.\" Class template bstree_algorithms: insert_commit

.sp

.nf
static void insert_commit(const node_ptr & header, const node_ptr & new_node, 
                          const insert_commit_data & commit_data);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}
.\" set_child: Class template bstree_algorithms
.\" Class template bstree_algorithms: set_child

.sp

.nf
static void set_child(const node_ptr & header, const node_ptr & new_child, 
                      const node_ptr & new_parent, const bool link_left);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rotate_left_no_parent_fix: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_left_no_parent_fix

.sp

.nf
static void rotate_left_no_parent_fix(const node_ptr & p, 
                                      const node_ptr & p_right);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rotate_left: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_left

.sp

.nf
static void rotate_left(const node_ptr & p, const node_ptr & p_right, 
                        const node_ptr & p_parent, const node_ptr & header);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}
.\" rotate_right_no_parent_fix: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_right_no_parent_fix

.sp

.nf
static void rotate_right_no_parent_fix(const node_ptr & p, 
                                       const node_ptr & p_left);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}
.\" rotate_right: Class template bstree_algorithms
.\" Class template bstree_algorithms: rotate_right

.sp

.nf
static void rotate_right(const node_ptr & p, const node_ptr & p_left, 
                         const node_ptr & p_parent, const node_ptr & header);
.fi

.RE

.SS "bstree_algorithms private static functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
.\" subtree_to_vine: Class template bstree_algorithms
.\" Class template bstree_algorithms: subtree_to_vine

.sp

.nf
static void subtree_to_vine(node_ptr vine_tail, std::size_t & size);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" compress_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: compress_subtree

.sp

.nf
static void compress_subtree(node_ptr scanner, std::size_t count);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" vine_to_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: vine_to_subtree

.sp

.nf
static void vine_to_subtree(const node_ptr & super_root, std::size_t count);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" get_root: Class template bstree_algorithms
.\" Class template bstree_algorithms: get_root

.sp

.nf
static node_ptr get_root(const node_ptr & node);
.fi

.sp
\fBRequires\fR: "n" must be a node inserted in a tree\&.
.sp
\fBEffects\fR: Returns a pointer to the header node of the tree\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.sp
\fBThrows\fR: Nothing\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" clone_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: clone_subtree

.sp

.nf
template<typename Cloner, typename Disposer> 
  static node_ptr 
  clone_subtree(const const_node_ptr & source_parent, 
                const node_ptr & target_parent, Cloner cloner, 
                Disposer disposer, node_ptr & leftmost_out, 
                node_ptr & rightmost_out);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
.\" dispose_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: dispose_subtree

.sp

.nf
template<typename Disposer> 
  static void dispose_subtree(node_ptr x, Disposer disposer);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" lower_bound_loop: Class template bstree_algorithms
.\" Class template bstree_algorithms: lower_bound_loop

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static node_ptr 
  lower_bound_loop(node_ptr x, node_ptr y, const KeyType & key, 
                   KeyNodePtrCompare comp);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" upper_bound_loop: Class template bstree_algorithms
.\" Class template bstree_algorithms: upper_bound_loop

.sp

.nf
template<typename KeyType, typename KeyNodePtrCompare> 
  static node_ptr 
  upper_bound_loop(node_ptr x, node_ptr y, const KeyType & key, 
                   KeyNodePtrCompare comp);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}
.\" check_subtree: Class template bstree_algorithms
.\" Class template bstree_algorithms: check_subtree

.sp

.nf
template<typename Checker> 
  static void check_subtree(const const_node_ptr & node, Checker checker, 
                            typename Checker::return_type & check_return);
.fi

.RE


