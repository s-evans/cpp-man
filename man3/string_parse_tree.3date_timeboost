.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "STRUCT TEMPL" 3 "" "" ""
.SH "NAME"
boost::date_time::string_parse_tree \- Recursive data structure to allow efficient parsing of various strings\&.
.SH "SYNOPSIS"

.sp
.nf
// In header: <boost/date_time/string_parse_tree\&.hpp>

template<typename charT> 
struct string_parse_tree {
  // types
  typedef std::multimap< charT, string_parse_tree< charT > > ptree_coll;             
  typedef std::multimap< charT, string_parse_tree >          ptree_coll;             
  typedef ptree_coll::value_type                             value_type;             
  typedef ptree_coll::iterator                               iterator;               
  typedef ptree_coll::const_iterator                         const_iterator;         
  typedef std::basic_string< charT >                         string_type;            
  typedef std::vector< std::basic_string< charT > >          collection_type;        
  typedef parse_match_result< charT >                        parse_match_result_type;

  // construct/copy/destruct
  string_parse_tree(collection_type, unsigned int = 0);
  string_parse_tree(short = \-1);

  // public member functions
  void insert(const string_type &, unsigned short);
  short match(std::istreambuf_iterator< charT > &, 
              std::istreambuf_iterator< charT > &, parse_match_result_type &, 
              unsigned int &) const;
  parse_match_result_type 
  match(std::istreambuf_iterator< charT > &, 
        std::istreambuf_iterator< charT > &) const;
  void printme(std::ostream &, int &);
  void print(std::ostream &);
  void printmatch(std::ostream &, charT);

  // public data members
  ptree_coll m_next_chars;
  short m_value;
};
.fi
.SH "DESCRIPTION"
.PP
This class provides a quick lookup by building what amounts to a tree data structure\&. It also features a match function which can can handle nasty input interators by caching values as it recurses the tree so that it can backtrack as needed\&.
.SS "string_parse_tree public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
string_parse_tree(collection_type names, unsigned int starting_point = 0);
.fi

.sp
Parameter "starting_point" designates where the numbering begins\&. A starting_point of zero will start the numbering at zero (Sun=0, Mon=1, \&.\&.\&.) were a starting_point of one starts the numbering at one (Jan=1, Feb=2, \&.\&.\&.)\&. The default is zero, negative vaules are not allowed
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
string_parse_tree(short value = \-1);
.fi

.RE

.SS "string_parse_tree public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
void insert(const string_type & s, unsigned short value);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
short match(std::istreambuf_iterator< charT > & sitr, 
            std::istreambuf_iterator< charT > & stream_end, 
            parse_match_result_type & result, unsigned int & level) const;
.fi

.sp
Recursive function that finds a matching string in the tree\&. Must check match_results::has_remaining() after match() is called\&. This is required so the user can determine if stream iterator is already pointing to the expected character or not (match() might advance sitr to next char in stream)\&.
.sp
A
parse_match_result
that has been returned from a failed match attempt can be sent in to the match function of a different
string_parse_tree
to attempt a match there\&. Use the iterators for the partially consumed stream, the
parse_match_result
object, and \'0\' for the level parameter\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
parse_match_result_type 
match(std::istreambuf_iterator< charT > & sitr, 
      std::istreambuf_iterator< charT > & stream_end) const;
.fi

.sp
Must check match_results::has_remaining() after match() is called\&. This is required so the user can determine if stream iterator is already pointing to the expected character or not (match() might advance sitr to next char in stream)\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
void printme(std::ostream & os, int & level);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
void print(std::ostream & os);
.fi

.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
void printmatch(std::ostream & os, charT c);
.fi

.RE


