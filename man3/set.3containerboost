.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "CLASS TEMPLATE SET" 3 "" "" ""
.SH "NAME"
boost::container::set
.SH "SYNOPSIS"
.\" value_type: Class template set
.\" Class template set: value_type
.\" value_compare: Class template set
.\" Class template set: value_compare
.\" upper_bound: Class template set
.\" Class template set: upper_bound
.\" swap: Class template set
.\" Class template set: swap
.\" stored_allocator_type: Class template set
.\" Class template set: stored_allocator_type
.\" size_type: Class template set
.\" Class template set: size_type
.\" reverse_iterator: Class template set
.\" Class template set: reverse_iterator
.\" rend: Class template set
.\" Class template set: rend
.\" reference: Class template set
.\" Class template set: reference
.\" rebalance: Class template set
.\" Class template set: rebalance
.\" rbegin: Class template set
.\" Class template set: rbegin
.\" pointer: Class template set
.\" Class template set: pointer
.\" lower_bound: Class template set
.\" Class template set: lower_bound
.\" key_type: Class template set
.\" Class template set: key_type
.\" key_compare: Class template set
.\" Class template set: key_compare
.\" iterator: Class template set
.\" Class template set: iterator
.\" insert: Class template set
.\" Class template set: insert
.\" get_stored_allocator: Class template set
.\" Class template set: get_stored_allocator
.\" find: Class template set
.\" Class template set: find
.\" erase: Class template set
.\" Class template set: erase
.\" end: Class template set
.\" Class template set: end
.\" emplace: Class template set
.\" Class template set: emplace
.\" difference_type: Class template set
.\" Class template set: difference_type
.\" count: Class template set
.\" Class template set: count
.\" const_reverse_iterator: Class template set
.\" Class template set: const_reverse_iterator
.\" const_reference: Class template set
.\" Class template set: const_reference
.\" const_pointer: Class template set
.\" Class template set: const_pointer
.\" const_iterator: Class template set
.\" Class template set: const_iterator
.\" clear: Class template set
.\" Class template set: clear
.\" begin: Class template set
.\" Class template set: begin
.\" allocator_type: Class template set
.\" Class template set: allocator_type
.\" allocator_traits_type: Class template set
.\" Class template set: allocator_traits_type

.sp
.nf
// In header: <boost/container/set\&.hpp>

template<typename Key, typename Compare = std::less<Key>, 
         typename Allocator = new_allocator<Key>, 
         typename SetOptions = tree_assoc_defaults> 
class set {
public:
  // types
  typedef Key                                                                key_type;              
  typedef Key                                                                value_type;            
  typedef Compare                                                            key_compare;           
  typedef Compare                                                            value_compare;         
  typedef ::boost::container::allocator_traits< Allocator >                  allocator_traits_type; 
  typedef ::boost::container::allocator_traits< Allocator >::pointer         pointer;               
  typedef ::boost::container::allocator_traits< Allocator >::const_pointer   const_pointer;         
  typedef ::boost::container::allocator_traits< Allocator >::reference       reference;             
  typedef ::boost::container::allocator_traits< Allocator >::const_reference const_reference;       
  typedef ::boost::container::allocator_traits< Allocator >::size_type       size_type;             
  typedef ::boost::container::allocator_traits< Allocator >::difference_type difference_type;       
  typedef Allocator                                                          allocator_type;        
  typedef implementation_defined                                             stored_allocator_type; 
  typedef implementation_defined                                             iterator;              
  typedef implementation_defined                                             const_iterator;        
  typedef implementation_defined                                             reverse_iterator;      
  typedef implementation_defined                                             const_reverse_iterator;

  // construct/copy/destruct
  set();
  explicit set(const Compare &, const allocator_type & = allocator_type());
  explicit set(const allocator_type &);
  template<typename InputIterator> 
    set(InputIterator, InputIterator, const Compare & = Compare(), 
        const allocator_type & = allocator_type());
  template<typename InputIterator> 
    set(InputIterator, InputIterator, const allocator_type &);
  template<typename InputIterator> 
    set(ordered_unique_range_t, InputIterator, InputIterator, 
        const Compare & = Compare(), 
        const allocator_type & = allocator_type());
  set(std::initializer_list< value_type >, const Compare & = Compare(), 
      const allocator_type & = allocator_type());
  set(std::initializer_list< value_type >, const allocator_type &);
  set(ordered_unique_range_t, std::initializer_list< value_type >, 
      const Compare & = Compare(), const allocator_type & = allocator_type());
  set(const set &);
  set(set &&);
  set(const set &, const allocator_type &);
  set(set &&, const allocator_type &);
  set & operator=(const set &);
  set & operator=(set &&) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
  set & operator=(std::initializer_list< value_type >);

  // public member functions
  allocator_type get_allocator() const;
  stored_allocator_type & get_stored_allocator();
  const stored_allocator_type & get_stored_allocator() const;
  iterator begin();
  const_iterator begin() const;
  const_iterator cbegin() const;
  iterator end();
  const_iterator end() const;
  const_iterator cend() const;
  reverse_iterator rbegin();
  const_reverse_iterator rbegin() const;
  const_reverse_iterator crbegin() const;
  reverse_iterator rend();
  const_reverse_iterator rend() const;
  const_reverse_iterator crend() const;
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  template<class\&.\&.\&. Args> std::pair< iterator, bool > emplace(Args &&\&.\&.\&.);
  template<class\&.\&.\&. Args> iterator emplace_hint(const_iterator, Args &&\&.\&.\&.);
  std::pair< iterator, bool > insert(const value_type &);
  std::pair< iterator, bool > insert(value_type &&);
  iterator insert(const_iterator, const value_type &);
  iterator insert(const_iterator, value_type &&);
  template<typename InputIterator> void insert(InputIterator, InputIterator);
  void insert(std::initializer_list< value_type >);
  iterator erase(const_iterator);
  size_type erase(const key_type &);
  iterator erase(const_iterator, const_iterator);
  void swap(set &) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
  void clear();
  key_compare key_comp() const;
  value_compare value_comp() const;
  iterator find(const key_type &);
  const_iterator find(const key_type &) const;
  size_type count(const key_type &) const;
  size_type count(const key_type &);
  iterator lower_bound(const key_type &);
  const_iterator lower_bound(const key_type &) const;
  iterator upper_bound(const key_type &);
  const_iterator upper_bound(const key_type &) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  std::pair< iterator, iterator > equal_range(const key_type &);
  std::pair< const_iterator, const_iterator > 
  equal_range(const key_type &) const;
  void rebalance();

  // friend functions
  friend bool operator==(const set &, const set &);
  friend bool operator!=(const set &, const set &);
  friend bool operator<(const set &, const set &);
  friend bool operator>(const set &, const set &);
  friend bool operator<=(const set &, const set &);
  friend bool operator>=(const set &, const set &);
  friend void swap(set &, set &);
};
.fi
.SH "DESCRIPTION"
.PP
A set is a kind of associative container that supports unique keys (contains at most one of each key value) and provides for fast retrieval of the keys themselves\&. Class set supports bidirectional iterators\&.
.PP
A set satisfies all of the requirements of a container and of a reversible container , and of an associative container\&. A set also provides most operations described in for unique keys\&.
.PP

.SS "Template Parameters"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
typename Key
.fi

.sp
is the type to be inserted in the set, which is also the key_type
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
typename Compare = std::less<Key>
.fi

.sp
is the comparison functor used to order keys
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
typename Allocator = new_allocator<Key>
.fi

.sp
is the allocator to be used to allocate memory for this container
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
typename SetOptions = tree_assoc_defaults
.fi

.sp
is an packed option type generated using using boost::container::tree_assoc_options\&.
.RE

.SS "set public construct/copy/destruct"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
set();
.fi

.sp
\fBEffects\fR: Default constructs an empty set\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
explicit set(const Compare & comp, 
             const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
explicit set(const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified allocator object\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  set(InputIterator first, InputIterator last, 
      const Compare & comp = Compare(), 
      const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  set(InputIterator first, InputIterator last, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified allocator, and inserts elements from the range [first ,last )\&.
.sp
\fBComplexity\fR: Linear in N if the range [first ,last ) is already sorted using comp and otherwise N logN, where N is last \- first\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
template<typename InputIterator> 
  set(ordered_unique_range_t, InputIterator first, InputIterator last, 
      const Compare & comp = Compare(), 
      const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the ordered unique range [first ,last)\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [first ,last) must be ordered according to the predicate and must be unique values\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}

.sp

.nf
set(std::initializer_list< value_type > il, const Compare & comp = Compare(), 
    const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is il\&.begin() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}

.sp

.nf
set(std::initializer_list< value_type > il, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified allocator, and inserts elements from the range [il\&.begin(), il\&.end())\&.
.sp
\fBComplexity\fR: Linear in N if the range [il\&.begin(), il\&.end()) is already sorted using comp and otherwise N logN, where N is il\&.begin() \- il\&.end()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
set(ordered_unique_range_t, std::initializer_list< value_type > il, 
    const Compare & comp = Compare(), 
    const allocator_type & a = allocator_type());
.fi

.sp
\fBEffects\fR: Constructs an empty set using the specified comparison object and allocator, and inserts elements from the ordered unique range [il\&.begin(), il\&.end())\&. This function is more efficient than the normal range creation for ordered ranges\&.
.sp
\fBRequires\fR: [il\&.begin(), il\&.end()) must be ordered according to the predicate and must be unique values\&.
.sp
\fBComplexity\fR: Linear in N\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}

.sp

.nf
set(const set & x);
.fi

.sp
\fBEffects\fR: Copy constructs a set\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}

.sp

.nf
set(set && x);
.fi

.sp
\fBEffects\fR: Move constructs a set\&. Constructs *this using x\'s resources\&.
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBPostcondition\fR: x is emptied\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
set(const set & x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Copy constructs a set using the specified allocator\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}

.sp

.nf
set(set && x, const allocator_type & a);
.fi

.sp
\fBEffects\fR: Move constructs a set using the specified allocator\&. Constructs *this using x\'s resources\&.
.sp
\fBComplexity\fR: Constant if a == x\&.get_allocator(), linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}

.sp

.nf
set & operator=(const set & x);
.fi

.sp
\fBEffects\fR: Makes *this a copy of x\&.
.sp
\fBComplexity\fR: Linear in x\&.size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
set & operator=(set && x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_move_assignable< Compare >::value));
.fi

.sp
\fBEffects\fR: this\->swap(x\&.get())\&.
.sp
\fBThrows\fR: If allocator_traits_type::propagate_on_container_move_assignment is false and (allocation throws or value_type\'s move constructor throws)
.sp
\fBComplexity\fR: Constant if allocator_traits_type:: propagate_on_container_move_assignment is true or this\->get>allocator() == x\&.get_allocator()\&. Linear otherwise\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
set & operator=(std::initializer_list< value_type > il);
.fi

.RE

.SS "set public member functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
allocator_type get_allocator() const;
.fi

.sp
\fBEffects\fR: Returns a copy of the allocator that was passed to the object\'s constructor\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
.\" get_stored_allocator: Class template set
.\" Class template set: get_stored_allocator

.sp

.nf
stored_allocator_type & get_stored_allocator();
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
.\" get_stored_allocator: Class template set
.\" Class template set: get_stored_allocator

.sp

.nf
const stored_allocator_type & get_stored_allocator() const;
.fi

.sp
\fBEffects\fR: Returns a reference to the internal allocator\&.
.sp
\fBThrows\fR: Nothing
.sp
\fBComplexity\fR: Constant\&.
.sp
\fBNote\fR: Non\-standard extension\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
.\" begin: Class template set
.\" Class template set: begin

.sp

.nf
iterator begin();
.fi

.sp
\fBEffects\fR: Returns an iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
.\" begin: Class template set
.\" Class template set: begin

.sp

.nf
const_iterator begin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
const_iterator cbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the first element contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" end: Class template set
.\" Class template set: end

.sp

.nf
iterator end();
.fi

.sp
\fBEffects\fR: Returns an iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
.\" end: Class template set
.\" Class template set: end

.sp

.nf
const_iterator end() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 9.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  9." 4.2
.\}

.sp

.nf
const_iterator cend() const;
.fi

.sp
\fBEffects\fR: Returns a const_iterator to the end of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'10.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "10." 4.2
.\}
.\" rbegin: Class template set
.\" Class template set: rbegin

.sp

.nf
reverse_iterator rbegin();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'11.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "11." 4.2
.\}
.\" rbegin: Class template set
.\" Class template set: rbegin

.sp

.nf
const_reverse_iterator rbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'12.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "12." 4.2
.\}

.sp

.nf
const_reverse_iterator crbegin() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the beginning of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'13.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "13." 4.2
.\}
.\" rend: Class template set
.\" Class template set: rend

.sp

.nf
reverse_iterator rend();
.fi

.sp
\fBEffects\fR: Returns a reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'14.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "14." 4.2
.\}
.\" rend: Class template set
.\" Class template set: rend

.sp

.nf
const_reverse_iterator rend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'15.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "15." 4.2
.\}

.sp

.nf
const_reverse_iterator crend() const;
.fi

.sp
\fBEffects\fR: Returns a const_reverse_iterator pointing to the end of the reversed container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'16.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "16." 4.2
.\}

.sp

.nf
bool empty() const;
.fi

.sp
\fBEffects\fR: Returns true if the container contains no elements\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'17.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "17." 4.2
.\}

.sp

.nf
size_type size() const;
.fi

.sp
\fBEffects\fR: Returns the number of the elements contained in the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'18.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "18." 4.2
.\}

.sp

.nf
size_type max_size() const;
.fi

.sp
\fBEffects\fR: Returns the largest possible size of the container\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'19.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "19." 4.2
.\}
.\" emplace: Class template set
.\" Class template set: emplace

.sp

.nf
template<class\&.\&.\&. Args> std::pair< iterator, bool > emplace(Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object x of type Key constructed with std::forward<Args>(args)\&.\&.\&. if and only if there is no element in the container with equivalent value\&. and returns the iterator pointing to the newly inserted element\&.
.sp
\fBReturns\fR: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x\&.
.sp
\fBThrows\fR: If memory allocation throws or Key\'s in\-place constructor throws\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'20.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "20." 4.2
.\}

.sp

.nf
template<class\&.\&.\&. Args> 
  iterator emplace_hint(const_iterator p, Args &&\&.\&.\&. args);
.fi

.sp
\fBEffects\fR: Inserts an object of type Key constructed with std::forward<Args>(args)\&.\&.\&. if and only if there is no element in the container with equivalent value\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'21.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "21." 4.2
.\}
.\" insert: Class template set
.\" Class template set: insert

.sp

.nf
std::pair< iterator, bool > insert(const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts x if and only if there is no element in the container with key equivalent to the key of x\&.
.sp
\fBReturns\fR: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'22.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "22." 4.2
.\}
.\" insert: Class template set
.\" Class template set: insert

.sp

.nf
std::pair< iterator, bool > insert(value_type && x);
.fi

.sp
\fBEffects\fR: Move constructs a new value from x if and only if there is no element in the container with key equivalent to the key of x\&.
.sp
\fBReturns\fR: The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'23.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "23." 4.2
.\}
.\" insert: Class template set
.\" Class template set: insert

.sp

.nf
iterator insert(const_iterator p, const value_type & x);
.fi

.sp
\fBEffects\fR: Inserts a copy of x in the container if and only if there is no element in the container with key equivalent to the key of x\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic in general, but amortized constant if t is inserted right before p\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'24.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "24." 4.2
.\}
.\" insert: Class template set
.\" Class template set: insert

.sp

.nf
iterator insert(const_iterator p, value_type && x);
.fi

.sp
\fBEffects\fR: Inserts an element move constructed from x in the container\&. p is a hint pointing to where the insert should start to search\&.
.sp
\fBReturns\fR: An iterator pointing to the element with key equivalent to the key of x\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'25.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "25." 4.2
.\}
.\" insert: Class template set
.\" Class template set: insert

.sp

.nf
template<typename InputIterator> 
  void insert(InputIterator first, InputIterator last);
.fi

.sp
\fBRequires\fR: first, last are not iterators into *this\&.
.sp
\fBEffects\fR: inserts each element from the range [first,last) if and only if there is no element with key equivalent to the key of that element\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from first to last)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'26.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "26." 4.2
.\}
.\" insert: Class template set
.\" Class template set: insert

.sp

.nf
void insert(std::initializer_list< value_type > il);
.fi

.sp
\fBEffects\fR: inserts each element from the range [il\&.begin(),il\&.end()) if and only if there is no element with key equivalent to the key of that element\&.
.sp
\fBComplexity\fR: At most N log(size()+N) (N is the distance from il\&.begin() to il\&.end())
.RE


.sp
.RS 4
.ie n \{\
\h'-04'27.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "27." 4.2
.\}
.\" end: Class template set
.\" Class template set: end
.\" erase: Class template set
.\" Class template set: erase

.sp

.nf
iterator erase(const_iterator p);
.fi

.sp
\fBEffects\fR: Erases the element pointed to by p\&.
.sp
\fBReturns\fR: Returns an iterator pointing to the element immediately following q prior to the element being erased\&. If no such element exists, returns end()\&.
.sp
\fBComplexity\fR: Amortized constant time
.RE


.sp
.RS 4
.ie n \{\
\h'-04'28.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "28." 4.2
.\}
.\" erase: Class template set
.\" Class template set: erase

.sp

.nf
size_type erase(const key_type & x);
.fi

.sp
\fBEffects\fR: Erases all elements in the container with key equivalent to x\&.
.sp
\fBReturns\fR: Returns the number of erased elements\&.
.sp
\fBComplexity\fR: log(size()) + count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'29.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "29." 4.2
.\}
.\" erase: Class template set
.\" Class template set: erase

.sp

.nf
iterator erase(const_iterator first, const_iterator last);
.fi

.sp
\fBEffects\fR: Erases all the elements in the range [first, last)\&.
.sp
\fBReturns\fR: Returns last\&.
.sp
\fBComplexity\fR: log(size())+N where N is the distance from first to last\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'30.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "30." 4.2
.\}
.\" swap: Class template set
.\" Class template set: swap

.sp

.nf
void swap(set & x) noexcept(allocator_traits_type::is_always_equal::value &&boost::container::container_detail::is_nothrow_swappable< Compare >::value));
.fi

.sp
\fBEffects\fR: Swaps the contents of *this and x\&.
.sp
\fBThrows\fR: Nothing\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'31.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "31." 4.2
.\}
.\" clear: Class template set
.\" Class template set: clear

.sp

.nf
void clear();
.fi

.sp
\fBEffects\fR: erase(a\&.begin(),a\&.end())\&.
.sp
\fBPostcondition\fR: size() == 0\&.
.sp
\fBComplexity\fR: linear in size()\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'32.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "32." 4.2
.\}

.sp

.nf
key_compare key_comp() const;
.fi

.sp
\fBEffects\fR: Returns the comparison object out of which a was constructed\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'33.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "33." 4.2
.\}

.sp

.nf
value_compare value_comp() const;
.fi

.sp
\fBEffects\fR: Returns an object of value_compare constructed out of the comparison object\&.
.sp
\fBComplexity\fR: Constant\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'34.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "34." 4.2
.\}
.\" end: Class template set
.\" Class template set: end
.\" find: Class template set
.\" Class template set: find

.sp

.nf
iterator find(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'35.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "35." 4.2
.\}
.\" end: Class template set
.\" Class template set: end
.\" find: Class template set
.\" Class template set: find

.sp

.nf
const_iterator find(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const_iterator pointing to an element with the key equivalent to x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04'36.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "36." 4.2
.\}
.\" count: Class template set
.\" Class template set: count

.sp

.nf
size_type count(const key_type & x) const;
.fi

.sp
\fBReturns\fR: The number of elements with key equivalent to x\&.
.sp
\fBComplexity\fR: log(size())+count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'37.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "37." 4.2
.\}
.\" count: Class template set
.\" Class template set: count

.sp

.nf
size_type count(const key_type & x);
.fi

.sp
\fBReturns\fR: The number of elements with key equivalent to x\&.
.sp
\fBComplexity\fR: log(size())+count(k)
.RE


.sp
.RS 4
.ie n \{\
\h'-04'38.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "38." 4.2
.\}
.\" lower_bound: Class template set
.\" Class template set: lower_bound

.sp

.nf
iterator lower_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'39.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "39." 4.2
.\}
.\" lower_bound: Class template set
.\" Class template set: lower_bound

.sp

.nf
const_iterator lower_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than k, or a\&.end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'40.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "40." 4.2
.\}
.\" end: Class template set
.\" Class template set: end
.\" upper_bound: Class template set
.\" Class template set: upper_bound

.sp

.nf
iterator upper_bound(const key_type & x);
.fi

.sp
\fBReturns\fR: An iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'41.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "41." 4.2
.\}
.\" end: Class template set
.\" Class template set: end
.\" upper_bound: Class template set
.\" Class template set: upper_bound

.sp

.nf
const_iterator upper_bound(const key_type & x) const;
.fi

.sp
\fBReturns\fR: A const iterator pointing to the first element with key not less than x, or end() if such an element is not found\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'42.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "42." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & x);
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'43.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "43." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & x) const;
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'44.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "44." 4.2
.\}

.sp

.nf
std::pair< iterator, iterator > equal_range(const key_type & x);
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'45.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "45." 4.2
.\}

.sp

.nf
std::pair< const_iterator, const_iterator > 
equal_range(const key_type & x) const;
.fi

.sp
\fBEffects\fR: Equivalent to std::make_pair(this\->lower_bound(k), this\->upper_bound(k))\&.
.sp
\fBComplexity\fR: Logarithmic
.RE


.sp
.RS 4
.ie n \{\
\h'-04'46.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "46." 4.2
.\}
.\" rebalance: Class template set
.\" Class template set: rebalance

.sp

.nf
void rebalance();
.fi

.sp
\fBEffects\fR: Rebalances the tree\&. It\'s a no\-op for Red\-Black and AVL trees\&.
.sp
\fBComplexity\fR: Linear
.RE

.SS "set friend functions"

.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}

.sp

.nf
friend bool operator==(const set & x, const set & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are equal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}

.sp

.nf
friend bool operator!=(const set & x, const set & y);
.fi

.sp
\fBEffects\fR: Returns true if x and y are unequal
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}

.sp

.nf
friend bool operator<(const set & x, const set & y);
.fi

.sp
\fBEffects\fR: Returns true if x is less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}

.sp

.nf
friend bool operator>(const set & x, const set & y);
.fi

.sp
\fBEffects\fR: Returns true if x is greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}

.sp

.nf
friend bool operator<=(const set & x, const set & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or less than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}

.sp

.nf
friend bool operator>=(const set & x, const set & y);
.fi

.sp
\fBEffects\fR: Returns true if x is equal or greater than y
.sp
\fBComplexity\fR: Linear to the number of elements in the container\&.
.RE


.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
.\" swap: Class template set
.\" Class template set: swap

.sp

.nf
friend void swap(set & x, set & y);
.fi

.sp
\fBEffects\fR: x\&.swap(y)
.sp
\fBComplexity\fR: Constant\&.
.RE


